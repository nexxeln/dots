{
  "version": 3,
  "sources": ["../../src/tools/list-processes.ts", "../../src/utils/process.ts", "../../src/utils/platform.ts"],
  "sourcesContent": ["import { Process } from \"../types\";\nimport { fetchRunningProcesses } from \"../utils/process\";\n\ntype SortOrder = \"asc\" | \"desc\";\ntype SortField = keyof Process;\n\ntype Input = {\n  /**\n   * Optional array of search terms to filter processes.\n   * For single process search, provide an array with one element.\n   * Example: [\"Logi\"] will find all processes containing \"Logi\" in their name\n   * Example: [\"Chrome\", \"Firefox\"] will find all processes containing either \"Chrome\" or \"Firefox\"\n   */\n  searchTerm?: string[];\n  /**\n   * Field to sort by (defaults to 'mem')\n   */\n  sortBy?: SortField;\n  /**\n   * Sort order (defaults to 'desc')\n   */\n  sortOrder?: SortOrder;\n};\n\nconst sortProcesses = (processes: Process[], field: SortField = \"mem\", order: SortOrder = \"desc\"): Process[] => {\n  return [...processes].sort((a, b) => {\n    const valueA = a[field];\n    const valueB = b[field];\n\n    if (valueA === valueB) return 0;\n    if (valueA === undefined) return 1;\n    if (valueB === undefined) return -1;\n\n    const comparison = valueA < valueB ? -1 : 1;\n    return order === \"desc\" ? -comparison : comparison;\n  });\n};\n\nconst filterProcessesBySearchTerm = (processes: Process[], searchTerms?: string[]): Process[] => {\n  if (!searchTerms?.length) return processes;\n\n  return processes.filter((p) => {\n    const searchIn = `${p.path} ${p.processName} ${p.appName || \"\"}`.toLowerCase();\n    return searchTerms.some((term) => searchIn.includes(term.toLowerCase()));\n  });\n};\n\nconst validateResults = (processes: Process[], searchTerms?: string[]): void => {\n  if (processes.length === 0 && searchTerms?.length) {\n    throw new Error(`No processes found matching \"${searchTerms.join(\", \")}\"`);\n  }\n};\n\n/**\n * List out all running processes.\n * This tool can be called by AI to answer queries like,\n * \"What processes are running right now?\"\n * or \"list processes containing xyz\"\n * or \"list processes containing xyz and abc\"\n *\n * Throws an error if no processes are found matching the search terms\n */\nexport default async function listProcesses(input?: Input): Promise<Process[]> {\n  const processes = await fetchRunningProcesses();\n\n  const filteredProcesses = filterProcessesBySearchTerm(processes, input?.searchTerm);\n  validateResults(filteredProcesses, input?.searchTerm);\n\n  return sortProcesses(filteredProcesses, input?.sortBy, input?.sortOrder);\n}\n", "import { exec } from \"child_process\";\nimport { Process } from \"../types\";\nimport {\n  isWindows,\n  getProcessListCommand,\n  getProcessPerformanceCommand,\n  parseProcessLine,\n  parseWindowsProcesses,\n  parseWindowsPerformanceData,\n  getProcessType,\n  getAppName,\n} from \"./platform\";\n\nconst EXEC_OPTIONS = { maxBuffer: 10 * 1024 * 1024 };\n\n/**\n * Fetch all running processes\n * On Windows, CPU values are placeholders (0) until fetchProcessPerformance() is called\n */\nexport async function fetchRunningProcesses(): Promise<Process[]> {\n  return new Promise((resolve, reject) => {\n    exec(getProcessListCommand(), EXEC_OPTIONS, (err, stdout) => {\n      if (err) {\n        reject(err);\n        return;\n      }\n\n      const parsed = isWindows\n        ? parseWindowsProcesses(stdout)\n        : (stdout.split(\"\\n\").map(parseProcessLine).filter(Boolean) as Partial<Process>[]);\n\n      const processes = parsed\n        .filter((p) => p?.processName)\n        .map((p) => {\n          const path = p.path || \"\";\n          const processName = p.processName || \"\";\n          const type = getProcessType(path);\n\n          return {\n            id: p.id || 0,\n            pid: p.pid || 0,\n            cpu: p.cpu || 0,\n            mem: p.mem || 0,\n            type,\n            path,\n            processName,\n            appName: type === \"app\" ? getAppName(path, processName) : undefined,\n          } as Process;\n        })\n        .filter((p) => p.processName !== \"\");\n\n      resolve(processes);\n    });\n  });\n}\n\n/**\n * Fetch CPU usage for all processes (Windows only)\n * Uses WMI performance counters for accurate real-time CPU percentage\n * Returns empty map on macOS (CPU is already included in fetchRunningProcesses)\n */\nexport async function fetchProcessPerformance(): Promise<Map<number, number>> {\n  if (!isWindows) {\n    return new Map();\n  }\n\n  return new Promise((resolve) => {\n    exec(getProcessPerformanceCommand(), EXEC_OPTIONS, (err, stdout) => {\n      if (err) {\n        console.error(\"Failed to fetch CPU performance data:\", err);\n        resolve(new Map());\n        return;\n      }\n      resolve(parseWindowsPerformanceData(stdout));\n    });\n  });\n}\n", "import { Image } from \"@raycast/api\";\nimport { Process } from \"../types\";\n\n/**\n * Platform detection\n */\nexport const platform = process.platform;\nexport const isMac = platform === \"darwin\";\nexport const isWindows = platform === \"win32\";\n\n/**\n * Encode a PowerShell script to Base64 for safe execution via -EncodedCommand\n * This avoids shell escaping issues with special characters like $\n */\nfunction encodePowerShellCommand(script: string): string {\n  return Buffer.from(script, \"utf16le\").toString(\"base64\");\n}\n\n/**\n * Windows PowerShell script to quickly list all processes\n * Returns: pid, name, cpu (placeholder 0), mem (KB), path\n * Note: CPU is set to 0 here; actual CPU usage comes from getProcessPerformanceCommand()\n */\nconst WINDOWS_PROCESS_LIST_SCRIPT = `\n$result = Get-Process | Where-Object { $_.Id -ne 0 } | ForEach-Object {\n  [PSCustomObject]@{\n    pid = $_.Id\n    name = $_.ProcessName\n    cpu = 0\n    mem = [math]::Round($_.WorkingSet64 / 1KB, 0)\n    path = if ($_.Path) { $_.Path } else { '' }\n  }\n}\n$result | ConvertTo-Json -Compress\n`;\n\n/**\n * Windows PowerShell script to fetch CPU usage via WMI performance counters\n * This is slower but provides accurate real-time CPU percentage\n * Returns: pid, cpu (percentage normalized by core count)\n */\nconst WINDOWS_CPU_PERFORMANCE_SCRIPT = `\n$cpuCores = (Get-CimInstance Win32_ComputerSystem).NumberOfLogicalProcessors\n$processes = Get-CimInstance Win32_PerfFormattedData_PerfProc_Process | Where-Object { $_.IDProcess -ne 0 -and $_.Name -ne '_Total' -and $_.Name -ne 'Idle' }\n$result = $processes | ForEach-Object {\n  [PSCustomObject]@{\n    pid = $_.IDProcess\n    cpu = [math]::Round($_.PercentProcessorTime / $cpuCores, 1)\n  }\n}\n$result | ConvertTo-Json -Compress\n`;\n\n/**\n * Get command to list all processes\n * - Windows: Uses Get-Process (fast, but CPU is placeholder)\n * - macOS: Uses ps command\n */\nexport function getProcessListCommand(): string {\n  if (isWindows) {\n    return `powershell -EncodedCommand ${encodePowerShellCommand(WINDOWS_PROCESS_LIST_SCRIPT)}`;\n  }\n  return \"ps -eo pid,ppid,pcpu,rss,comm\";\n}\n\n/**\n * Get command to fetch CPU performance data (Windows only)\n * Uses WMI which is slower but provides accurate real-time CPU usage\n */\nexport function getProcessPerformanceCommand(): string {\n  if (isWindows) {\n    return `powershell -EncodedCommand ${encodePowerShellCommand(WINDOWS_CPU_PERFORMANCE_SCRIPT)}`;\n  }\n  return \"ps -eo pid,ppid,pcpu,rss,comm\";\n}\n\n/**\n * Get command to kill a process\n */\nexport function getKillCommand(pid: number, force = false): string {\n  if (isWindows) {\n    return force ? `taskkill /F /PID ${pid}` : `taskkill /PID ${pid}`;\n  }\n  return force ? `zsh -c 'sudo kill -9 ${pid}'` : `kill -9 ${pid}`;\n}\n\n/**\n * Parse macOS ps command output line\n * Format: pid ppid cpu mem path\n */\nexport function parseProcessLine(line: string): Partial<Process> | null {\n  const trimmed = line.trim();\n  if (!trimmed) return null;\n\n  const match = trimmed.match(/(\\d+)\\s+(\\d+)\\s+(\\d+[.|,]\\d+)\\s+(\\d+)\\s+(.*)/);\n  if (!match) return null;\n\n  const [, id, pid, cpu, mem, path] = match;\n  return {\n    id: parseInt(id),\n    pid: parseInt(pid),\n    cpu: parseFloat(cpu),\n    mem: parseInt(mem),\n    path,\n    processName: path.match(/[^/]*$/)?.[0] ?? \"\",\n  };\n}\n\n/**\n * Parse Windows process list JSON output\n */\nexport function parseWindowsProcesses(output: string): Partial<Process>[] {\n  try {\n    const data = JSON.parse(output);\n    const processes = Array.isArray(data) ? data : [data];\n\n    return processes.map((proc: { pid: number; name: string; cpu: number; mem: number; path: string }) => ({\n      id: proc.pid,\n      pid: 0,\n      cpu: proc.cpu,\n      mem: proc.mem,\n      path: proc.path || \"\",\n      processName: proc.name || \"\",\n    }));\n  } catch {\n    console.error(\"Failed to parse Windows process output\");\n    return [];\n  }\n}\n\n/**\n * Parse Windows CPU performance data JSON output\n * Returns map of process ID to CPU percentage\n */\nexport function parseWindowsPerformanceData(output: string): Map<number, number> {\n  const cpuMap = new Map<number, number>();\n  try {\n    const data = JSON.parse(output);\n    const processes = Array.isArray(data) ? data : [data];\n\n    for (const proc of processes) {\n      if (proc?.pid) {\n        cpuMap.set(proc.pid, proc.cpu ?? 0);\n      }\n    }\n  } catch {\n    console.error(\"Failed to parse Windows performance output\");\n  }\n  return cpuMap;\n}\n\n/**\n * Detect process type based on path\n */\nexport function getProcessType(path: string): Process[\"type\"] {\n  if (isMac) {\n    if (path.includes(\".prefPane\")) return \"prefPane\";\n    if (path.includes(\".app/\")) return \"app\";\n    return \"binary\";\n  }\n\n  if (isWindows) {\n    const lowerPath = path.toLowerCase();\n    const isApp =\n      lowerPath.endsWith(\".exe\") && (lowerPath.includes(\"program files\") || lowerPath.includes(\"applications\"));\n    return isApp ? \"app\" : \"binary\";\n  }\n\n  return \"binary\";\n}\n\n/**\n * Extract application name from path\n */\nexport function getAppName(path: string, processName: string): string | undefined {\n  if (isMac) {\n    return path.match(/(?<=\\/)[^/]+(?=\\.app\\/)/)?.[0];\n  }\n  if (isWindows) {\n    return processName.replace(/\\.exe$/i, \"\");\n  }\n  return processName;\n}\n\n/**\n * Get file icon for a process\n */\nexport function getFileIcon(process: Process): Image.ImageLike {\n  if (isMac) {\n    if (process.type === \"prefPane\") {\n      return { fileIcon: process.path?.replace(/(.+\\.prefPane)(.+)/, \"$1\") ?? \"\" };\n    }\n    if (process.type === \"app\" || process.type === \"aggregatedApp\") {\n      return { fileIcon: process.path?.replace(/(.+\\.app)(.+)/, \"$1\") ?? \"\" };\n    }\n    return \"/System/Library/CoreServices/CoreTypes.bundle/Contents/Resources/ExecutableBinaryIcon.icns\";\n  }\n\n  if (isWindows) {\n    if (process.type === \"app\") {\n      return { fileIcon: process.path };\n    }\n    return \"\uD83D\uDDA5\uFE0F\";\n  }\n\n  return \"\u2699\uFE0F\";\n}\n\n/**\n * Get error help message for failed kill attempts\n */\nexport function getPlatformSpecificErrorHelp(isForceKill: boolean): {\n  title: string;\n  message?: string;\n  helpUrl?: string;\n} {\n  if (isMac && isForceKill) {\n    return {\n      title: \"Failed to Force Kill Process\",\n      message: \"Please ensure that touch ID/password prompt is enabled for sudo\",\n      helpUrl: \"https://dev.to/siddhantkcode/enable-touch-id-authentication-for-sudo-on-macos-sonoma-14x-4d28\",\n    };\n  }\n\n  if (isWindows && isForceKill) {\n    return {\n      title: \"Failed to Force Kill Process\",\n      message: \"Administrative privileges may be required. Try running as administrator.\",\n    };\n  }\n\n  return {\n    title: \"Failed to Kill Process\",\n    message: \"The process could not be terminated. It may have already exited or require elevated privileges.\",\n  };\n}\n"],
  "mappings": "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",
  "names": ["list_processes_exports", "__export", "listProcesses", "__toCommonJS", "import_child_process", "platform", "isMac", "isWindows", "encodePowerShellCommand", "script", "WINDOWS_PROCESS_LIST_SCRIPT", "getProcessListCommand", "isWindows", "encodePowerShellCommand", "WINDOWS_PROCESS_LIST_SCRIPT", "parseProcessLine", "line", "trimmed", "match", "id", "pid", "cpu", "mem", "path", "parseWindowsProcesses", "output", "data", "proc", "getProcessType", "path", "isMac", "isWindows", "lowerPath", "getAppName", "processName", "EXEC_OPTIONS", "fetchRunningProcesses", "resolve", "reject", "getProcessListCommand", "err", "stdout", "processes", "isWindows", "parseWindowsProcesses", "parseProcessLine", "p", "path", "processName", "type", "getProcessType", "getAppName", "sortProcesses", "processes", "field", "order", "a", "b", "valueA", "valueB", "comparison", "filterProcessesBySearchTerm", "searchTerms", "p", "searchIn", "term", "validateResults", "listProcesses", "input", "fetchRunningProcesses", "filteredProcesses"]
}
