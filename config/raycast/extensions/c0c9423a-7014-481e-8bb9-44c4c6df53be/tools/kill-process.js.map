{
  "version": 3,
  "sources": ["../../src/tools/kill-process.ts", "../../src/utils/platform.ts"],
  "sourcesContent": ["import { exec } from \"child_process\";\nimport { Tool } from \"@raycast/api\";\nimport { getKillCommand, getPlatformSpecificErrorHelp } from \"../utils/platform\";\n\n/**\n * Input type for killing a process\n */\ntype Input = {\n  /**\n   * App name to kill\n   */\n  processName?: string;\n\n  /**\n   * Process ID to kill\n   */\n  id: number;\n\n  /**\n   * Path to the process to kill\n   */\n  path?: string;\n\n  /**\n   * Whether to force kill the process (requires elevated privileges)\n   */\n  force?: boolean;\n};\n\n/**\n * Kill a process.\n * Provide the process ID to kill.\n * If the process is not found, the tool will return an error.\n */\nexport default async function killProcess(input: Input) {\n  return new Promise((resolve, reject) => {\n    const command = getKillCommand(input.id, input.force);\n\n    exec(command, (killErr) => {\n      if (killErr) {\n        const errorHelp = getPlatformSpecificErrorHelp(input.force || false);\n        const error = new Error(`${errorHelp.title}: ${killErr.message}`);\n        reject(error);\n        return;\n      }\n\n      const processInfo = input.processName ? `${input.processName} ` : \"\";\n      resolve({\n        success: true,\n        message: `Killed process: ${processInfo}(PID: ${input.id})`,\n      });\n    });\n  });\n}\n\n/**\n * Because forcibly killing a process can cause data loss or undesired system changes,\n * let's ask for user confirmation before proceeding.\n */\nexport const confirmation: Tool.Confirmation<Input> = async (input: Input) => {\n  const info: { name: string; value: string }[] = [];\n\n  // Only add Process Name if it's provided and non-empty\n  if (input.processName) {\n    info.push({ name: \"Process Name\", value: input.processName });\n  }\n\n  // Always add PID as it's required\n  info.push({ name: \"PID\", value: String(input.id) });\n\n  // Only add Path if it's provided and non-empty\n  if (input.path) {\n    info.push({ name: \"Path\", value: input.path });\n  }\n\n  return { info };\n};\n", "import { Image } from \"@raycast/api\";\nimport { Process } from \"../types\";\n\n/**\n * Platform detection\n */\nexport const platform = process.platform;\nexport const isMac = platform === \"darwin\";\nexport const isWindows = platform === \"win32\";\n\n/**\n * Encode a PowerShell script to Base64 for safe execution via -EncodedCommand\n * This avoids shell escaping issues with special characters like $\n */\nfunction encodePowerShellCommand(script: string): string {\n  return Buffer.from(script, \"utf16le\").toString(\"base64\");\n}\n\n/**\n * Windows PowerShell script to quickly list all processes\n * Returns: pid, name, cpu (placeholder 0), mem (KB), path\n * Note: CPU is set to 0 here; actual CPU usage comes from getProcessPerformanceCommand()\n */\nconst WINDOWS_PROCESS_LIST_SCRIPT = `\n$result = Get-Process | Where-Object { $_.Id -ne 0 } | ForEach-Object {\n  [PSCustomObject]@{\n    pid = $_.Id\n    name = $_.ProcessName\n    cpu = 0\n    mem = [math]::Round($_.WorkingSet64 / 1KB, 0)\n    path = if ($_.Path) { $_.Path } else { '' }\n  }\n}\n$result | ConvertTo-Json -Compress\n`;\n\n/**\n * Windows PowerShell script to fetch CPU usage via WMI performance counters\n * This is slower but provides accurate real-time CPU percentage\n * Returns: pid, cpu (percentage normalized by core count)\n */\nconst WINDOWS_CPU_PERFORMANCE_SCRIPT = `\n$cpuCores = (Get-CimInstance Win32_ComputerSystem).NumberOfLogicalProcessors\n$processes = Get-CimInstance Win32_PerfFormattedData_PerfProc_Process | Where-Object { $_.IDProcess -ne 0 -and $_.Name -ne '_Total' -and $_.Name -ne 'Idle' }\n$result = $processes | ForEach-Object {\n  [PSCustomObject]@{\n    pid = $_.IDProcess\n    cpu = [math]::Round($_.PercentProcessorTime / $cpuCores, 1)\n  }\n}\n$result | ConvertTo-Json -Compress\n`;\n\n/**\n * Get command to list all processes\n * - Windows: Uses Get-Process (fast, but CPU is placeholder)\n * - macOS: Uses ps command\n */\nexport function getProcessListCommand(): string {\n  if (isWindows) {\n    return `powershell -EncodedCommand ${encodePowerShellCommand(WINDOWS_PROCESS_LIST_SCRIPT)}`;\n  }\n  return \"ps -eo pid,ppid,pcpu,rss,comm\";\n}\n\n/**\n * Get command to fetch CPU performance data (Windows only)\n * Uses WMI which is slower but provides accurate real-time CPU usage\n */\nexport function getProcessPerformanceCommand(): string {\n  if (isWindows) {\n    return `powershell -EncodedCommand ${encodePowerShellCommand(WINDOWS_CPU_PERFORMANCE_SCRIPT)}`;\n  }\n  return \"ps -eo pid,ppid,pcpu,rss,comm\";\n}\n\n/**\n * Get command to kill a process\n */\nexport function getKillCommand(pid: number, force = false): string {\n  if (isWindows) {\n    return force ? `taskkill /F /PID ${pid}` : `taskkill /PID ${pid}`;\n  }\n  return force ? `zsh -c 'sudo kill -9 ${pid}'` : `kill -9 ${pid}`;\n}\n\n/**\n * Parse macOS ps command output line\n * Format: pid ppid cpu mem path\n */\nexport function parseProcessLine(line: string): Partial<Process> | null {\n  const trimmed = line.trim();\n  if (!trimmed) return null;\n\n  const match = trimmed.match(/(\\d+)\\s+(\\d+)\\s+(\\d+[.|,]\\d+)\\s+(\\d+)\\s+(.*)/);\n  if (!match) return null;\n\n  const [, id, pid, cpu, mem, path] = match;\n  return {\n    id: parseInt(id),\n    pid: parseInt(pid),\n    cpu: parseFloat(cpu),\n    mem: parseInt(mem),\n    path,\n    processName: path.match(/[^/]*$/)?.[0] ?? \"\",\n  };\n}\n\n/**\n * Parse Windows process list JSON output\n */\nexport function parseWindowsProcesses(output: string): Partial<Process>[] {\n  try {\n    const data = JSON.parse(output);\n    const processes = Array.isArray(data) ? data : [data];\n\n    return processes.map((proc: { pid: number; name: string; cpu: number; mem: number; path: string }) => ({\n      id: proc.pid,\n      pid: 0,\n      cpu: proc.cpu,\n      mem: proc.mem,\n      path: proc.path || \"\",\n      processName: proc.name || \"\",\n    }));\n  } catch {\n    console.error(\"Failed to parse Windows process output\");\n    return [];\n  }\n}\n\n/**\n * Parse Windows CPU performance data JSON output\n * Returns map of process ID to CPU percentage\n */\nexport function parseWindowsPerformanceData(output: string): Map<number, number> {\n  const cpuMap = new Map<number, number>();\n  try {\n    const data = JSON.parse(output);\n    const processes = Array.isArray(data) ? data : [data];\n\n    for (const proc of processes) {\n      if (proc?.pid) {\n        cpuMap.set(proc.pid, proc.cpu ?? 0);\n      }\n    }\n  } catch {\n    console.error(\"Failed to parse Windows performance output\");\n  }\n  return cpuMap;\n}\n\n/**\n * Detect process type based on path\n */\nexport function getProcessType(path: string): Process[\"type\"] {\n  if (isMac) {\n    if (path.includes(\".prefPane\")) return \"prefPane\";\n    if (path.includes(\".app/\")) return \"app\";\n    return \"binary\";\n  }\n\n  if (isWindows) {\n    const lowerPath = path.toLowerCase();\n    const isApp =\n      lowerPath.endsWith(\".exe\") && (lowerPath.includes(\"program files\") || lowerPath.includes(\"applications\"));\n    return isApp ? \"app\" : \"binary\";\n  }\n\n  return \"binary\";\n}\n\n/**\n * Extract application name from path\n */\nexport function getAppName(path: string, processName: string): string | undefined {\n  if (isMac) {\n    return path.match(/(?<=\\/)[^/]+(?=\\.app\\/)/)?.[0];\n  }\n  if (isWindows) {\n    return processName.replace(/\\.exe$/i, \"\");\n  }\n  return processName;\n}\n\n/**\n * Get file icon for a process\n */\nexport function getFileIcon(process: Process): Image.ImageLike {\n  if (isMac) {\n    if (process.type === \"prefPane\") {\n      return { fileIcon: process.path?.replace(/(.+\\.prefPane)(.+)/, \"$1\") ?? \"\" };\n    }\n    if (process.type === \"app\" || process.type === \"aggregatedApp\") {\n      return { fileIcon: process.path?.replace(/(.+\\.app)(.+)/, \"$1\") ?? \"\" };\n    }\n    return \"/System/Library/CoreServices/CoreTypes.bundle/Contents/Resources/ExecutableBinaryIcon.icns\";\n  }\n\n  if (isWindows) {\n    if (process.type === \"app\") {\n      return { fileIcon: process.path };\n    }\n    return \"\uD83D\uDDA5\uFE0F\";\n  }\n\n  return \"\u2699\uFE0F\";\n}\n\n/**\n * Get error help message for failed kill attempts\n */\nexport function getPlatformSpecificErrorHelp(isForceKill: boolean): {\n  title: string;\n  message?: string;\n  helpUrl?: string;\n} {\n  if (isMac && isForceKill) {\n    return {\n      title: \"Failed to Force Kill Process\",\n      message: \"Please ensure that touch ID/password prompt is enabled for sudo\",\n      helpUrl: \"https://dev.to/siddhantkcode/enable-touch-id-authentication-for-sudo-on-macos-sonoma-14x-4d28\",\n    };\n  }\n\n  if (isWindows && isForceKill) {\n    return {\n      title: \"Failed to Force Kill Process\",\n      message: \"Administrative privileges may be required. Try running as administrator.\",\n    };\n  }\n\n  return {\n    title: \"Failed to Kill Process\",\n    message: \"The process could not be terminated. It may have already exited or require elevated privileges.\",\n  };\n}\n"],
  "mappings": "yaAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,kBAAAE,EAAA,YAAAC,IAAA,eAAAC,EAAAJ,GAAA,IAAAK,EAAqB,yBCMd,IAAMC,EAAW,QAAQ,SACnBC,EAAQD,IAAa,SACrBE,EAAYF,IAAa,QAuE/B,SAASG,EAAeC,EAAaC,EAAQ,GAAe,CACjE,OAAIC,EACKD,EAAQ,oBAAoBD,CAAG,GAAK,iBAAiBA,CAAG,GAE1DC,EAAQ,wBAAwBD,CAAG,IAAM,WAAWA,CAAG,EAChE,CA+HO,SAASG,EAA6BC,EAI3C,CACA,OAAIC,GAASD,EACJ,CACL,MAAO,+BACP,QAAS,kEACT,QAAS,+FACX,EAGEE,GAAaF,EACR,CACL,MAAO,+BACP,QAAS,0EACX,EAGK,CACL,MAAO,yBACP,QAAS,iGACX,CACF,CDzMA,eAAOG,EAAmCC,EAAc,CACtD,OAAO,IAAI,QAAQ,CAACC,EAASC,IAAW,CACtC,IAAMC,EAAUC,EAAeJ,EAAM,GAAIA,EAAM,KAAK,KAEpD,QAAKG,EAAUE,GAAY,CACzB,GAAIA,EAAS,CACX,IAAMC,EAAYC,EAA6BP,EAAM,OAAS,EAAK,EAC7DQ,EAAQ,IAAI,MAAM,GAAGF,EAAU,KAAK,KAAKD,EAAQ,OAAO,EAAE,EAChEH,EAAOM,CAAK,EACZ,MACF,CAEA,IAAMC,EAAcT,EAAM,YAAc,GAAGA,EAAM,WAAW,IAAM,GAClEC,EAAQ,CACN,QAAS,GACT,QAAS,mBAAmBQ,CAAW,SAAST,EAAM,EAAE,GAC1D,CAAC,CACH,CAAC,CACH,CAAC,CACH,CAMO,IAAMU,EAAyC,MAAOV,GAAiB,CAC5E,IAAMW,EAA0C,CAAC,EAGjD,OAAIX,EAAM,aACRW,EAAK,KAAK,CAAE,KAAM,eAAgB,MAAOX,EAAM,WAAY,CAAC,EAI9DW,EAAK,KAAK,CAAE,KAAM,MAAO,MAAO,OAAOX,EAAM,EAAE,CAAE,CAAC,EAG9CA,EAAM,MACRW,EAAK,KAAK,CAAE,KAAM,OAAQ,MAAOX,EAAM,IAAK,CAAC,EAGxC,CAAE,KAAAW,CAAK,CAChB",
  "names": ["kill_process_exports", "__export", "confirmation", "killProcess", "__toCommonJS", "import_child_process", "platform", "isMac", "isWindows", "getKillCommand", "pid", "force", "isWindows", "getPlatformSpecificErrorHelp", "isForceKill", "isMac", "isWindows", "killProcess", "input", "resolve", "reject", "command", "getKillCommand", "killErr", "errorHelp", "getPlatformSpecificErrorHelp", "error", "processInfo", "confirmation", "info"]
}
