{
  "version": 3,
  "sources": ["../node_modules/@chrismessina/raycast-logger/src/redaction.ts", "../node_modules/@chrismessina/raycast-logger/src/logger.ts", "../node_modules/@chrismessina/raycast-logger/src/index.ts", "../node_modules/stream-chain/index.js", "../node_modules/stream-json/utils/Utf8Stream.js", "../node_modules/stream-json/Parser.js", "../node_modules/stream-json/utils/emit.js", "../node_modules/stream-json/index.js", "../node_modules/stream-json/filters/FilterBase.js", "../node_modules/stream-json/utils/withParser.js", "../node_modules/stream-json/filters/Filter.js", "../node_modules/stream-json/Assembler.js", "../node_modules/stream-json/streamers/StreamBase.js", "../node_modules/stream-json/streamers/StreamArray.js", "../node_modules/stream-json/filters/Pick.js", "../node_modules/stream-json/streamers/StreamObject.js", "../src/clean-up.tsx", "../src/utils/brew/paths.ts", "../src/utils/preferences.ts", "../src/utils/brew/commands.ts", "../src/utils/logger.ts", "../src/utils/errors.ts", "../src/utils/cache.ts", "../src/utils/async.ts", "../src/utils/brew/progress.ts", "../src/utils/brew/internal-api.ts", "../src/utils/memory.ts", "../src/utils/brew/fetch.ts", "../src/utils/brew/actions.ts", "../src/utils/toast.ts", "../src/utils/array.ts"],
  "sourcesContent": [null, null, null, "'use strict';\n\nconst {Readable, Writable, Duplex, Transform} = require('stream');\n\nconst none = Symbol.for('object-stream.none');\nconst finalSymbol = Symbol.for('object-stream.final');\nconst manySymbol = Symbol.for('object-stream.many');\n\nconst final = value => ({[finalSymbol]: value});\nconst many = values => ({[manySymbol]: values});\n\nconst isFinal = o => o && typeof o == 'object' && finalSymbol in o;\nconst isMany = o => o && typeof o == 'object' && manySymbol in o;\n\nconst getFinalValue = o => o[finalSymbol];\nconst getManyValues = o => o[manySymbol];\n\nconst runAsyncGenerator = async (gen, stream) => {\n  for (;;) {\n    let data = gen.next();\n    if (data && typeof data.then == 'function') {\n      data = await data;\n    }\n    if (data.done) break;\n    let value = data.value;\n    if (value && typeof value.then == 'function') {\n      value = await value;\n    }\n    Chain.sanitize(value, stream);\n  }\n};\n\nconst wrapFunction = fn =>\n  new Transform({\n    writableObjectMode: true,\n    readableObjectMode: true,\n    transform(chunk, encoding, callback) {\n      try {\n        const result = fn.call(this, chunk, encoding);\n        if (result && typeof result.then == 'function') {\n          // thenable\n          result.then(\n            result => (Chain.sanitize(result, this), callback(null)),\n            error => callback(error)\n          );\n          return;\n        }\n        if (result && typeof result.next == 'function') {\n          // generator\n          runAsyncGenerator(result, this).then(\n            () => callback(null),\n            error => callback(error)\n          );\n          return;\n        }\n        Chain.sanitize(result, this);\n        callback(null);\n      } catch (error) {\n        callback(error);\n      }\n    }\n  });\n\nconst wrapArray = fns =>\n  new Transform({\n    writableObjectMode: true,\n    readableObjectMode: true,\n    transform(chunk, encoding, callback) {\n      try {\n        let value = chunk;\n        for (let i = 0; i < fns.length; ++i) {\n          const result = fns[i].call(this, value, encoding);\n          if (result === Chain.none) {\n            callback(null);\n            return;\n          }\n          if (Chain.isFinal(result)) {\n            value = Chain.getFinalValue(result);\n            break;\n          }\n          value = result;\n        }\n        Chain.sanitize(value, this);\n        callback(null);\n      } catch (error) {\n        callback(error);\n      }\n    }\n  });\n\n// is*NodeStream functions taken from https://github.com/nodejs/node/blob/master/lib/internal/streams/utils.js\nconst isReadableNodeStream = obj =>\n  obj &&\n  typeof obj.pipe === 'function' &&\n  typeof obj.on === 'function' &&\n  (!obj._writableState || (typeof obj._readableState === 'object' ? obj._readableState.readable : null) !== false) && // Duplex\n  (!obj._writableState || obj._readableState); // Writable has .pipe.\n\nconst isWritableNodeStream = obj =>\n  obj &&\n  typeof obj.write === 'function' &&\n  typeof obj.on === 'function' &&\n  (!obj._readableState || (typeof obj._writableState === 'object' ? obj._writableState.writable : null) !== false); // Duplex\n\nconst isDuplexNodeStream = obj =>\n  obj && typeof obj.pipe === 'function' && obj._readableState && typeof obj.on === 'function' && typeof obj.write === 'function';\n\nclass Chain extends Duplex {\n  constructor(fns, options) {\n    super(options || {writableObjectMode: true, readableObjectMode: true});\n\n    if (!(fns instanceof Array) || !fns.length) {\n      throw Error(\"Chain's argument should be a non-empty array.\");\n    }\n\n    this.streams = fns\n      .filter(fn => fn)\n      .map((fn, index, fns) => {\n        if (typeof fn === 'function' || fn instanceof Array) return Chain.convertToTransform(fn);\n        if (isDuplexNodeStream(fn) || (!index && isReadableNodeStream(fn)) || (index === fns.length - 1 && isWritableNodeStream(fn))) {\n          return fn;\n        }\n        throw Error('Arguments should be functions, arrays or streams.');\n      })\n      .filter(s => s);\n    this.input = this.streams[0];\n    this.output = this.streams.reduce((output, stream) => (output && output.pipe(stream)) || stream);\n\n    if (!isWritableNodeStream(this.input)) {\n      this._write = (_1, _2, callback) => callback(null);\n      this._final = callback => callback(null); // unavailable in Node 6\n      this.input.on('end', () => this.end());\n    }\n\n    if (isReadableNodeStream(this.output)) {\n      this.output.on('data', chunk => !this.push(chunk) && this.output.pause());\n      this.output.on('end', () => this.push(null));\n    } else {\n      this._read = () => {}; // nop\n      this.resume();\n      this.output.on('finish', () => this.push(null));\n    }\n\n    // connect events\n    if (!options || !options.skipEvents) {\n      this.streams.forEach(stream => stream.on('error', error => this.emit('error', error)));\n    }\n  }\n  _write(chunk, encoding, callback) {\n    let error = null;\n    try {\n      this.input.write(chunk, encoding, e => callback(e || error));\n    } catch (e) {\n      error = e;\n    }\n  }\n  _final(callback) {\n    let error = null;\n    try {\n      this.input.end(null, null, e => callback(e || error));\n    } catch (e) {\n      error = e;\n    }\n  }\n  _read() {\n    this.output.resume();\n  }\n  static make(fns, options) {\n    return new Chain(fns, options);\n  }\n  static sanitize(result, stream) {\n    if (Chain.isFinal(result)) {\n      result = Chain.getFinalValue(result);\n    } else if (Chain.isMany(result)) {\n      result = Chain.getManyValues(result);\n    }\n    if (result !== undefined && result !== null && result !== Chain.none) {\n      if (result instanceof Array) {\n        result.forEach(value => value !== undefined && value !== null && stream.push(value));\n      } else {\n        stream.push(result);\n      }\n    }\n  }\n  static convertToTransform(fn) {\n    if (typeof fn === 'function') return wrapFunction(fn);\n    if (fn instanceof Array) return fn.length ? wrapArray(fn) : null;\n    return null;\n  }\n}\n\nChain.none = none;\nChain.final = final;\nChain.isFinal = isFinal;\nChain.getFinalValue = getFinalValue;\nChain.many = many;\nChain.isMany = isMany;\nChain.getManyValues = getManyValues;\n\nChain.chain = Chain.make;\nChain.make.Constructor = Chain;\n\nmodule.exports = Chain;\n", "'use strict';\n\nconst {Transform} = require('stream');\nconst {StringDecoder} = require('string_decoder');\n\nclass Utf8Stream extends Transform {\n  constructor(options) {\n    super(Object.assign({}, options, {writableObjectMode: false}));\n    this._buffer = '';\n  }\n\n  _transform(chunk, encoding, callback) {\n    if (typeof chunk == 'string') {\n      this._transform = this._transformString;\n    } else {\n      this._stringDecoder = new StringDecoder();\n      this._transform = this._transformBuffer;\n    }\n    this._transform(chunk, encoding, callback);\n  }\n\n  _transformBuffer(chunk, _, callback) {\n    this._buffer += this._stringDecoder.write(chunk);\n    this._processBuffer(callback);\n  }\n\n  _transformString(chunk, _, callback) {\n    this._buffer += chunk.toString();\n    this._processBuffer(callback);\n  }\n\n  _processBuffer(callback) {\n    if (this._buffer) {\n      this.push(this._buffer, 'utf8');\n      this._buffer = '';\n    }\n    callback(null);\n  }\n\n  _flushInput() {\n    // meant to be called from _flush()\n    if (this._stringDecoder) {\n      this._buffer += this._stringDecoder.end();\n    }\n  }\n\n  _flush(callback) {\n    this._flushInput();\n    this._processBuffer(callback);\n  }\n}\n\nmodule.exports = Utf8Stream;\n", "'use strict';\n\nconst Utf8Stream = require('./utils/Utf8Stream');\n\nconst patterns = {\n  value1: /^(?:[\\\"\\{\\[\\]\\-\\d]|true\\b|false\\b|null\\b|\\s{1,256})/,\n  string: /^(?:[^\\x00-\\x1f\\\"\\\\]{1,256}|\\\\[bfnrt\\\"\\\\\\/]|\\\\u[\\da-fA-F]{4}|\\\")/,\n  key1: /^(?:[\\\"\\}]|\\s{1,256})/,\n  colon: /^(?:\\:|\\s{1,256})/,\n  comma: /^(?:[\\,\\]\\}]|\\s{1,256})/,\n  ws: /^\\s{1,256}/,\n  numberStart: /^\\d/,\n  numberDigit: /^\\d{0,256}/,\n  numberFraction: /^[\\.eE]/,\n  numberExponent: /^[eE]/,\n  numberExpSign: /^[-+]/\n};\nconst MAX_PATTERN_SIZE = 16;\n\nlet noSticky = true;\ntry {\n  new RegExp('.', 'y');\n  noSticky = false;\n} catch (e) {\n  // suppress\n}\n\n!noSticky &&\n  Object.keys(patterns).forEach(key => {\n    let src = patterns[key].source.slice(1); // lop off ^\n    if (src.slice(0, 3) === '(?:' && src.slice(-1) === ')') {\n      src = src.slice(3, -1);\n    }\n    patterns[key] = new RegExp(src, 'y');\n  });\n\npatterns.numberFracStart = patterns.numberExpStart = patterns.numberStart;\npatterns.numberFracDigit = patterns.numberExpDigit = patterns.numberDigit;\n\nconst values = {true: true, false: false, null: null},\n  expected = {object: 'objectStop', array: 'arrayStop', '': 'done'};\n\n// long hexadecimal codes: \\uXXXX\nconst fromHex = s => String.fromCharCode(parseInt(s.slice(2), 16));\n\n// short codes: \\b \\f \\n \\r \\t \\\" \\\\ \\/\nconst codes = {b: '\\b', f: '\\f', n: '\\n', r: '\\r', t: '\\t', '\"': '\"', '\\\\': '\\\\', '/': '/'};\n\nclass Parser extends Utf8Stream {\n  static make(options) {\n    return new Parser(options);\n  }\n\n  constructor(options) {\n    super(Object.assign({}, options, {readableObjectMode: true}));\n\n    this._packKeys = this._packStrings = this._packNumbers = this._streamKeys = this._streamStrings = this._streamNumbers = true;\n    if (options) {\n      'packValues' in options && (this._packKeys = this._packStrings = this._packNumbers = options.packValues);\n      'packKeys' in options && (this._packKeys = options.packKeys);\n      'packStrings' in options && (this._packStrings = options.packStrings);\n      'packNumbers' in options && (this._packNumbers = options.packNumbers);\n      'streamValues' in options && (this._streamKeys = this._streamStrings = this._streamNumbers = options.streamValues);\n      'streamKeys' in options && (this._streamKeys = options.streamKeys);\n      'streamStrings' in options && (this._streamStrings = options.streamStrings);\n      'streamNumbers' in options && (this._streamNumbers = options.streamNumbers);\n      this._jsonStreaming = options.jsonStreaming;\n    }\n    !this._packKeys && (this._streamKeys = true);\n    !this._packStrings && (this._streamStrings = true);\n    !this._packNumbers && (this._streamNumbers = true);\n\n    this._done = false;\n    this._expect = this._jsonStreaming ? 'done' : 'value';\n    this._stack = [];\n    this._parent = '';\n    this._open_number = false;\n    this._accumulator = '';\n  }\n\n  _flush(callback) {\n    this._done = true;\n    super._flush(error => {\n      if (error) return callback(error);\n      if (this._open_number) {\n        if (this._streamNumbers) {\n          this.push({name: 'endNumber'});\n        }\n        this._open_number = false;\n        if (this._packNumbers) {\n          this.push({name: 'numberValue', value: this._accumulator});\n          this._accumulator = '';\n        }\n      }\n      callback(null);\n    });\n  }\n\n  _processBuffer(callback) {\n    let match,\n      value,\n      index = 0;\n    main: for (;;) {\n      switch (this._expect) {\n        case 'value1':\n        case 'value':\n          patterns.value1.lastIndex = index;\n          match = patterns.value1.exec(this._buffer);\n          if (!match) {\n            if (this._done || index + MAX_PATTERN_SIZE < this._buffer.length) {\n              if (index < this._buffer.length) return callback(new Error('Parser cannot parse input: expected a value'));\n              return callback(new Error('Parser has expected a value'));\n            }\n            break main; // wait for more input\n          }\n          value = match[0];\n          switch (value) {\n            case '\"':\n              this._streamStrings && this.push({name: 'startString'});\n              this._expect = 'string';\n              break;\n            case '{':\n              this.push({name: 'startObject'});\n              this._stack.push(this._parent);\n              this._parent = 'object';\n              this._expect = 'key1';\n              break;\n            case '[':\n              this.push({name: 'startArray'});\n              this._stack.push(this._parent);\n              this._parent = 'array';\n              this._expect = 'value1';\n              break;\n            case ']':\n              if (this._expect !== 'value1') return callback(new Error(\"Parser cannot parse input: unexpected token ']'\"));\n              if (this._open_number) {\n                this._streamNumbers && this.push({name: 'endNumber'});\n                this._open_number = false;\n                if (this._packNumbers) {\n                  this.push({name: 'numberValue', value: this._accumulator});\n                  this._accumulator = '';\n                }\n              }\n              this.push({name: 'endArray'});\n              this._parent = this._stack.pop();\n              this._expect = expected[this._parent];\n              break;\n            case '-':\n              this._open_number = true;\n              if (this._streamNumbers) {\n                this.push({name: 'startNumber'});\n                this.push({name: 'numberChunk', value: '-'});\n              }\n              this._packNumbers && (this._accumulator = '-');\n              this._expect = 'numberStart';\n              break;\n            case '0':\n              this._open_number = true;\n              if (this._streamNumbers) {\n                this.push({name: 'startNumber'});\n                this.push({name: 'numberChunk', value: '0'});\n              }\n              this._packNumbers && (this._accumulator = '0');\n              this._expect = 'numberFraction';\n              break;\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n              this._open_number = true;\n              if (this._streamNumbers) {\n                this.push({name: 'startNumber'});\n                this.push({name: 'numberChunk', value: value});\n              }\n              this._packNumbers && (this._accumulator = value);\n              this._expect = 'numberDigit';\n              break;\n            case 'true':\n            case 'false':\n            case 'null':\n              if (this._buffer.length - index === value.length && !this._done) break main; // wait for more input\n              this.push({name: value + 'Value', value: values[value]});\n              this._expect = expected[this._parent];\n              break;\n            // default: // ws\n          }\n          if (noSticky) {\n            this._buffer = this._buffer.slice(value.length);\n          } else {\n            index += value.length;\n          }\n          break;\n        case 'keyVal':\n        case 'string':\n          patterns.string.lastIndex = index;\n          match = patterns.string.exec(this._buffer);\n          if (!match) {\n            if (index < this._buffer.length && (this._done || this._buffer.length - index >= 6))\n              return callback(new Error('Parser cannot parse input: escaped characters'));\n            if (this._done) return callback(new Error('Parser has expected a string value'));\n            break main; // wait for more input\n          }\n          value = match[0];\n          if (value === '\"') {\n            if (this._expect === 'keyVal') {\n              this._streamKeys && this.push({name: 'endKey'});\n              if (this._packKeys) {\n                this.push({name: 'keyValue', value: this._accumulator});\n                this._accumulator = '';\n              }\n              this._expect = 'colon';\n            } else {\n              this._streamStrings && this.push({name: 'endString'});\n              if (this._packStrings) {\n                this.push({name: 'stringValue', value: this._accumulator});\n                this._accumulator = '';\n              }\n              this._expect = expected[this._parent];\n            }\n          } else if (value.length > 1 && value.charAt(0) === '\\\\') {\n            const t = value.length == 2 ? codes[value.charAt(1)] : fromHex(value);\n            if (this._expect === 'keyVal' ? this._streamKeys : this._streamStrings) {\n              this.push({name: 'stringChunk', value: t});\n            }\n            if (this._expect === 'keyVal' ? this._packKeys : this._packStrings) {\n              this._accumulator += t;\n            }\n          } else {\n            if (this._expect === 'keyVal' ? this._streamKeys : this._streamStrings) {\n              this.push({name: 'stringChunk', value: value});\n            }\n            if (this._expect === 'keyVal' ? this._packKeys : this._packStrings) {\n              this._accumulator += value;\n            }\n          }\n          if (noSticky) {\n            this._buffer = this._buffer.slice(value.length);\n          } else {\n            index += value.length;\n          }\n          break;\n        case 'key1':\n        case 'key':\n          patterns.key1.lastIndex = index;\n          match = patterns.key1.exec(this._buffer);\n          if (!match) {\n            if (index < this._buffer.length || this._done) return callback(new Error('Parser cannot parse input: expected an object key'));\n            break main; // wait for more input\n          }\n          value = match[0];\n          if (value === '\"') {\n            this._streamKeys && this.push({name: 'startKey'});\n            this._expect = 'keyVal';\n          } else if (value === '}') {\n            if (this._expect !== 'key1') return callback(new Error(\"Parser cannot parse input: unexpected token '}'\"));\n            this.push({name: 'endObject'});\n            this._parent = this._stack.pop();\n            this._expect = expected[this._parent];\n          }\n          if (noSticky) {\n            this._buffer = this._buffer.slice(value.length);\n          } else {\n            index += value.length;\n          }\n          break;\n        case 'colon':\n          patterns.colon.lastIndex = index;\n          match = patterns.colon.exec(this._buffer);\n          if (!match) {\n            if (index < this._buffer.length || this._done) return callback(new Error(\"Parser cannot parse input: expected ':'\"));\n            break main; // wait for more input\n          }\n          value = match[0];\n          value === ':' && (this._expect = 'value');\n          if (noSticky) {\n            this._buffer = this._buffer.slice(value.length);\n          } else {\n            index += value.length;\n          }\n          break;\n        case 'arrayStop':\n        case 'objectStop':\n          patterns.comma.lastIndex = index;\n          match = patterns.comma.exec(this._buffer);\n          if (!match) {\n            if (index < this._buffer.length || this._done) return callback(new Error(\"Parser cannot parse input: expected ','\"));\n            break main; // wait for more input\n          }\n          if (this._open_number) {\n            this._streamNumbers && this.push({name: 'endNumber'});\n            this._open_number = false;\n            if (this._packNumbers) {\n              this.push({name: 'numberValue', value: this._accumulator});\n              this._accumulator = '';\n            }\n          }\n          value = match[0];\n          if (value === ',') {\n            this._expect = this._expect === 'arrayStop' ? 'value' : 'key';\n          } else if (value === '}' || value === ']') {\n            if (value === '}' ? this._expect === 'arrayStop' : this._expect !== 'arrayStop') {\n              return callback(new Error(\"Parser cannot parse input: expected '\" + (this._expect === 'arrayStop' ? ']' : '}') + \"'\"));\n            }\n            this.push({name: value === '}' ? 'endObject' : 'endArray'});\n            this._parent = this._stack.pop();\n            this._expect = expected[this._parent];\n          }\n          if (noSticky) {\n            this._buffer = this._buffer.slice(value.length);\n          } else {\n            index += value.length;\n          }\n          break;\n        // number chunks\n        case 'numberStart': // [0-9]\n          patterns.numberStart.lastIndex = index;\n          match = patterns.numberStart.exec(this._buffer);\n          if (!match) {\n            if (index < this._buffer.length || this._done) return callback(new Error('Parser cannot parse input: expected a starting digit'));\n            break main; // wait for more input\n          }\n          value = match[0];\n          this._streamNumbers && this.push({name: 'numberChunk', value: value});\n          this._packNumbers && (this._accumulator += value);\n          this._expect = value === '0' ? 'numberFraction' : 'numberDigit';\n          if (noSticky) {\n            this._buffer = this._buffer.slice(value.length);\n          } else {\n            index += value.length;\n          }\n          break;\n        case 'numberDigit': // [0-9]*\n          patterns.numberDigit.lastIndex = index;\n          match = patterns.numberDigit.exec(this._buffer);\n          if (!match) {\n            if (index < this._buffer.length || this._done) return callback(new Error('Parser cannot parse input: expected a digit'));\n            break main; // wait for more input\n          }\n          value = match[0];\n          if (value) {\n            this._streamNumbers && this.push({name: 'numberChunk', value: value});\n            this._packNumbers && (this._accumulator += value);\n            if (noSticky) {\n              this._buffer = this._buffer.slice(value.length);\n            } else {\n              index += value.length;\n            }\n          } else {\n            if (index < this._buffer.length) {\n              this._expect = 'numberFraction';\n              break;\n            }\n            if (this._done) {\n              this._expect = expected[this._parent];\n              break;\n            }\n            break main; // wait for more input\n          }\n          break;\n        case 'numberFraction': // [\\.eE]?\n          patterns.numberFraction.lastIndex = index;\n          match = patterns.numberFraction.exec(this._buffer);\n          if (!match) {\n            if (index < this._buffer.length || this._done) {\n              this._expect = expected[this._parent];\n              break;\n            }\n            break main; // wait for more input\n          }\n          value = match[0];\n          this._streamNumbers && this.push({name: 'numberChunk', value: value});\n          this._packNumbers && (this._accumulator += value);\n          this._expect = value === '.' ? 'numberFracStart' : 'numberExpSign';\n          if (noSticky) {\n            this._buffer = this._buffer.slice(value.length);\n          } else {\n            index += value.length;\n          }\n          break;\n        case 'numberFracStart': // [0-9]\n          patterns.numberFracStart.lastIndex = index;\n          match = patterns.numberFracStart.exec(this._buffer);\n          if (!match) {\n            if (index < this._buffer.length || this._done) return callback(new Error('Parser cannot parse input: expected a fractional part of a number'));\n            break main; // wait for more input\n          }\n          value = match[0];\n          this._streamNumbers && this.push({name: 'numberChunk', value: value});\n          this._packNumbers && (this._accumulator += value);\n          this._expect = 'numberFracDigit';\n          if (noSticky) {\n            this._buffer = this._buffer.slice(value.length);\n          } else {\n            index += value.length;\n          }\n          break;\n        case 'numberFracDigit': // [0-9]*\n          patterns.numberFracDigit.lastIndex = index;\n          match = patterns.numberFracDigit.exec(this._buffer);\n          value = match[0];\n          if (value) {\n            this._streamNumbers && this.push({name: 'numberChunk', value: value});\n            this._packNumbers && (this._accumulator += value);\n            if (noSticky) {\n              this._buffer = this._buffer.slice(value.length);\n            } else {\n              index += value.length;\n            }\n          } else {\n            if (index < this._buffer.length) {\n              this._expect = 'numberExponent';\n              break;\n            }\n            if (this._done) {\n              this._expect = expected[this._parent];\n              break;\n            }\n            break main; // wait for more input\n          }\n          break;\n        case 'numberExponent': // [eE]?\n          patterns.numberExponent.lastIndex = index;\n          match = patterns.numberExponent.exec(this._buffer);\n          if (!match) {\n            if (index < this._buffer.length) {\n              this._expect = expected[this._parent];\n              break;\n            }\n            if (this._done) {\n              this._expect = 'done';\n              break;\n            }\n            break main; // wait for more input\n          }\n          value = match[0];\n          this._streamNumbers && this.push({name: 'numberChunk', value: value});\n          this._packNumbers && (this._accumulator += value);\n          this._expect = 'numberExpSign';\n          if (noSticky) {\n            this._buffer = this._buffer.slice(value.length);\n          } else {\n            index += value.length;\n          }\n          break;\n        case 'numberExpSign': // [-+]?\n          patterns.numberExpSign.lastIndex = index;\n          match = patterns.numberExpSign.exec(this._buffer);\n          if (!match) {\n            if (index < this._buffer.length) {\n              this._expect = 'numberExpStart';\n              break;\n            }\n            if (this._done) return callback(new Error('Parser has expected an exponent value of a number'));\n            break main; // wait for more input\n          }\n          value = match[0];\n          this._streamNumbers && this.push({name: 'numberChunk', value: value});\n          this._packNumbers && (this._accumulator += value);\n          this._expect = 'numberExpStart';\n          if (noSticky) {\n            this._buffer = this._buffer.slice(value.length);\n          } else {\n            index += value.length;\n          }\n          break;\n        case 'numberExpStart': // [0-9]\n          patterns.numberExpStart.lastIndex = index;\n          match = patterns.numberExpStart.exec(this._buffer);\n          if (!match) {\n            if (index < this._buffer.length || this._done) return callback(new Error('Parser cannot parse input: expected an exponent part of a number'));\n            break main; // wait for more input\n          }\n          value = match[0];\n          this._streamNumbers && this.push({name: 'numberChunk', value: value});\n          this._packNumbers && (this._accumulator += value);\n          this._expect = 'numberExpDigit';\n          if (noSticky) {\n            this._buffer = this._buffer.slice(value.length);\n          } else {\n            index += value.length;\n          }\n          break;\n        case 'numberExpDigit': // [0-9]*\n          patterns.numberExpDigit.lastIndex = index;\n          match = patterns.numberExpDigit.exec(this._buffer);\n          value = match[0];\n          if (value) {\n            this._streamNumbers && this.push({name: 'numberChunk', value: value});\n            this._packNumbers && (this._accumulator += value);\n            if (noSticky) {\n              this._buffer = this._buffer.slice(value.length);\n            } else {\n              index += value.length;\n            }\n          } else {\n            if (index < this._buffer.length || this._done) {\n              this._expect = expected[this._parent];\n              break;\n            }\n            break main; // wait for more input\n          }\n          break;\n        case 'done':\n          patterns.ws.lastIndex = index;\n          match = patterns.ws.exec(this._buffer);\n          if (!match) {\n            if (index < this._buffer.length) {\n              if (this._jsonStreaming) {\n                this._expect = 'value';\n                break;\n              }\n              return callback(new Error('Parser cannot parse input: unexpected characters'));\n            }\n            break main; // wait for more input\n          }\n          value = match[0];\n          if (this._open_number) {\n            this._streamNumbers && this.push({name: 'endNumber'});\n            this._open_number = false;\n            if (this._packNumbers) {\n              this.push({name: 'numberValue', value: this._accumulator});\n              this._accumulator = '';\n            }\n          }\n          if (noSticky) {\n            this._buffer = this._buffer.slice(value.length);\n          } else {\n            index += value.length;\n          }\n          break;\n      }\n    }\n    !noSticky && (this._buffer = this._buffer.slice(index));\n    callback(null);\n  }\n}\nParser.parser = Parser.make;\nParser.make.Constructor = Parser;\n\nmodule.exports = Parser;\n", "'use strict';\n\nconst emit = stream => stream.on('data', item => stream.emit(item.name, item.value));\n\nmodule.exports = emit;\n", "'use strict';\n\nconst Parser = require('./Parser');\nconst emit = require('./utils/emit');\n\nconst make = options => emit(new Parser(options));\n\nmake.Parser = Parser;\nmake.parser = Parser.parser;\n\nmodule.exports = make;\n", "'use strict';\n\nconst {Transform} = require('stream');\n\nclass FilterBase extends Transform {\n  static stringFilter(string, separator) {\n    return stack => {\n      const path = stack.join(separator);\n      return (\n        (path.length === string.length && path === string) ||\n        (path.length > string.length && path.substr(0, string.length) === string && path.substr(string.length, separator.length) === separator)\n      );\n    };\n  }\n\n  static regExpFilter(regExp, separator) {\n    return stack => regExp.test(stack.join(separator));\n  }\n\n  static arrayReplacement(array) {\n    return () => array;\n  }\n\n  constructor(options) {\n    super(Object.assign({}, options, {writableObjectMode: true, readableObjectMode: true}));\n    this._transform = this._check;\n    this._stack = [];\n\n    const filter = options && options.filter,\n      separator = (options && options.pathSeparator) || '.';\n    if (typeof filter == 'string') {\n      this._filter = FilterBase.stringFilter(filter, separator);\n    } else if (typeof filter == 'function') {\n      this._filter = filter;\n    } else if (filter instanceof RegExp) {\n      this._filter = FilterBase.regExpFilter(filter, separator);\n    }\n\n    const replacement = options && options.replacement;\n    if (typeof replacement == 'function') {\n      this._replacement = replacement;\n    } else {\n      this._replacement = FilterBase.arrayReplacement(replacement || FilterBase.defaultReplacement);\n    }\n    this._allowEmptyReplacement = options && options.allowEmptyReplacement;\n\n    this._streamKeys = true;\n    if (options) {\n      'streamValues' in options && (this._streamKeys = options.streamValues);\n      'streamKeys' in options && (this._streamKeys = options.streamKeys);\n    }\n\n    this._once = options && options.once;\n    this._previousToken = '';\n  }\n\n  _check(chunk, _, callback) {\n    // update the last stack key\n    switch (chunk.name) {\n      case 'startObject':\n      case 'startArray':\n      case 'startString':\n      case 'startNumber':\n      case 'nullValue':\n      case 'trueValue':\n      case 'falseValue':\n        if (typeof this._stack[this._stack.length - 1] == 'number') {\n          // array\n          ++this._stack[this._stack.length - 1];\n        }\n        break;\n      case 'keyValue':\n        this._stack[this._stack.length - 1] = chunk.value;\n        break;\n      case 'numberValue':\n        if (this._previousToken !== 'endNumber' && typeof this._stack[this._stack.length - 1] == 'number') {\n          // array\n          ++this._stack[this._stack.length - 1];\n        }\n        break;\n      case 'stringValue':\n        if (this._previousToken !== 'endString' && typeof this._stack[this._stack.length - 1] == 'number') {\n          // array\n          ++this._stack[this._stack.length - 1];\n        }\n        break;\n    }\n    this._previousToken = chunk.name;\n    // check, if we allow a chunk\n    if (this._checkChunk(chunk)) {\n      return callback(null);\n    }\n    // update the stack\n    switch (chunk.name) {\n      case 'startObject':\n        this._stack.push(null);\n        break;\n      case 'startArray':\n        this._stack.push(-1);\n        break;\n      case 'endObject':\n      case 'endArray':\n        this._stack.pop();\n        break;\n    }\n    callback(null);\n  }\n\n  _passObject(chunk, _, callback) {\n    this.push(chunk);\n    switch (chunk.name) {\n      case 'startObject':\n      case 'startArray':\n        ++this._depth;\n        break;\n      case 'endObject':\n      case 'endArray':\n        --this._depth;\n        break;\n    }\n    if (!this._depth) {\n      this._transform = this._once ? this._skip : this._check;\n    }\n    callback(null);\n  }\n\n  _pass(chunk, _, callback) {\n    this.push(chunk);\n    callback(null);\n  }\n\n  _skipObject(chunk, _, callback) {\n    switch (chunk.name) {\n      case 'startObject':\n      case 'startArray':\n        ++this._depth;\n        break;\n      case 'endObject':\n      case 'endArray':\n        --this._depth;\n        break;\n    }\n    if (!this._depth) {\n      this._transform = this._once ? this._pass : this._check;\n    }\n    callback(null);\n  }\n\n  _skip(chunk, _, callback) {\n    callback(null);\n  }\n}\n\nFilterBase.defaultReplacement = [{name: 'nullValue', value: null}];\n\nconst passValue = (last, post) =>\n  function(chunk, _, callback) {\n    if (this._expected) {\n      const expected = this._expected;\n      this._expected = '';\n      this._transform = this._once ? this._skip : this._check;\n      if (expected === chunk.name) {\n        this.push(chunk);\n      } else {\n        return this._transform(chunk, _, callback);\n      }\n    } else {\n      this.push(chunk);\n      if (chunk.name === last) {\n        this._expected = post;\n      }\n    }\n    callback(null);\n  };\n\nFilterBase.prototype._passNumber = passValue('endNumber', 'numberValue');\nFilterBase.prototype._passString = passValue('endString', 'stringValue');\nFilterBase.prototype._passKey = passValue('endKey', 'keyValue');\n\nconst skipValue = (last, post) =>\n  function(chunk, _, callback) {\n    if (this._expected) {\n      const expected = this._expected;\n      this._expected = '';\n      this._transform = this._once ? this._pass : this._check;\n      if (expected !== chunk.name) {\n        return this._transform(chunk, _, callback);\n      }\n    } else {\n      if (chunk.name === last) {\n        this._expected = post;\n      }\n    }\n    callback(null);\n  };\n\nFilterBase.prototype._skipNumber = skipValue('endNumber', 'numberValue');\nFilterBase.prototype._skipString = skipValue('endString', 'stringValue');\nFilterBase.prototype._skipKey = skipValue('endKey', 'keyValue');\n\nmodule.exports = FilterBase;\n", "'use strict';\n\nconst {chain} = require('stream-chain');\n\nconst Parser = require('../Parser');\n\nconst withParser = (fn, options) =>\n  chain([new Parser(options), fn(options)], Object.assign({}, options, {writableObjectMode: false, readableObjectMode: true}));\n\nmodule.exports = withParser;\n", "'use strict';\n\nconst FilterBase = require('./FilterBase');\nconst withParser = require('../utils/withParser');\n\nclass Filter extends FilterBase {\n  static make(options) {\n    return new Filter(options);\n  }\n\n  static withParser(options) {\n    return withParser(Filter.make, options);\n  }\n\n  constructor(options) {\n    super(options);\n    this._once = false;\n    this._lastStack = [];\n  }\n\n  _flush(callback) {\n    this._syncStack();\n    callback(null);\n  }\n\n  _checkChunk(chunk) {\n    switch (chunk.name) {\n      case 'startObject':\n        if (this._filter(this._stack, chunk)) {\n          this._syncStack();\n          this.push(chunk);\n          this._lastStack.push(null);\n        }\n        break;\n      case 'startArray':\n        if (this._filter(this._stack, chunk)) {\n          this._syncStack();\n          this.push(chunk);\n          this._lastStack.push(-1);\n        }\n        break;\n      case 'nullValue':\n      case 'trueValue':\n      case 'falseValue':\n      case 'stringValue':\n      case 'numberValue':\n        if (this._filter(this._stack, chunk)) {\n          this._syncStack();\n          this.push(chunk);\n        }\n        break;\n      case 'startString':\n        if (this._filter(this._stack, chunk)) {\n          this._syncStack();\n          this.push(chunk);\n          this._transform = this._passString;\n        } else {\n          this._transform = this._skipString;\n        }\n        break;\n      case 'startNumber':\n        if (this._filter(this._stack, chunk)) {\n          this._syncStack();\n          this.push(chunk);\n          this._transform = this._passNumber;\n        } else {\n          this._transform = this._skipNumber;\n        }\n        break;\n    }\n    return false;\n  }\n\n  _syncStack() {\n    const stack = this._stack,\n      last = this._lastStack,\n      stackLength = stack.length,\n      lastLength = last.length;\n\n    // find the common part\n    let commonLength = 0;\n    for (const n = Math.min(stackLength, lastLength); commonLength < n && stack[commonLength] === last[commonLength]; ++commonLength);\n\n    // close old objects\n    for (let i = lastLength - 1; i > commonLength; --i) {\n      this.push({name: typeof last[i] == 'number' ? 'endArray' : 'endObject'});\n    }\n    if (commonLength < lastLength) {\n      if (commonLength < stackLength) {\n        if (typeof stack[commonLength] == 'string') {\n          const key = stack[commonLength];\n          if (this._streamKeys) {\n            this.push({name: 'startKey'});\n            this.push({name: 'stringChunk', value: key});\n            this.push({name: 'endKey'});\n          }\n          this.push({name: 'keyValue', value: key});\n        }\n        ++commonLength;\n      } else {\n        this.push({name: typeof last[commonLength] == 'number' ? 'endArray' : 'endObject'});\n      }\n    }\n\n    // open new objects\n    for (let i = commonLength; i < stackLength; ++i) {\n      const key = stack[i];\n      if (typeof key == 'number') {\n        if (key >= 0) {\n          this.push({name: 'startArray'});\n        }\n      } else if (typeof key == 'string') {\n        this.push({name: 'startObject'});\n        if (this._streamKeys) {\n          this.push({name: 'startKey'});\n          this.push({name: 'stringChunk', value: key});\n          this.push({name: 'endKey'});\n        }\n        this.push({name: 'keyValue', value: key});\n      }\n    }\n\n    // update the last stack\n    this._lastStack = Array.prototype.concat.call(stack);\n  }\n}\nFilter.filter = Filter.make;\nFilter.make.Constructor = Filter;\n\nmodule.exports = Filter;\n", "'use strict';\n\nconst EventEmitter = require('events');\n\nconst startObject = Ctr =>\n  function () {\n    if (this.done) {\n      this.done = false;\n    } else {\n      this.stack.push(this.current, this.key);\n    }\n    this.current = new Ctr();\n    this.key = null;\n  };\n\nclass Assembler extends EventEmitter {\n  static connectTo(stream, options) {\n    return new Assembler(options).connectTo(stream);\n  }\n\n  constructor(options) {\n    super();\n    this.stack = [];\n    this.current = this.key = null;\n    this.done = true;\n    if (options) {\n      this.reviver = typeof options.reviver == 'function' && options.reviver;\n      if (this.reviver) {\n        this.stringValue = this._saveValue = this._saveValueWithReviver;\n      }\n      if (options.numberAsString) {\n        this.numberValue = this.stringValue;\n      }\n    }\n  }\n\n  connectTo(stream) {\n    stream.on('data', chunk => {\n      if (this[chunk.name]) {\n        this[chunk.name](chunk.value);\n        if (this.done) this.emit('done', this);\n      }\n    });\n    return this;\n  }\n\n  get depth() {\n    return (this.stack.length >> 1) + (this.done ? 0 : 1);\n  }\n\n  get path() {\n    const path = [];\n    for (let i = 0; i < this.stack.length; i += 2) {\n      const key = this.stack[i + 1];\n      path.push(key === null ? this.stack[i].length : key);\n    }\n    return path;\n  }\n\n  dropToLevel(level) {\n    if (level < this.depth) {\n      if (level) {\n        const index = (level - 1) << 1;\n        this.current = this.stack[index];\n        this.key = this.stack[index + 1];\n        this.stack.splice(index);\n      } else {\n        this.stack = [];\n        this.current = this.key = null;\n        this.done = true;\n      }\n    }\n    return this;\n  }\n\n  consume(chunk) {\n    this[chunk.name] && this[chunk.name](chunk.value);\n    return this;\n  }\n\n  keyValue(value) {\n    this.key = value;\n  }\n\n  //stringValue() - aliased below to _saveValue()\n\n  numberValue(value) {\n    this._saveValue(parseFloat(value));\n  }\n  nullValue() {\n    this._saveValue(null);\n  }\n  trueValue() {\n    this._saveValue(true);\n  }\n  falseValue() {\n    this._saveValue(false);\n  }\n\n  //startObject() - assigned below\n\n  endObject() {\n    if (this.stack.length) {\n      const value = this.current;\n      this.key = this.stack.pop();\n      this.current = this.stack.pop();\n      this._saveValue(value);\n    } else {\n      this.done = true;\n    }\n  }\n\n  //startArray() - assigned below\n  //endArray() - aliased below to endObject()\n\n  _saveValue(value) {\n    if (this.done) {\n      this.current = value;\n    } else {\n      if (this.current instanceof Array) {\n        this.current.push(value);\n      } else {\n        this.current[this.key] = value;\n        this.key = null;\n      }\n    }\n  }\n  _saveValueWithReviver(value) {\n    if (this.done) {\n      this.current = this.reviver('', value);\n    } else {\n      if (this.current instanceof Array) {\n        value = this.reviver('' + this.current.length, value);\n        this.current.push(value);\n        if (value === undefined) {\n          delete this.current[this.current.length - 1];\n        }\n      } else {\n        value = this.reviver(this.key, value);\n        if (value !== undefined) {\n          this.current[this.key] = value;\n        }\n        this.key = null;\n      }\n    }\n  }\n}\n\nAssembler.prototype.stringValue = Assembler.prototype._saveValue;\nAssembler.prototype.startObject = startObject(Object);\nAssembler.prototype.startArray = startObject(Array);\nAssembler.prototype.endArray = Assembler.prototype.endObject;\n\nmodule.exports = Assembler;\n", "'use strict';\n\nconst {Transform} = require('stream');\nconst Assembler = require('../Assembler');\n\nclass Counter {\n  constructor(initialDepth) {\n    this.depth = initialDepth;\n  }\n  startObject() {\n    ++this.depth;\n  }\n  endObject() {\n    --this.depth;\n  }\n  startArray() {\n    ++this.depth;\n  }\n  endArray() {\n    --this.depth;\n  }\n}\n\nclass StreamBase extends Transform {\n  constructor(options) {\n    super(Object.assign({}, options, {writableObjectMode: true, readableObjectMode: true}));\n    if (options) {\n      this.objectFilter = options.objectFilter;\n      this.includeUndecided = options.includeUndecided;\n    }\n    if (typeof this.objectFilter != 'function') {\n      this._filter = this._transform;\n    }\n    this._transform = this._wait || this._filter;\n    this._assembler = new Assembler(options);\n  }\n\n  _transform(chunk, encoding, callback) {\n    if (this._assembler[chunk.name]) {\n      this._assembler[chunk.name](chunk.value);\n      if (this._assembler.depth === this._level) {\n        this._push();\n      }\n    }\n    callback(null);\n  }\n\n  _filter(chunk, encoding, callback) {\n    if (this._assembler[chunk.name]) {\n      this._assembler[chunk.name](chunk.value);\n      const result = this.objectFilter(this._assembler);\n      if (result) {\n        if (this._assembler.depth === this._level) {\n          this._push();\n          this._transform = this._filter;\n        }\n        this._transform = this._accept;\n        return callback(null);\n      }\n      if (result === false) {\n        this._saved_assembler = this._assembler;\n        this._assembler = new Counter(this._saved_assembler.depth);\n        this._saved_assembler.dropToLevel(this._level);\n        if (this._assembler.depth === this._level) {\n          this._assembler = this._saved_assembler;\n          this._transform = this._filter;\n        }\n        this._transform = this._reject;\n        return callback(null);\n      }\n      if (this._assembler.depth === this._level) {\n        this._push(!this.includeUndecided);\n      }\n    }\n    callback(null);\n  }\n\n  _accept(chunk, encoding, callback) {\n    if (this._assembler[chunk.name]) {\n      this._assembler[chunk.name](chunk.value);\n      if (this._assembler.depth === this._level) {\n        this._push();\n        this._transform = this._filter;\n      }\n    }\n    callback(null);\n  }\n\n  _reject(chunk, encoding, callback) {\n    if (this._assembler[chunk.name]) {\n      this._assembler[chunk.name](chunk.value);\n      if (this._assembler.depth === this._level) {\n        this._assembler = this._saved_assembler;\n        this._transform = this._filter;\n      }\n    }\n    callback(null);\n  }\n}\n\nmodule.exports = StreamBase;\n", "'use strict';\n\nconst StreamBase = require('./StreamBase');\nconst withParser = require('../utils/withParser');\n\nclass StreamArray extends StreamBase {\n  static make(options) {\n    return new StreamArray(options);\n  }\n\n  static withParser(options) {\n    return withParser(StreamArray.make, options);\n  }\n\n  constructor(options) {\n    super(options);\n    this._level = 1;\n    this._counter = 0;\n  }\n\n  _wait(chunk, _, callback) {\n    // first chunk should open an array\n    if (chunk.name !== 'startArray') {\n      return callback(new Error('Top-level object should be an array.'));\n    }\n    this._transform = this._filter;\n    return this._transform(chunk, _, callback);\n  }\n\n  _push(discard) {\n    if (this._assembler.current.length) {\n      if (discard) {\n        ++this._counter;\n        this._assembler.current.pop();\n      } else {\n        this.push({key: this._counter++, value: this._assembler.current.pop()});\n      }\n    }\n  }\n}\nStreamArray.streamArray = StreamArray.make;\nStreamArray.make.Constructor = StreamArray;\n\nmodule.exports = StreamArray;\n", "'use strict';\n\nconst FilterBase = require('./FilterBase');\nconst withParser = require('../utils/withParser');\n\nclass Pick extends FilterBase {\n  static make(options) {\n    return new Pick(options);\n  }\n\n  static withParser(options) {\n    return withParser(Pick.make, options);\n  }\n\n  _checkChunk(chunk) {\n    switch (chunk.name) {\n      case 'startObject':\n      case 'startArray':\n        if (this._filter(this._stack, chunk)) {\n          this.push(chunk);\n          this._transform = this._passObject;\n          this._depth = 1;\n          return true;\n        }\n        break;\n      case 'startString':\n        if (this._filter(this._stack, chunk)) {\n          this.push(chunk);\n          this._transform = this._passString;\n          return true;\n        }\n        break;\n      case 'startNumber':\n        if (this._filter(this._stack, chunk)) {\n          this.push(chunk);\n          this._transform = this._passNumber;\n          return true;\n        }\n        break;\n      case 'nullValue':\n      case 'trueValue':\n      case 'falseValue':\n      case 'stringValue':\n      case 'numberValue':\n        if (this._filter(this._stack, chunk)) {\n          this.push(chunk);\n          this._transform = this._once ? this._skip : this._check;\n          return true;\n        }\n        break;\n    }\n    return false;\n  }\n}\nPick.pick = Pick.make;\nPick.make.Constructor = Pick;\n\nmodule.exports = Pick;\n", "'use strict';\n\nconst StreamBase = require('./StreamBase');\nconst withParser = require('../utils/withParser');\n\nclass StreamObject extends StreamBase {\n  static make(options) {\n    return new StreamObject(options);\n  }\n\n  static withParser(options) {\n    return withParser(StreamObject.make, options);\n  }\n\n  constructor(options) {\n    super(options);\n    this._level = 1;\n    this._lastKey = null;\n  }\n\n  _wait(chunk, _, callback) {\n    // first chunk should open an array\n    if (chunk.name !== 'startObject') {\n      return callback(new Error('Top-level object should be an object.'));\n    }\n    this._transform = this._filter;\n    return this._transform(chunk, _, callback);\n  }\n\n  _push(discard) {\n    if (this._lastKey === null) {\n      this._lastKey = this._assembler.key;\n    } else {\n      !discard && this.push({key: this._lastKey, value: this._assembler.current[this._lastKey]});\n      this._assembler.current = {};\n      this._lastKey = null;\n    }\n  }\n}\nStreamObject.streamObject = StreamObject.make;\nStreamObject.make.Constructor = StreamObject;\n\nmodule.exports = StreamObject;\n", "import { showToast, Toast } from \"@raycast/api\";\nimport { brewCleanup } from \"./utils/brew\";\nimport { showActionToast, showBrewFailureToast, wait, ensureError } from \"./utils\";\nimport { preferences } from \"./utils\";\n\nexport default async (): Promise<void> => {\n  try {\n    const handle = showActionToast({\n      title: \"Cleaning files & packages from the cache\" + String.ellipsis,\n      cancelable: true,\n    });\n    await brewCleanup(preferences.withoutThreshold, handle.abort?.signal);\n    showToast(Toast.Style.Success, \"Cleaning completed\");\n  } catch (err) {\n    await showBrewFailureToast(\"Cleaning failed\", ensureError(err));\n    await wait(3000);\n  }\n};\n", "/**\n * Homebrew path utilities.\n *\n * Provides functions for resolving brew installation paths.\n */\n\nimport { execSync } from \"child_process\";\nimport { join as path_join } from \"path\";\nimport { cpus } from \"os\";\nimport { preferences } from \"../preferences\";\n\n/**\n * The Homebrew prefix directory.\n * Determined by:\n * 1. Custom brew path preference (if set)\n * 2. Running `brew --prefix` command\n * 3. Fallback based on CPU architecture\n */\nexport const brewPrefix = (() => {\n  if (preferences.customBrewPath && preferences.customBrewPath.length > 0)\n    return path_join(preferences.customBrewPath, \"..\", \"..\");\n  try {\n    return execSync(\"brew --prefix\", { encoding: \"utf8\" }).trim();\n  } catch {\n    const firstCpu = cpus()[0];\n    return firstCpu?.model?.includes(\"Apple\") ? \"/opt/homebrew\" : \"/usr/local\";\n  }\n})();\n\n/**\n * Get a path relative to the brew prefix.\n */\nexport const brewPath = (suffix: string): string => path_join(brewPrefix, suffix);\n\n/**\n * Get the path to the brew executable.\n */\nexport const brewExecutable = (): string => brewPath(\"bin/brew\");\n", "import { getPreferenceValues } from \"@raycast/api\";\n\nexport const preferences = <Preferences & Preferences.CleanUp>getPreferenceValues();\n", "/**\n * Homebrew command execution utilities.\n *\n * Provides functions for executing brew commands with proper error handling.\n *\n * Homebrew 5.0 Compatibility Notes:\n * - Download concurrency is now enabled by default (HOMEBREW_DOWNLOAD_CONCURRENCY=auto)\n * - The extension supports controlling this via preferences\n * - --no-quarantine and --quarantine flags are deprecated\n * - HOMEBREW_USE_INTERNAL_API can be enabled for the new smaller JSON API\n */\n\nimport { exec } from \"child_process\";\nimport { promisify } from \"util\";\nimport { constants as fs_constants } from \"fs\";\nimport * as fs from \"fs/promises\";\nimport { join as path_join } from \"path\";\nimport { environment } from \"@raycast/api\";\nimport { ExecError, ExecResult } from \"../types\";\nimport { brewExecutable } from \"./paths\";\nimport { preferences } from \"../preferences\";\nimport { brewLogger } from \"../logger\";\nimport { BrewLockError, isBrewLockMessage } from \"../errors\";\nimport { bundleIdentifier } from \"../cache\";\n\nconst execp = promisify(exec);\n\n// Track if we've logged the Homebrew 5.0 environment configuration\nlet homebrewEnvLogged = false;\n\n/**\n * Execute a brew command.\n */\nexport async function execBrew(cmd: string, options?: { signal?: AbortSignal }): Promise<ExecResult> {\n  try {\n    const env = await execBrewEnv();\n    return await execp(`${brewExecutable()} ${cmd}`, {\n      signal: options?.signal,\n      env: env,\n      maxBuffer: 10 * 1024 * 1024,\n    });\n  } catch (err) {\n    const execErr = err as ExecError;\n\n    // Check for brew lock/concurrent process error\n    const errorOutput = execErr?.stderr || execErr?.stdout || \"\";\n    if (isBrewLockMessage(errorOutput)) {\n      brewLogger.warn(\"Brew lock detected - another process is running\", {\n        command: cmd,\n        stderr: execErr?.stderr,\n      });\n      throw new BrewLockError(\"Another brew process is already running\", {\n        command: cmd,\n        cause: execErr,\n      });\n    }\n\n    // Check for brew not found\n    if (preferences.customBrewPath && execErr && execErr.code === 127) {\n      execErr.stderr = `Brew executable not found at: ${preferences.customBrewPath}`;\n      throw execErr;\n    }\n\n    throw err;\n  }\n}\n\n/**\n * Get the environment variables for brew execution.\n *\n * Homebrew 5.0 environment variables:\n * - HOMEBREW_DOWNLOAD_CONCURRENCY: Controls parallel downloads (default: \"auto\")\n *   Set to \"1\" to disable concurrent downloads\n * - HOMEBREW_USE_INTERNAL_API: Opt-in to the new smaller internal JSON API\n */\nexport async function execBrewEnv(): Promise<NodeJS.ProcessEnv> {\n  const askpassPath = path_join(environment.assetsPath, \"askpass.sh\");\n  try {\n    await fs.access(askpassPath, fs_constants.X_OK);\n  } catch {\n    await fs.chmod(askpassPath, 0o755);\n  }\n  const env = { ...process.env };\n  env[\"SUDO_ASKPASS\"] = askpassPath;\n  // Use HOMEBREW_BROWSER to pass through the app's bundle identifier.\n  // Brew will ignore custom environment variables.\n  env[\"HOMEBREW_BROWSER\"] = bundleIdentifier;\n\n  // Homebrew 5.0: Control download concurrency\n  // By default, Homebrew 5.0 enables concurrent downloads (auto)\n  // Users can disable this via preferences if they experience issues\n  const downloadConcurrencyDisabled = preferences.disableDownloadConcurrency;\n  if (downloadConcurrencyDisabled) {\n    env[\"HOMEBREW_DOWNLOAD_CONCURRENCY\"] = \"1\";\n  }\n\n  // Homebrew 5.0: Opt-in to the new internal API (smaller JSON)\n  // This will become default in a future version\n  const useInternalApi = preferences.useInternalApi;\n  if (useInternalApi) {\n    env[\"HOMEBREW_USE_INTERNAL_API\"] = \"1\";\n  }\n\n  // Log Homebrew 5.0 configuration once per session\n  if (!homebrewEnvLogged) {\n    homebrewEnvLogged = true;\n    brewLogger.log(\"Homebrew 5.0 Configuration\", {\n      downloadConcurrencyEnabled: !downloadConcurrencyDisabled,\n      downloadConcurrencyMode: downloadConcurrencyDisabled ? \"sequential (1)\" : \"parallel (auto)\",\n      internalApiEnabled: useInternalApi,\n      verboseLogging: preferences.verboseLogging,\n    });\n  }\n\n  return env;\n}\n", "/**\n * Logger utilities for the Brew extension.\n *\n * Uses @chrismessina/raycast-logger for verbose logging support.\n * Child loggers are created for different modules to provide context.\n */\n\nimport { Logger } from \"@chrismessina/raycast-logger\";\n\n/**\n * Main logger instance for the Brew extension.\n */\nexport const logger = new Logger({\n  prefix: \"[Brew]\",\n});\n\n/**\n * Child logger for brew command operations.\n */\nexport const brewLogger = logger.child(\"[Commands]\");\n\n/**\n * Child logger for cache operations.\n */\nexport const cacheLogger = logger.child(\"[Cache]\");\n\n/**\n * Child logger for action operations (install, uninstall, upgrade).\n */\nexport const actionsLogger = logger.child(\"[Actions]\");\n\n/**\n * Child logger for fetch operations.\n */\nexport const fetchLogger = logger.child(\"[Fetch]\");\n\n/**\n * Child logger for search operations.\n */\nexport const searchLogger = logger.child(\"[Search]\");\n\n/**\n * Child logger for UI operations (toasts, etc.).\n */\nexport const uiLogger = logger.child(\"[UI]\");\n", "/**\n * Error types for the Brew extension.\n *\n * Provides granular error types for different failure scenarios:\n * - Network errors (transient, recoverable)\n * - Parse errors (corrupted data)\n * - Brew command errors (brew-specific failures)\n * - Brew lock errors (concurrent process detection)\n * - Cache errors (file system issues)\n */\n\n/**\n * Base error class for all Brew extension errors.\n */\nexport class BrewError extends Error {\n  readonly brewCause?: Error;\n\n  constructor(message: string, options?: { cause?: Error }) {\n    super(message);\n    this.name = \"BrewError\";\n    this.brewCause = options?.cause;\n  }\n}\n\n/**\n * Network-related errors (HTTP failures, timeouts, etc.).\n * These are typically transient and recoverable.\n */\nexport class NetworkError extends BrewError {\n  readonly statusCode?: number;\n  readonly url?: string;\n\n  constructor(message: string, options?: { cause?: Error; statusCode?: number; url?: string }) {\n    super(message, { cause: options?.cause });\n    this.name = \"NetworkError\";\n    this.statusCode = options?.statusCode;\n    this.url = options?.url;\n  }\n}\n\n/**\n * Parse errors for corrupted or invalid data.\n */\nexport class ParseError extends BrewError {\n  constructor(message: string, options?: { cause?: Error }) {\n    super(message, options);\n    this.name = \"ParseError\";\n  }\n}\n\n/**\n * Brew command execution errors.\n */\nexport class BrewCommandError extends BrewError {\n  readonly command?: string;\n  readonly exitCode?: number;\n  readonly stderr?: string;\n\n  constructor(message: string, options?: { cause?: Error; command?: string; exitCode?: number; stderr?: string }) {\n    super(message, { cause: options?.cause });\n    this.name = \"BrewCommandError\";\n    this.command = options?.command;\n    this.exitCode = options?.exitCode;\n    this.stderr = options?.stderr;\n  }\n}\n\n/**\n * Error when brew executable is not found.\n */\nexport class BrewNotFoundError extends BrewError {\n  readonly path?: string;\n\n  constructor(message: string, options?: { cause?: Error; path?: string }) {\n    super(message, { cause: options?.cause });\n    this.name = \"BrewNotFoundError\";\n    this.path = options?.path;\n  }\n}\n\n/**\n * Cache-related errors (file system issues).\n */\nexport class CacheError extends BrewError {\n  readonly path?: string;\n\n  constructor(message: string, options?: { cause?: Error; path?: string }) {\n    super(message, { cause: options?.cause });\n    this.name = \"CacheError\";\n    this.path = options?.path;\n  }\n}\n\n/**\n * Error when another brew process is already running.\n * This is a recoverable error - the user can retry after the other process finishes.\n */\nexport class BrewLockError extends BrewError {\n  readonly command?: string;\n\n  constructor(message: string, options?: { cause?: Error; command?: string }) {\n    super(message, { cause: options?.cause });\n    this.name = \"BrewLockError\";\n    this.command = options?.command;\n  }\n}\n\n/**\n * Error when a download or operation times out.\n * This is a recoverable error - the user can retry.\n */\nexport class DownloadTimeoutError extends BrewError {\n  readonly packageName?: string;\n  readonly phase?: string;\n  readonly timeoutMs?: number;\n  readonly elapsedMs?: number;\n\n  constructor(\n    message: string,\n    options?: {\n      cause?: Error;\n      packageName?: string;\n      phase?: string;\n      timeoutMs?: number;\n      elapsedMs?: number;\n    },\n  ) {\n    super(message, { cause: options?.cause });\n    this.name = \"DownloadTimeoutError\";\n    this.packageName = options?.packageName;\n    this.phase = options?.phase;\n    this.timeoutMs = options?.timeoutMs;\n    this.elapsedMs = options?.elapsedMs;\n  }\n}\n\n/**\n * Error when a brew process appears to be stale/stuck.\n * This happens when no progress is made for an extended period.\n */\nexport class StaleProcessError extends BrewError {\n  readonly packageName?: string;\n  readonly lastPhase?: string;\n  readonly staleDurationMs?: number;\n\n  constructor(\n    message: string,\n    options?: {\n      cause?: Error;\n      packageName?: string;\n      lastPhase?: string;\n      staleDurationMs?: number;\n    },\n  ) {\n    super(message, { cause: options?.cause });\n    this.name = \"StaleProcessError\";\n    this.packageName = options?.packageName;\n    this.lastPhase = options?.lastPhase;\n    this.staleDurationMs = options?.staleDurationMs;\n  }\n}\n\n/**\n * Error when a package is not found.\n */\nexport class PackageNotFoundError extends BrewError {\n  readonly packageName?: string;\n  readonly packageType?: \"formula\" | \"cask\";\n\n  constructor(message: string, options?: { cause?: Error; packageName?: string; packageType?: \"formula\" | \"cask\" }) {\n    super(message, { cause: options?.cause });\n    this.name = \"PackageNotFoundError\";\n    this.packageName = options?.packageName;\n    this.packageType = options?.packageType;\n  }\n}\n\n/**\n * Error when a package has been disabled/discontinued.\n * This is not recoverable - the package is no longer available.\n */\nexport class PackageDisabledError extends BrewError {\n  readonly packageName?: string;\n  readonly packageType?: \"formula\" | \"cask\";\n  readonly disabledDate?: string;\n  readonly reason?: string;\n\n  constructor(\n    message: string,\n    options?: {\n      cause?: Error;\n      packageName?: string;\n      packageType?: \"formula\" | \"cask\";\n      disabledDate?: string;\n      reason?: string;\n    },\n  ) {\n    super(message, { cause: options?.cause });\n    this.name = \"PackageDisabledError\";\n    this.packageName = options?.packageName;\n    this.packageType = options?.packageType;\n    this.disabledDate = options?.disabledDate;\n    this.reason = options?.reason;\n  }\n}\n\n/**\n * Error when a package conflicts with another installed package.\n */\nexport class PackageConflictError extends BrewError {\n  readonly packageName?: string;\n  readonly conflictsWith?: string[];\n\n  constructor(message: string, options?: { cause?: Error; packageName?: string; conflictsWith?: string[] }) {\n    super(message, { cause: options?.cause });\n    this.name = \"PackageConflictError\";\n    this.packageName = options?.packageName;\n    this.conflictsWith = options?.conflictsWith;\n  }\n}\n\n/**\n * Error when a package requires a specific macOS version.\n */\nexport class UnsupportedMacOSError extends BrewError {\n  readonly packageName?: string;\n  readonly requiredVersion?: string;\n  readonly currentVersion?: string;\n\n  constructor(\n    message: string,\n    options?: { cause?: Error; packageName?: string; requiredVersion?: string; currentVersion?: string },\n  ) {\n    super(message, { cause: options?.cause });\n    this.name = \"UnsupportedMacOSError\";\n    this.packageName = options?.packageName;\n    this.requiredVersion = options?.requiredVersion;\n    this.currentVersion = options?.currentVersion;\n  }\n}\n\n/// Type Guards\n\n/**\n * Check if an error is a BrewError.\n */\nexport function isBrewError(error: unknown): error is BrewError {\n  return error instanceof BrewError;\n}\n\n/**\n * Check if an error is a NetworkError.\n */\nexport function isNetworkError(error: unknown): error is NetworkError {\n  return error instanceof NetworkError;\n}\n\n/**\n * Check if an error is a BrewLockError.\n */\nexport function isBrewLockError(error: unknown): error is BrewLockError {\n  return error instanceof BrewLockError;\n}\n\n/**\n * Check if an error is a DownloadTimeoutError.\n */\nexport function isDownloadTimeoutError(error: unknown): error is DownloadTimeoutError {\n  return error instanceof DownloadTimeoutError;\n}\n\n/**\n * Check if an error is a StaleProcessError.\n */\nexport function isStaleProcessError(error: unknown): error is StaleProcessError {\n  return error instanceof StaleProcessError;\n}\n\n/**\n * Check if an error is a PackageDisabledError.\n */\nexport function isPackageDisabledError(error: unknown): error is PackageDisabledError {\n  return error instanceof PackageDisabledError;\n}\n\n/**\n * Check if an error is a PackageConflictError.\n */\nexport function isPackageConflictError(error: unknown): error is PackageConflictError {\n  return error instanceof PackageConflictError;\n}\n\n/**\n * Check if an error is an UnsupportedMacOSError.\n */\nexport function isUnsupportedMacOSError(error: unknown): error is UnsupportedMacOSError {\n  return error instanceof UnsupportedMacOSError;\n}\n\n/**\n * Check if an error is recoverable (can be retried).\n * Network errors, lock errors, timeout errors, and stale process errors are typically recoverable.\n * Disabled packages, conflicts, and macOS version errors are NOT recoverable.\n */\nexport function isRecoverableError(error: unknown): boolean {\n  return isNetworkError(error) || isBrewLockError(error) || isDownloadTimeoutError(error) || isStaleProcessError(error);\n}\n\n/// Message Detection\n\n/**\n * Patterns that indicate a brew lock/concurrent process error.\n */\nconst BREW_LOCK_PATTERNS = [\n  /lockf:.*already locked/i,\n  /another active Homebrew/i,\n  /another brew process/i,\n  /another.*brew.*update.*process/i,\n  /Homebrew is already running/i,\n  /Error: Another active Homebrew/i,\n  /Error: Another.*brew.*process/i,\n  /waiting for lock/i,\n  /lock file/i,\n  /has already locked/i, // Homebrew 5.0: \"A `brew upgrade` process has already locked ...\"\n  /brew upgrade.*process has already/i,\n];\n\n/**\n * Pattern to detect disabled/discontinued packages.\n * Matches: \"Error: Cask 'name' has been disabled because it is discontinued upstream! It was disabled on 2024-12-16.\"\n * Or: \"Error: Formula 'name' has been disabled because ...\"\n */\nconst DISABLED_PACKAGE_PATTERN =\n  /Error: (Cask|Formula) '([^']+)' has been disabled(?: because (.+?))?(?:! It was disabled on (\\d{4}-\\d{2}-\\d{2}))?/i;\n\n/**\n * Pattern to detect package conflicts.\n * Matches: \"Error: Cask 'name' conflicts with 'other'\"\n */\nconst CONFLICT_PATTERN = /Error: (Cask|Formula) '([^']+)' conflicts with '([^']+)'/i;\n\n/**\n * Pattern to detect macOS version requirements.\n * Matches: \"Error: Cask 'name' requires macOS >= 12.0\"\n */\nconst MACOS_VERSION_PATTERN = /Error: (Cask|Formula) '([^']+)' requires macOS\\s*([><=]+\\s*[\\d.]+)/i;\n\n/**\n * Check if an error message indicates a brew lock error.\n */\nexport function isBrewLockMessage(message: string): boolean {\n  return BREW_LOCK_PATTERNS.some((pattern) => pattern.test(message));\n}\n\n/**\n * Check if an error message indicates a disabled package.\n */\nexport function isDisabledPackageMessage(message: string): boolean {\n  return DISABLED_PACKAGE_PATTERN.test(message);\n}\n\n/**\n * Parse disabled package details from an error message.\n */\nexport function parseDisabledPackageMessage(message: string): {\n  packageType: \"formula\" | \"cask\";\n  packageName: string;\n  reason?: string;\n  disabledDate?: string;\n} | null {\n  const match = message.match(DISABLED_PACKAGE_PATTERN);\n  if (!match) return null;\n\n  return {\n    packageType: match[1].toLowerCase() as \"formula\" | \"cask\",\n    packageName: match[2],\n    reason: match[3]?.trim(),\n    disabledDate: match[4],\n  };\n}\n\n/**\n * Check if an error message indicates a package conflict.\n */\nexport function isConflictMessage(message: string): boolean {\n  return CONFLICT_PATTERN.test(message);\n}\n\n/**\n * Check if an error message indicates a macOS version requirement.\n */\nexport function isMacOSVersionMessage(message: string): boolean {\n  return MACOS_VERSION_PATTERN.test(message);\n}\n\n/**\n * Safely cast an unknown error to an Error instance.\n * If the value is already an Error, returns it as-is.\n * Otherwise, wraps it in a new Error with the string representation.\n */\nexport function ensureError(err: unknown): Error {\n  return err instanceof Error ? err : new Error(String(err));\n}\n\n/**\n * Get a user-friendly error message from an error.\n */\nexport function getErrorMessage(error: unknown): string {\n  if (error instanceof BrewLockError) {\n    return \"Another brew process is already running. Please wait for it to finish and try again.\";\n  }\n\n  if (error instanceof DownloadTimeoutError) {\n    const pkg = error.packageName ? ` for \"${error.packageName}\"` : \"\";\n    const phase = error.phase ? ` during ${error.phase}` : \"\";\n    return `Download timed out${pkg}${phase}. Please try again.`;\n  }\n\n  if (error instanceof StaleProcessError) {\n    const pkg = error.packageName ? ` for \"${error.packageName}\"` : \"\";\n    const phase = error.lastPhase ? ` (stuck at ${error.lastPhase})` : \"\";\n    return `Process appears stuck${pkg}${phase}. The operation was cancelled.`;\n  }\n\n  if (error instanceof PackageDisabledError) {\n    const type = error.packageType ?? \"package\";\n    const typeName = type.charAt(0).toUpperCase() + type.slice(1);\n    let message = `${typeName} \"${error.packageName}\" has been discontinued`;\n    if (error.reason) {\n      message += `: ${error.reason}`;\n    }\n    if (error.disabledDate) {\n      message += ` (disabled on ${error.disabledDate})`;\n    }\n    return message;\n  }\n\n  if (error instanceof PackageConflictError) {\n    const conflicts = error.conflictsWith?.join(\", \") ?? \"another package\";\n    return `\"${error.packageName}\" conflicts with ${conflicts}. Please uninstall the conflicting package first.`;\n  }\n\n  if (error instanceof UnsupportedMacOSError) {\n    let message = `\"${error.packageName}\" requires a different macOS version`;\n    if (error.requiredVersion) {\n      message += ` (requires ${error.requiredVersion})`;\n    }\n    return message;\n  }\n\n  if (error instanceof NetworkError) {\n    if (error.statusCode) {\n      return `Network error (HTTP ${error.statusCode}): ${error.message}`;\n    }\n    return `Network error: ${error.message}`;\n  }\n\n  if (error instanceof BrewNotFoundError) {\n    return `Homebrew not found: ${error.message}`;\n  }\n\n  if (error instanceof PackageNotFoundError) {\n    const type = error.packageType ?? \"package\";\n    return `${type.charAt(0).toUpperCase() + type.slice(1)} not found: ${error.packageName ?? error.message}`;\n  }\n\n  if (error instanceof BrewCommandError) {\n    // Check for null exit code (process was killed/cancelled)\n    if (error.exitCode === undefined || error.exitCode === null) {\n      return \"Cancelled\";\n    }\n    // Check if the stderr contains a known error pattern for better messages\n    if (error.stderr) {\n      // Check for disabled package\n      const disabledInfo = parseDisabledPackageMessage(error.stderr);\n      if (disabledInfo) {\n        let message = `${disabledInfo.packageType.charAt(0).toUpperCase() + disabledInfo.packageType.slice(1)} \"${disabledInfo.packageName}\" has been discontinued`;\n        if (disabledInfo.reason) {\n          message += `: ${disabledInfo.reason}`;\n        }\n        if (disabledInfo.disabledDate) {\n          message += ` (disabled on ${disabledInfo.disabledDate})`;\n        }\n        return message;\n      }\n    }\n    return error.stderr ?? error.message;\n  }\n\n  if (error instanceof BrewError) {\n    return error.message;\n  }\n\n  if (error instanceof Error) {\n    // Handle abort errors with user-friendly message\n    if (error.name === \"AbortError\") {\n      return \"Cancelled\";\n    }\n\n    // Check for ExecError-like objects\n    const execError = error as { stderr?: string; stdout?: string };\n    if (execError.stderr) {\n      // Check for disabled package in raw stderr\n      const disabledInfo = parseDisabledPackageMessage(execError.stderr);\n      if (disabledInfo) {\n        let message = `${disabledInfo.packageType.charAt(0).toUpperCase() + disabledInfo.packageType.slice(1)} \"${disabledInfo.packageName}\" has been discontinued`;\n        if (disabledInfo.reason) {\n          message += `: ${disabledInfo.reason}`;\n        }\n        if (disabledInfo.disabledDate) {\n          message += ` (disabled on ${disabledInfo.disabledDate})`;\n        }\n        return message;\n      }\n      return execError.stderr;\n    }\n    return error.message;\n  }\n\n  return String(error);\n}\n", "/**\n * Cache utilities for the Brew extension.\n *\n * Provides functions for managing cached data and remote fetching.\n */\n\nimport { environment, showToast, Toast } from \"@raycast/api\";\nimport path from \"path\";\nimport fs from \"fs\";\nimport { rm } from \"fs/promises\";\nimport { stat } from \"fs/promises\";\nimport { Readable } from \"stream\";\nimport { ReadableStream } from \"stream/web\";\nimport { chain } from \"stream-chain\";\nimport { parser } from \"stream-json\";\nimport { filter } from \"stream-json/filters/Filter\";\nimport { streamArray } from \"stream-json/streamers/StreamArray\";\nimport { pipeline as streamPipeline } from \"stream/promises\";\nimport { Remote, DownloadProgressCallback } from \"./types\";\nimport { cacheLogger, fetchLogger } from \"./logger\";\nimport { NetworkError, ParseError, isNetworkError, isRecoverableError, ensureError } from \"./errors\";\nimport { wait } from \"./async\";\nimport { preferences } from \"./preferences\";\n\n/// Cache Paths\n\nexport const supportPath: string = (() => {\n  try {\n    fs.mkdirSync(environment.supportPath, { recursive: true });\n  } catch {\n    cacheLogger.warn(\"Failed to create supportPath\");\n  }\n  return environment.supportPath;\n})();\n\nexport const bundleIdentifier: string = (() => {\n  return (\n    environment.supportPath.split(path.sep).find((comp) => {\n      if (comp.startsWith(\"com.raycast\")) {\n        return true;\n      }\n      return false;\n    }) ?? \"com.raycast.macos\"\n  );\n})();\n\nexport function cachePath(name: string): string {\n  return path.join(supportPath, name);\n}\n\nconst CACHE_FILES = [\"formula.json\", \"cask.json\", \"installedv2.json\"];\n\n/**\n * Clear all cached data files (formulae, casks, installed packages).\n */\nexport async function clearCache(): Promise<void> {\n  try {\n    cacheLogger.log(\"Starting cache clear operation\");\n    await showToast(Toast.Style.Animated, \"Clearing downloaded casks and formulae...\");\n\n    // Check which files exist before clearing\n    const existingFiles: string[] = [];\n    const fileSizes: Record<string, number> = {};\n\n    for (const file of CACHE_FILES) {\n      const filePath = path.join(environment.supportPath, file);\n      try {\n        const stats = await stat(filePath);\n        existingFiles.push(file);\n        fileSizes[file] = stats.size;\n      } catch {\n        // File doesn't exist\n      }\n    }\n\n    if (existingFiles.length > 0) {\n      cacheLogger.log(\"Clearing cache files\", {\n        files: existingFiles,\n        sizes: fileSizes,\n        totalBytes: Object.values(fileSizes).reduce((a, b) => a + b, 0),\n      });\n    } else {\n      cacheLogger.log(\"No cache files to clear\");\n    }\n\n    await Promise.all(\n      CACHE_FILES.map((file) =>\n        rm(path.join(environment.supportPath, file), { force: true }).catch(() => {\n          // Ignore errors for files that don't exist\n        }),\n      ),\n    );\n\n    cacheLogger.log(\"Cache clear completed\", {\n      filesCleared: existingFiles,\n      fileCount: existingFiles.length,\n    });\n\n    await showToast(Toast.Style.Success, \"Cache files cleared\");\n  } catch (err) {\n    const error = ensureError(err);\n    cacheLogger.error(\"Failed to clear cache\", { error: error.message });\n    await showToast(Toast.Style.Failure, \"Failed to clear cache\", error.message);\n  }\n}\n\n/// Remote Fetching\n\n// Top-level object keys which should be parsed from the raw JSON objects.\nconst valid_keys = [\n  \"name\",\n  \"tap\",\n  \"desc\",\n  \"homepage\",\n  \"versions\",\n  \"outdated\",\n  \"caveats\",\n  \"token\",\n  \"version\",\n  \"installed\",\n  \"auto_updates\",\n  \"depends_on\",\n  \"conflicts_with\",\n  \"license\",\n  \"aliases\",\n  \"dependencies\",\n  \"build_dependencies\",\n  \"installed\",\n  \"keg_only\",\n  \"linked_key\",\n  \"pinned\",\n];\n\n/** Maximum number of retry attempts for network requests */\nconst MAX_FETCH_RETRIES = 2;\n/** Delay between retry attempts in milliseconds */\nconst RETRY_DELAY_MS = 1000;\n\nexport async function fetchRemote<T>(remote: Remote<T>, onProgress?: DownloadProgressCallback): Promise<T[]> {\n  if (remote.value) {\n    // Already cached in memory\n    onProgress?.({\n      url: remote.url,\n      bytesDownloaded: 0,\n      totalBytes: 0,\n      percent: 100,\n      complete: true,\n    });\n    return remote.value;\n  } else if (remote.fetch) {\n    return remote.fetch;\n  } else {\n    remote.fetch = _fetchRemoteWithRetry(remote, onProgress)\n      .then((value) => {\n        remote.value = value;\n        return value;\n      })\n      .finally(() => {\n        remote.fetch = undefined;\n      });\n    return remote.fetch;\n  }\n}\n\n/**\n * Fetch remote data with automatic retry for transient network errors.\n */\nasync function _fetchRemoteWithRetry<T>(remote: Remote<T>, onProgress?: DownloadProgressCallback): Promise<T[]> {\n  let lastError: Error | undefined;\n\n  for (let attempt = 0; attempt <= MAX_FETCH_RETRIES; attempt++) {\n    try {\n      return await _fetchRemote(remote, attempt, onProgress);\n    } catch (error) {\n      lastError = error instanceof Error ? error : new Error(String(error));\n\n      // Only retry for recoverable errors (network issues)\n      if (!isRecoverableError(error) || attempt >= MAX_FETCH_RETRIES) {\n        throw lastError;\n      }\n\n      fetchLogger.warn(\"Fetch failed, retrying\", {\n        url: remote.url,\n        attempt: attempt + 1,\n        maxRetries: MAX_FETCH_RETRIES,\n        error: lastError.message,\n      });\n\n      // Wait before retrying\n      await wait(RETRY_DELAY_MS * (attempt + 1));\n    }\n  }\n\n  throw lastError;\n}\n\nasync function _fetchRemote<T>(\n  remote: Remote<T>,\n  attempt: number,\n  onProgress?: DownloadProgressCallback,\n): Promise<T[]> {\n  const fetchStartTime = Date.now();\n  fetchLogger.log(\"Fetching remote\", { url: remote.url, attempt });\n\n  async function fetchURL(): Promise<void> {\n    const downloadStartTime = Date.now();\n    fetchLogger.log(\"Starting download\", { url: remote.url });\n\n    try {\n      // Request uncompressed data so Content-Length matches actual bytes for accurate progress\n      const response = await fetch(remote.url, {\n        headers: {\n          \"Accept-Encoding\": \"identity\",\n        },\n      });\n      if (!response.ok || !response.body) {\n        throw new NetworkError(`HTTP ${response.status}: ${response.statusText}`, {\n          statusCode: response.status,\n          url: remote.url,\n        });\n      }\n\n      // Track response size for progress reporting\n      // With Accept-Encoding: identity, Content-Length should match actual bytes\n      const contentLength = response.headers.get(\"content-length\");\n      const totalBytes = contentLength ? parseInt(contentLength, 10) : 0;\n\n      // Track bytes for progress reporting\n      let bytesDownloaded = 0;\n\n      // Report initial progress\n      onProgress?.({\n        url: remote.url,\n        bytesDownloaded: 0,\n        totalBytes,\n        percent: 0,\n        complete: false,\n      });\n\n      // Create write stream with error handling\n      const writeStream = fs.createWriteStream(remote.cachePath);\n\n      try {\n        // If we have a progress callback, use a transform stream to track progress\n        // Otherwise, stream directly to avoid overhead\n        if (onProgress) {\n          // Throttle progress updates to avoid render loops (max once per 100ms)\n          let lastProgressUpdate = 0;\n          const PROGRESS_THROTTLE_MS = 100;\n\n          const progressStream = new TransformStream({\n            transform(chunk, controller) {\n              bytesDownloaded += chunk.length;\n              const now = Date.now();\n\n              // Only report progress if enough time has passed OR this is the final chunk\n              const isComplete = totalBytes > 0 && bytesDownloaded >= totalBytes;\n              if (isComplete || now - lastProgressUpdate >= PROGRESS_THROTTLE_MS) {\n                const percent = totalBytes > 0 ? Math.round((bytesDownloaded / totalBytes) * 100) : -1;\n                lastProgressUpdate = now;\n\n                onProgress({\n                  url: remote.url,\n                  bytesDownloaded,\n                  totalBytes,\n                  percent: Math.min(percent, 100), // Cap at 100%\n                  complete: false,\n                });\n              }\n\n              controller.enqueue(chunk);\n            },\n          });\n\n          // Pipe through progress tracker\n          const progressBody = response.body.pipeThrough(progressStream);\n          await streamPipeline(Readable.fromWeb(progressBody as ReadableStream), writeStream);\n        } else {\n          // Direct stream without progress tracking\n          await streamPipeline(Readable.fromWeb(response.body as ReadableStream), writeStream);\n        }\n      } catch (streamError) {\n        // Clean up partial file on stream failure\n        writeStream.destroy();\n        try {\n          fs.unlinkSync(remote.cachePath);\n          fetchLogger.log(\"Cleaned up partial cache file\", { path: remote.cachePath });\n        } catch {\n          // Ignore cleanup errors\n        }\n\n        // Report error state to progress callback\n        const errorMessage = streamError instanceof Error ? streamError.message : String(streamError);\n        onProgress?.({\n          url: remote.url,\n          bytesDownloaded,\n          totalBytes,\n          percent: -1,\n          complete: false,\n          error: true,\n          errorMessage,\n        });\n\n        throw streamError;\n      }\n\n      // Report completion\n      onProgress?.({\n        url: remote.url,\n        bytesDownloaded,\n        totalBytes,\n        percent: 100,\n        complete: true,\n      });\n\n      const downloadDurationMs = Date.now() - downloadStartTime;\n\n      // Log cache update with size metrics\n      const logData: Record<string, unknown> = {\n        path: remote.cachePath,\n        url: remote.url,\n        downloadDurationMs,\n      };\n\n      if (totalBytes > 0) {\n        const contentLengthKb = (totalBytes / 1024).toFixed(2);\n        logData.responseSizeBytes = totalBytes;\n        logData.responseSizeKb = `${contentLengthKb} KB`;\n      }\n\n      if (preferences.useInternalApi) {\n        logData.usingInternalApi = true;\n      }\n\n      cacheLogger.log(\"Cache updated from remote\", logData);\n    } catch (error) {\n      const downloadDurationMs = Date.now() - downloadStartTime;\n      fetchLogger.error(\"Download failed\", { url: remote.url, durationMs: downloadDurationMs, error });\n\n      // Report error state to progress callback\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      onProgress?.({\n        url: remote.url,\n        bytesDownloaded: 0,\n        totalBytes: 0,\n        percent: -1,\n        complete: false,\n        error: true,\n        errorMessage,\n      });\n\n      if (isNetworkError(error)) {\n        throw error;\n      }\n      // Wrap fetch errors as NetworkError for retry logic\n      throw new NetworkError(`Failed to fetch ${remote.url}`, {\n        cause: error instanceof Error ? error : undefined,\n        url: remote.url,\n      });\n    }\n  }\n\n  async function updateCache(): Promise<void> {\n    let cacheInfo: fs.Stats | undefined;\n    let lastModified = 0;\n    try {\n      cacheInfo = await stat(remote.cachePath);\n      const response = await fetch(remote.url, { method: \"HEAD\" });\n      lastModified = Date.parse(response.headers.get(\"last-modified\") ?? \"\");\n    } catch {\n      cacheLogger.log(\"Cache miss\", { path: remote.cachePath });\n    }\n    if (!cacheInfo || cacheInfo.size == 0 || lastModified > cacheInfo.mtimeMs) {\n      await fetchURL();\n    } else {\n      fetchLogger.log(\"Using cached data (up to date)\", {\n        url: remote.url,\n        cacheAgeMs: Date.now() - cacheInfo.mtimeMs,\n      });\n    }\n  }\n\n  async function readCache(): Promise<T[]> {\n    const parseStartTime = Date.now();\n    fetchLogger.log(\"Parsing cache\", { path: remote.cachePath });\n\n    const keysRe = new RegExp(`\\\\b(${valid_keys.join(\"|\")})\\\\b`);\n\n    return new Promise<T[]>((resolve, reject) => {\n      // Note: We accumulate all parsed objects in memory. For ~7000 formulae/casks,\n      // this is typically 5-15MB of heap usage. The streaming parser avoids loading\n      // the entire 30MB+ JSON file at once, but we still need to hold the parsed\n      // objects for the UI. A SQLite backend could reduce memory but adds complexity.\n      const value: T[] = [];\n      // Throttle processing progress updates (max once per 100ms)\n      let lastProgressUpdate = 0;\n      const PROGRESS_THROTTLE_MS = 100;\n\n      /** Report processing progress to callback */\n      const reportProgress = (complete: boolean) => {\n        onProgress?.({\n          url: remote.url,\n          bytesDownloaded: 0,\n          totalBytes: 0,\n          percent: 100, // Download is complete\n          complete,\n          phase: \"processing\",\n          itemsProcessed: value.length,\n          totalItems: complete ? value.length : undefined,\n        });\n      };\n\n      // stream-json/chain is quite slow, so unfortunately not suitable for real-time queries.\n      // migrating to a sqlite backend _might_ help, although the bootstrap cost\n      // (each time json response changes) will probably be high.\n      const pipeline = chain([\n        fs.createReadStream(remote.cachePath),\n        parser(),\n        filter({ filter: keysRe }),\n        streamArray(),\n      ]);\n      pipeline.on(\"data\", (data) => {\n        if (data && typeof data === \"object\" && \"value\" in data) {\n          value.push(data.value);\n\n          // Report processing progress (throttled)\n          const now = Date.now();\n          if (onProgress && now - lastProgressUpdate >= PROGRESS_THROTTLE_MS) {\n            lastProgressUpdate = now;\n            reportProgress(false);\n          }\n        }\n      });\n      pipeline.on(\"end\", () => {\n        const parseDurationMs = Date.now() - parseStartTime;\n        const totalDurationMs = Date.now() - fetchStartTime;\n        fetchLogger.log(\"Fetch completed\", {\n          url: remote.url,\n          itemCount: value.length,\n          parseDurationMs,\n          totalDurationMs,\n        });\n        reportProgress(true);\n        resolve(value);\n      });\n      pipeline.on(\"error\", (err) => {\n        const parseDurationMs = Date.now() - parseStartTime;\n        // Cache parsing failed, remove corrupted cache and retry\n        cacheLogger.warn(\"Cache parse error, removing corrupted cache\", {\n          path: remote.cachePath,\n          error: err.message,\n          parseDurationMs,\n        });\n        fs.rmSync(remote.cachePath);\n        reject(\n          new ParseError(\"Failed to parse cached data\", {\n            cause: err,\n          }),\n        );\n      });\n    });\n  }\n\n  return updateCache().then(readCache);\n}\n", "/**\n * Async utilities for the Brew extension.\n *\n * Provides helper functions for async operations.\n */\n\nimport { setTimeout } from \"node:timers\";\n\n/**\n * Wait for a specified number of milliseconds.\n *\n * Useful for:\n * - Waiting for toast actions to be clicked\n * - Implementing retry delays\n * - Debouncing operations\n *\n * Note: For \"no view\" commands, this allows users time to click Toast actions.\n * See: https://raycastapp.slack.com/archives/C01E6LWGXJ8/p1642676284027700\n */\nexport async function wait(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n", "/**\n * Homebrew progress tracking utilities.\n *\n * Provides functions for executing brew commands with real-time progress updates.\n */\n\nimport { spawn } from \"child_process\";\nimport { brewExecutable } from \"./paths\";\nimport { execBrewEnv } from \"./commands\";\nimport { brewLogger } from \"../logger\";\nimport { BrewLockError, isBrewLockMessage, BrewCommandError, StaleProcessError } from \"../errors\";\nimport { ExecResult } from \"../types\";\n\n/// Configuration\n\n/**\n * Default timeout for stale process detection (5 minutes).\n * If no progress is made for this duration, the process is considered stuck.\n */\nexport const DEFAULT_STALE_TIMEOUT_MS = 5 * 60 * 1000;\n\n/**\n * Timeout for download phase specifically (10 minutes).\n * Downloads can take longer, especially for large packages like LLVM.\n */\nexport const DOWNLOAD_PHASE_TIMEOUT_MS = 10 * 60 * 1000;\n\n/// Progress Types\n\n/**\n * Phases of a brew operation.\n */\nexport type BrewPhase =\n  | \"starting\"\n  | \"downloading\"\n  | \"verifying\"\n  | \"extracting\"\n  | \"installing\"\n  | \"linking\"\n  | \"cleaning\"\n  | \"complete\"\n  | \"error\";\n\n/**\n * Progress information for a brew operation.\n */\nexport interface BrewProgress {\n  phase: BrewPhase;\n  message: string;\n  percentage?: number;\n  bytesDownloaded?: number;\n  totalBytes?: number;\n}\n\n/**\n * Callback for progress updates.\n */\nexport type ProgressCallback = (progress: BrewProgress) => void;\n\n/// Progress Parsing\n\n/**\n * Parse brew output to extract progress information.\n */\nexport function parseBrewOutput(line: string): BrewProgress | null {\n  const trimmedLine = line.trim();\n  if (!trimmedLine) return null;\n\n  // Strip the \"==>\" prefix from Homebrew output for cleaner UI messages\n  const cleanMessage = trimmedLine.replace(/^=+>\\s*/, \"\");\n\n  // Downloading phase\n  if (trimmedLine.includes(\"Downloading\")) {\n    return { phase: \"downloading\", message: cleanMessage };\n  }\n\n  // Download progress (e.g., \"######## 50.0%\")\n  const percentMatch = trimmedLine.match(/#+\\s*(\\d+\\.?\\d*)%/);\n  if (percentMatch) {\n    return {\n      phase: \"downloading\",\n      message: `Downloading... ${percentMatch[1]}%`,\n      percentage: parseFloat(percentMatch[1]),\n    };\n  }\n\n  // Verifying checksum\n  if (trimmedLine.includes(\"Verifying\") || trimmedLine.includes(\"checksum\")) {\n    return { phase: \"verifying\", message: cleanMessage };\n  }\n\n  // Extracting/Pouring\n  if (trimmedLine.includes(\"Pouring\") || trimmedLine.includes(\"Extracting\")) {\n    return { phase: \"extracting\", message: cleanMessage };\n  }\n\n  // Installing\n  if (trimmedLine.includes(\"Installing\") || trimmedLine.includes(\"==> Installing\")) {\n    return { phase: \"installing\", message: cleanMessage };\n  }\n\n  // Linking\n  if (trimmedLine.includes(\"Linking\") || trimmedLine.includes(\"==> Linking\")) {\n    return { phase: \"linking\", message: cleanMessage };\n  }\n\n  // Cleaning\n  if (trimmedLine.includes(\"Cleaning\") || trimmedLine.includes(\"Removing\")) {\n    return { phase: \"cleaning\", message: cleanMessage };\n  }\n\n  // Caveats or summary\n  if (trimmedLine.includes(\"==> Caveats\") || trimmedLine.includes(\"==> Summary\")) {\n    return { phase: \"complete\", message: cleanMessage };\n  }\n\n  // Generic progress message\n  if (trimmedLine.startsWith(\"==>\")) {\n    return { phase: \"installing\", message: cleanMessage };\n  }\n\n  return null;\n}\n\n/**\n * Format bytes to human-readable string.\n */\nexport function formatBytes(bytes: number): string {\n  if (bytes < 1024) return `${bytes} B`;\n  if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;\n  if (bytes < 1024 * 1024 * 1024) return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;\n  return `${(bytes / (1024 * 1024 * 1024)).toFixed(1)} GB`;\n}\n\n/**\n * Options for executing brew commands with progress tracking.\n */\nexport interface ExecBrewWithProgressOptions {\n  /** Callback for progress updates */\n  onProgress?: ProgressCallback;\n  /** AbortSignal for cancellation */\n  cancel?: AbortSignal;\n  /** Timeout for stale process detection (ms). Default: 5 minutes */\n  staleTimeoutMs?: number;\n  /** Package name for error context */\n  packageName?: string;\n  /** Enable detailed phase logging */\n  verboseLogging?: boolean;\n}\n\n/**\n * Execute a brew command with real-time progress updates and stale process detection.\n *\n * Features:\n * - Real-time progress parsing from stdout/stderr\n * - Stale process detection (kills process if no progress for timeout period)\n * - Detailed phase logging for debugging stuck operations\n * - Lock error detection and proper error handling\n */\nexport async function execBrewWithProgress(\n  cmd: string,\n  onProgress?: ProgressCallback,\n  cancel?: AbortSignal,\n  options?: Omit<ExecBrewWithProgressOptions, \"onProgress\" | \"cancel\">,\n): Promise<ExecResult> {\n  const env = await execBrewEnv();\n  const args = cmd.split(/\\s+/).filter(Boolean);\n  const staleTimeoutMs = options?.staleTimeoutMs ?? DEFAULT_STALE_TIMEOUT_MS;\n  const packageName = options?.packageName;\n  const verboseLogging = options?.verboseLogging ?? false;\n\n  brewLogger.log(\"Executing brew with progress\", { command: cmd, packageName, staleTimeoutMs });\n\n  return new Promise((resolve, reject) => {\n    const proc = spawn(brewExecutable(), args, {\n      env,\n      stdio: [\"ignore\", \"pipe\", \"pipe\"],\n    });\n\n    let stdout = \"\";\n    let stderr = \"\";\n    let lastProgressTime = Date.now();\n    let currentPhase: BrewPhase = \"starting\";\n    let staleCheckInterval: NodeJS.Timeout | null = null;\n    let isRejected = false;\n\n    // Helper to clean up and reject\n    const cleanup = () => {\n      if (staleCheckInterval) {\n        clearInterval(staleCheckInterval);\n        staleCheckInterval = null;\n      }\n    };\n\n    const rejectOnce = (error: Error) => {\n      if (isRejected) return;\n      isRejected = true;\n      cleanup();\n      proc.kill(\"SIGTERM\");\n      reject(error);\n    };\n\n    // Stale process detection - check every 30 seconds\n    staleCheckInterval = setInterval(() => {\n      const now = Date.now();\n      const staleDuration = now - lastProgressTime;\n\n      // Use longer timeout for download phase\n      const effectiveTimeout = currentPhase === \"downloading\" ? DOWNLOAD_PHASE_TIMEOUT_MS : staleTimeoutMs;\n\n      if (staleDuration > effectiveTimeout) {\n        brewLogger.warn(\"Stale process detected\", {\n          command: cmd,\n          packageName,\n          lastPhase: currentPhase,\n          staleDurationMs: staleDuration,\n          timeoutMs: effectiveTimeout,\n        });\n\n        rejectOnce(\n          new StaleProcessError(`Process appears stuck during ${currentPhase}`, {\n            packageName,\n            lastPhase: currentPhase,\n            staleDurationMs: staleDuration,\n          }),\n        );\n      } else if (verboseLogging) {\n        brewLogger.log(\"Stale check passed\", {\n          command: cmd,\n          phase: currentPhase,\n          timeSinceLastProgress: staleDuration,\n          timeout: effectiveTimeout,\n        });\n      }\n    }, 30000);\n\n    // Handle cancellation\n    if (cancel) {\n      cancel.addEventListener(\"abort\", () => {\n        if (isRejected) return;\n        isRejected = true;\n        cleanup();\n        proc.kill(\"SIGTERM\");\n        const error = new Error(\"Cancelled\");\n        error.name = \"AbortError\";\n        reject(error);\n      });\n    }\n\n    // Report starting\n    onProgress?.({ phase: \"starting\", message: `Running: brew ${cmd.trim()}` });\n\n    // Helper to process output and update progress\n    const processOutput = (text: string, source: \"stdout\" | \"stderr\") => {\n      lastProgressTime = Date.now();\n\n      const lines = text.split(\"\\n\");\n      for (const line of lines) {\n        const progress = parseBrewOutput(line);\n        if (progress) {\n          // Track phase transitions for detailed logging\n          if (progress.phase !== currentPhase) {\n            brewLogger.log(\"Phase transition\", {\n              command: cmd,\n              packageName,\n              from: currentPhase,\n              to: progress.phase,\n              message: progress.message,\n            });\n            currentPhase = progress.phase;\n          }\n          onProgress?.(progress);\n        } else if (verboseLogging && line.trim()) {\n          // Log unparsed output for debugging\n          brewLogger.log(`Unparsed ${source}`, { line: line.trim() });\n        }\n      }\n    };\n\n    proc.stdout?.on(\"data\", (data: Buffer) => {\n      const text = data.toString();\n      stdout += text;\n      processOutput(text, \"stdout\");\n    });\n\n    proc.stderr?.on(\"data\", (data: Buffer) => {\n      const text = data.toString();\n      stderr += text;\n\n      // Check for lock errors\n      if (isBrewLockMessage(text)) {\n        rejectOnce(\n          new BrewLockError(\"Another brew process is already running\", {\n            command: cmd,\n          }),\n        );\n        return;\n      }\n\n      // Parse stderr for progress too (brew outputs some progress to stderr)\n      processOutput(text, \"stderr\");\n    });\n\n    proc.on(\"close\", (code) => {\n      cleanup();\n      if (isRejected) return;\n\n      brewLogger.log(\"Command completed\", {\n        command: cmd,\n        packageName,\n        exitCode: code,\n        finalPhase: currentPhase,\n      });\n\n      if (code === 0) {\n        onProgress?.({ phase: \"complete\", message: \"Operation completed successfully\" });\n        resolve({ stdout, stderr });\n      } else {\n        onProgress?.({ phase: \"error\", message: `Command failed with exit code ${code}` });\n        reject(\n          new BrewCommandError(`brew ${cmd} failed with exit code ${code}`, {\n            command: cmd,\n            exitCode: code ?? undefined,\n            stderr,\n          }),\n        );\n      }\n    });\n\n    proc.on(\"error\", (err) => {\n      cleanup();\n      if (isRejected) return;\n      onProgress?.({ phase: \"error\", message: err.message });\n      reject(err);\n    });\n  });\n}\n", "/**\n * Homebrew Internal API utilities.\n *\n * Provides functions for fetching data from Homebrew's internal JSON API.\n * This API is significantly smaller and faster than the public API:\n * - Formula: ~1 MB vs ~30 MB (96% smaller)\n * - Cask: Similar size but wrapped in JWS format\n *\n * The internal API is experimental and may change without notice.\n * Use the `useInternalApi` preference to enable it.\n */\n\nimport { cpus, release } from \"os\";\nimport { execSync } from \"child_process\";\nimport * as fs from \"fs\";\nimport { chain } from \"stream-chain\";\nimport { parser } from \"stream-json\";\nimport { pick } from \"stream-json/filters/Pick\";\nimport { streamObject } from \"stream-json/streamers/StreamObject\";\nimport { Formula, DownloadProgressCallback } from \"../types\";\nimport { cacheLogger, fetchLogger } from \"../logger\";\nimport { logMemory, withMemoryTracking } from \"../memory\";\n\n/// System Tag Detection\n\n/**\n * macOS version name mapping from major version number.\n * Darwin kernel version = macOS version + 4 (e.g., Darwin 24.x = macOS 15 Sequoia)\n * https://en.wikipedia.org/wiki/Darwin_(operating_system)#Release_history\n */\nconst MACOS_VERSION_NAMES: Record<number, string> = {\n  15: \"sequoia\", // macOS 15 (Darwin 24.x)\n  14: \"sonoma\", // macOS 14 (Darwin 23.x)\n  13: \"ventura\", // macOS 13 (Darwin 22.x)\n  12: \"monterey\", // macOS 12 (Darwin 21.x)\n  11: \"big_sur\", // macOS 11 (Darwin 20.x)\n  // Homebrew 5.0 dropped support for macOS 10.14 (Mojave) and earlier\n};\n\n// Future macOS versions (for development/testing)\nconst MACOS_FUTURE_VERSIONS: Record<string, number> = {\n  tahoe: 26, // macOS 26 (future)\n};\n\n// Cache detected values to avoid repeated system calls\nlet cachedSystemTag: string | null = null;\nlet cachedMacOSVersion: number | null = null;\n\n/**\n * Get the current system tag for internal API URLs.\n * Format: {arch}_{os_version} (e.g., \"arm64_sequoia\", \"x86_64_sonoma\")\n */\nexport function getSystemTag(): string {\n  if (cachedSystemTag) {\n    return cachedSystemTag;\n  }\n\n  const arch = getArchitecture();\n  const osVersion = getMacOSVersionName();\n  cachedSystemTag = `${arch}_${osVersion}`;\n\n  fetchLogger.log(\"Detected system tag\", {\n    systemTag: cachedSystemTag,\n    architecture: arch,\n    macOSVersion: osVersion,\n  });\n\n  return cachedSystemTag;\n}\n\n/**\n * Get the CPU architecture.\n * Uses process.arch as primary source, with CPU model as fallback.\n *\n * Handles:\n * - process.arch: \"arm64\" \u2192 \"arm64\", \"x64\" \u2192 \"x86_64\"\n * - CPU model detection: Fallback for edge cases (Apple Silicon, Intel detection)\n * - Error handling: Safe defaults if detection fails (returns \"x86_64\")\n */\nfunction getArchitecture(): string {\n  // Method 1: Use process.arch (most reliable)\n  // Node.js process.arch values: https://nodejs.org/api/process.html#process_process_arch\n  if (process.arch === \"arm64\") {\n    return \"arm64\";\n  }\n  if (process.arch === \"x64\") {\n    return \"x86_64\";\n  }\n  // Other architectures (ppc64, s390x, etc.) - not supported by Homebrew on macOS\n  // Treat unknown architectures as x86_64 (safe default)\n\n  // Method 2: Fallback to CPU model detection\n  // This handles edge cases where process.arch might be unreliable\n  try {\n    const cpuList = cpus();\n    if (!cpuList || cpuList.length === 0) {\n      // No CPUs detected, use safe default\n      fetchLogger.warn(\"No CPUs detected, defaulting to x86_64\");\n      return \"x86_64\";\n    }\n\n    const firstCpu = cpuList[0];\n    if (!firstCpu || typeof firstCpu.model !== \"string\") {\n      // CPU model is not a string, use safe default\n      fetchLogger.warn(\"CPU model is not a string, defaulting to x86_64\", {\n        cpuModel: typeof firstCpu?.model,\n      });\n      return \"x86_64\";\n    }\n\n    // Check for Apple Silicon markers\n    if (firstCpu.model.includes(\"Apple\")) {\n      return \"arm64\";\n    }\n\n    // Check for Intel markers\n    if (firstCpu.model.includes(\"Intel\")) {\n      return \"x86_64\";\n    }\n\n    // Unknown CPU model, use safe default\n    fetchLogger.warn(\"Unknown CPU model, defaulting to x86_64\", {\n      cpuModel: firstCpu.model,\n    });\n    return \"x86_64\";\n  } catch (error) {\n    // CPU detection failed entirely, use safe default\n    fetchLogger.warn(\"CPU detection failed, defaulting to x86_64\", {\n      error: error instanceof Error ? error.message : String(error),\n    });\n    return \"x86_64\";\n  }\n}\n\n/**\n * Get the macOS major version number.\n * Uses multiple detection methods for reliability.\n */\nfunction getMacOSVersion(): number {\n  if (cachedMacOSVersion !== null) {\n    return cachedMacOSVersion;\n  }\n\n  // Method 1: Check environment variable override (for testing/development)\n  const envVersion = process.env.HOMEBREW_MACOS_VERSION;\n  if (envVersion) {\n    const parsed = parseInt(envVersion, 10);\n    if (!isNaN(parsed) && parsed >= 11 && parsed <= 30) {\n      cachedMacOSVersion = parsed;\n      return cachedMacOSVersion;\n    }\n  }\n\n  // Method 2: Try sw_vers command (most accurate)\n  try {\n    const swVersOutput = execSync(\"sw_vers -productVersion\", {\n      encoding: \"utf8\",\n      timeout: 5000,\n      stdio: [\"pipe\", \"pipe\", \"pipe\"],\n    }).trim();\n    // Format: \"15.1\" or \"14.6.1\"\n    const majorVersion = parseInt(swVersOutput.split(\".\")[0], 10);\n    if (!isNaN(majorVersion) && majorVersion >= 11) {\n      cachedMacOSVersion = majorVersion;\n      return cachedMacOSVersion;\n    }\n  } catch {\n    // sw_vers failed, try next method\n  }\n\n  // Method 3: Derive from Darwin kernel version\n  // Darwin version = macOS version + 4 (approximately)\n  // e.g., Darwin 24.x = macOS 15 (Sequoia)\n  try {\n    const darwinVersion = release(); // e.g., \"24.1.0\"\n    const darwinMajor = parseInt(darwinVersion.split(\".\")[0], 10);\n    if (!isNaN(darwinMajor) && darwinMajor >= 20) {\n      // Darwin 20 = macOS 11, Darwin 21 = macOS 12, etc.\n      cachedMacOSVersion = darwinMajor - 9;\n      return cachedMacOSVersion;\n    }\n  } catch {\n    // Darwin version detection failed\n  }\n\n  // Method 4: Default based on architecture (last resort)\n  // Apple Silicon requires macOS 11+, most users are on recent versions\n  const arch = getArchitecture();\n  cachedMacOSVersion = arch === \"arm64\" ? 15 : 14; // Sequoia for ARM, Sonoma for Intel\n  return cachedMacOSVersion;\n}\n\n/**\n * Get the macOS version name (e.g., \"sequoia\", \"sonoma\").\n */\nfunction getMacOSVersionName(): string {\n  const version = getMacOSVersion();\n\n  // Check known versions\n  const versionName = MACOS_VERSION_NAMES[version];\n  if (versionName) {\n    return versionName;\n  }\n\n  // Check future versions\n  for (const [name, futureVersion] of Object.entries(MACOS_FUTURE_VERSIONS)) {\n    if (version === futureVersion) {\n      return name;\n    }\n  }\n\n  // Unknown version - use the most recent known version\n  // This handles cases where a new macOS is released before we update the map\n  if (version > 15) {\n    fetchLogger.warn(\"Unknown macOS version, using sequoia as fallback\", {\n      detectedVersion: version,\n    });\n    return \"sequoia\";\n  }\n\n  // Very old version (shouldn't happen with Homebrew 5.0)\n  fetchLogger.warn(\"Unsupported macOS version detected\", {\n    detectedVersion: version,\n    minimumSupported: 11,\n  });\n  return \"big_sur\";\n}\n\n/// Internal API URLs\n\nconst INTERNAL_API_BASE = \"https://formulae.brew.sh/api/internal\";\n\n/**\n * Get the internal API URL for formulae.\n */\nexport function getInternalFormulaUrl(): string {\n  const tag = getSystemTag();\n  return `${INTERNAL_API_BASE}/formula.${tag}.jws.json`;\n}\n\n/**\n * Get the internal API URL for casks.\n *\n * Note: Currently not used - casks use the public API for better memory efficiency.\n * The internal cask API (~13 MB) requires JWS parsing overhead that negates the\n * download size benefit compared to stream-json parsing the public API (~30 MB).\n * Kept for potential future use if a more efficient JWS parser is implemented.\n */\nexport function getInternalCaskUrl(): string {\n  const tag = getSystemTag();\n  return `${INTERNAL_API_BASE}/cask.${tag}.jws.json`;\n}\n\n/// JWS Payload Parsing\n\n/**\n * Internal formula data structure from the API.\n * Array format: [version, version_scheme, rebuild, sha256, dependencies]\n */\ntype InternalFormulaArray = [string, number, number, string | null, string[]];\n\n/// Streaming Cache Functions\n\n/**\n * Download internal API and write to standard cache format.\n *\n * This hybrid approach:\n * 1. Downloads the smaller internal API (~1 MB formulae vs ~30 MB)\n * 2. Extracts the JWS payload\n * 3. Converts to array format and writes to standard cache files\n * 4. Allows existing stream-json parsing to be used for reading\n *\n * Memory optimization: We stream the download to disk, then process\n * the JWS payload incrementally to avoid holding large data in memory.\n */\n\n/**\n * Download internal formulae API and write to cache in standard array format.\n * Uses streaming to avoid loading the entire payload into memory.\n *\n * @param cachePath - Path to write the converted cache file\n * @param onProgress - Optional callback for progress updates\n */\nexport async function downloadAndCacheInternalFormulae(\n  cachePath: string,\n  onProgress?: DownloadProgressCallback,\n): Promise<void> {\n  const url = getInternalFormulaUrl();\n  const startTime = Date.now();\n  const tempJwsPath = cachePath + \".jws.tmp\";\n\n  fetchLogger.log(\"Downloading internal formulae API for cache\", { url, cachePath });\n\n  await withMemoryTracking(\n    \"downloadAndCacheInternalFormulae\",\n    async () => {\n      // Report initial progress\n      onProgress?.({\n        url,\n        bytesDownloaded: 0,\n        totalBytes: 0,\n        percent: 0,\n        complete: false,\n        phase: \"downloading\",\n      });\n\n      const response = await fetch(url);\n      if (!response.ok || !response.body) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n\n      const contentLength = response.headers.get(\"content-length\");\n      const totalBytes = contentLength ? parseInt(contentLength, 10) : 0;\n\n      // Step 1: Stream download directly to temp file (no memory accumulation)\n      let bytesDownloaded = 0;\n      let lastProgressUpdate = 0;\n      const PROGRESS_THROTTLE_MS = 100;\n\n      const downloadStream = fs.createWriteStream(tempJwsPath);\n      const reader = response.body.getReader();\n\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) break;\n\n        downloadStream.write(Buffer.from(value));\n        bytesDownloaded += value.length;\n\n        const now = Date.now();\n        if (now - lastProgressUpdate >= PROGRESS_THROTTLE_MS) {\n          lastProgressUpdate = now;\n          const percent = totalBytes > 0 ? Math.round((bytesDownloaded / totalBytes) * 100) : -1;\n          onProgress?.({\n            url,\n            bytesDownloaded,\n            totalBytes,\n            percent,\n            complete: false,\n            phase: \"downloading\",\n          });\n        }\n      }\n\n      await new Promise<void>((resolve, reject) => {\n        downloadStream.end((err: Error | null) => {\n          if (err) reject(err);\n          else resolve();\n        });\n      });\n\n      logMemory(\"After formulae download to disk\");\n\n      onProgress?.({\n        url,\n        bytesDownloaded,\n        totalBytes,\n        percent: 100,\n        complete: false,\n        phase: \"processing\",\n      });\n\n      // Step 2: Extract the payload from JWS directly to a temp file (no memory accumulation)\n      const tempPayloadPath = cachePath + \".payload.tmp\";\n      await extractJwsPayloadToFile(tempJwsPath, tempPayloadPath);\n      logMemory(\"After JWS payload extraction to disk\");\n\n      // Step 4: Stream-parse the formulae and write to cache\n      // Formulae are in format: {\"formulae\": {\"name\": [version, scheme, rebuild, sha256, deps], ...}}\n      let itemsProcessed = 0;\n      const writeStream = fs.createWriteStream(cachePath);\n      writeStream.write(\"[\");\n\n      await new Promise<void>((resolve, reject) => {\n        const pipeline = chain([\n          fs.createReadStream(tempPayloadPath),\n          parser(),\n          pick({ filter: \"formulae\" }),\n          streamObject(),\n        ]);\n\n        let isFirst = true;\n\n        pipeline.on(\"data\", (data: { key: string; value: InternalFormulaArray }) => {\n          if (data && data.key && data.value) {\n            const formula = createFormulaFromInternal(data.key, data.value);\n\n            if (!isFirst) {\n              writeStream.write(\",\\n\");\n            } else {\n              writeStream.write(\"\\n\");\n              isFirst = false;\n            }\n            writeStream.write(JSON.stringify(formula));\n            itemsProcessed++;\n\n            // Report progress (throttled)\n            const now = Date.now();\n            if (now - lastProgressUpdate >= PROGRESS_THROTTLE_MS) {\n              lastProgressUpdate = now;\n              onProgress?.({\n                url,\n                bytesDownloaded,\n                totalBytes,\n                percent: 100,\n                complete: false,\n                phase: \"processing\",\n                itemsProcessed,\n              });\n            }\n          }\n        });\n\n        pipeline.on(\"end\", () => {\n          writeStream.write(\"\\n]\");\n          writeStream.end((err: Error | null) => {\n            if (err) reject(err);\n            else resolve();\n          });\n        });\n\n        pipeline.on(\"error\", reject);\n      });\n\n      // Clean up temp files\n      try {\n        fs.unlinkSync(tempJwsPath);\n        fs.unlinkSync(tempPayloadPath);\n      } catch {\n        // Ignore cleanup errors\n      }\n\n      logMemory(\"After formulae cache write (streaming)\");\n\n      const duration = Date.now() - startTime;\n      fetchLogger.log(\"Internal formulae cached\", {\n        url,\n        cachePath,\n        count: itemsProcessed,\n        durationMs: duration,\n        downloadBytes: bytesDownloaded,\n      });\n\n      onProgress?.({\n        url,\n        bytesDownloaded,\n        totalBytes,\n        percent: 100,\n        complete: true,\n        phase: \"processing\",\n        itemsProcessed,\n        totalItems: itemsProcessed,\n      });\n    },\n    { logAlways: true },\n  );\n}\n\n/**\n * Extract the payload from a JWS file and write it directly to another file.\n * This avoids loading the entire payload string into memory.\n *\n * The JWS format is: {\"payload\": \"...escaped JSON string...\", ...}\n * We stream through the file, find the payload value, unescape it, and write to output.\n *\n * Memory optimization: Use array-based buffering to avoid string concatenation overhead.\n */\nasync function extractJwsPayloadToFile(jwsFilePath: string, outputPath: string): Promise<void> {\n  return new Promise((resolve, reject) => {\n    const readStream = fs.createReadStream(jwsFilePath, { encoding: \"utf8\", highWaterMark: 16 * 1024 });\n    const writeStream = fs.createWriteStream(outputPath, { highWaterMark: 16 * 1024 });\n\n    let state: \"searching\" | \"in_payload\" | \"done\" = \"searching\";\n    let searchBuffer = \"\";\n    let unicodeBuffer = \"\";\n    let escapeNext = false;\n\n    // Use array-based buffering to avoid string concatenation memory overhead\n    const outputChunks: string[] = [];\n    let outputSize = 0;\n    const FLUSH_THRESHOLD = 8 * 1024; // Flush every 8KB\n\n    const flushOutput = () => {\n      if (outputChunks.length > 0) {\n        writeStream.write(outputChunks.join(\"\"));\n        outputChunks.length = 0;\n        outputSize = 0;\n      }\n    };\n\n    const appendOutput = (str: string) => {\n      outputChunks.push(str);\n      outputSize += str.length;\n      if (outputSize >= FLUSH_THRESHOLD) {\n        flushOutput();\n      }\n    };\n\n    // We're looking for: \"payload\":\" then capturing until the closing unescaped \"\n    const payloadMarker = '\"payload\":\"';\n\n    readStream.on(\"data\", (chunkData: string | Buffer) => {\n      const chunk = typeof chunkData === \"string\" ? chunkData : chunkData.toString(\"utf8\");\n      if (state === \"done\") return;\n\n      // Process chunk - collect runs of regular characters to batch\n      let runStart = -1;\n\n      for (let i = 0; i < chunk.length; i++) {\n        const char = chunk[i];\n\n        if (state === \"searching\") {\n          searchBuffer += char;\n          // Keep buffer small - only need enough to match the marker\n          if (searchBuffer.length > payloadMarker.length) {\n            searchBuffer = searchBuffer.slice(-payloadMarker.length);\n          }\n          if (searchBuffer === payloadMarker) {\n            state = \"in_payload\";\n            searchBuffer = \"\";\n          }\n        } else if (state === \"in_payload\") {\n          if (escapeNext) {\n            // Handle escape sequences\n            escapeNext = false;\n            if (char === \"n\") {\n              appendOutput(\"\\n\");\n            } else if (char === \"r\") {\n              appendOutput(\"\\r\");\n            } else if (char === \"t\") {\n              appendOutput(\"\\t\");\n            } else if (char === '\"') {\n              appendOutput('\"');\n            } else if (char === \"\\\\\") {\n              appendOutput(\"\\\\\");\n            } else if (char === \"/\") {\n              appendOutput(\"/\");\n            } else if (char === \"u\") {\n              // Unicode escape - collect next 4 chars\n              unicodeBuffer = \"\\\\u\";\n            } else {\n              // Unknown escape, write as-is\n              appendOutput(char);\n            }\n          } else if (unicodeBuffer.length > 0) {\n            unicodeBuffer += char;\n            if (unicodeBuffer.length === 6) {\n              // Complete unicode escape: \\uXXXX\n              try {\n                const codePoint = parseInt(unicodeBuffer.slice(2), 16);\n                appendOutput(String.fromCharCode(codePoint));\n              } catch {\n                appendOutput(unicodeBuffer);\n              }\n              unicodeBuffer = \"\";\n            }\n          } else if (char === \"\\\\\") {\n            // Flush any pending run before escape\n            if (runStart >= 0) {\n              appendOutput(chunk.slice(runStart, i));\n              runStart = -1;\n            }\n            escapeNext = true;\n          } else if (char === '\"') {\n            // Flush any pending run\n            if (runStart >= 0) {\n              appendOutput(chunk.slice(runStart, i));\n              runStart = -1;\n            }\n            // End of payload string\n            state = \"done\";\n            flushOutput();\n            writeStream.end();\n            resolve();\n            return;\n          } else {\n            // Regular character - start or continue a run\n            if (runStart < 0) {\n              runStart = i;\n            }\n          }\n        }\n      }\n\n      // Flush any remaining run from this chunk\n      if (state === \"in_payload\" && runStart >= 0) {\n        appendOutput(chunk.slice(runStart));\n      }\n    });\n\n    readStream.on(\"end\", () => {\n      if (state !== \"done\") {\n        flushOutput();\n        writeStream.end();\n        if (state === \"searching\") {\n          reject(new Error(\"No payload found in JWS file\"));\n        } else {\n          // Payload wasn't properly terminated, but we got data\n          resolve();\n        }\n      }\n    });\n\n    readStream.on(\"error\", (err) => {\n      writeStream.end();\n      reject(err);\n    });\n\n    writeStream.on(\"error\", reject);\n  });\n}\n\n/**\n * Create a Formula object from internal API data.\n * The internal API only provides minimal data, so we create a minimal Formula.\n */\nfunction createFormulaFromInternal(name: string, data: InternalFormulaArray): Formula {\n  const [version, , , , dependencies] = data;\n\n  return {\n    name,\n    tap: \"homebrew/core\",\n    homepage: \"\",\n    versions: { stable: version, bottle: true },\n    outdated: false,\n    license: null,\n    aliases: [],\n    dependencies: dependencies || [],\n    build_dependencies: [],\n    installed: [],\n    keg_only: false,\n    linked_key: \"\",\n    pinned: false,\n    // Note: desc is not available in internal API\n    // Users can still search by name\n  };\n}\n\n/**\n * Log internal API configuration for debugging.\n */\nexport function logInternalApiConfig(): void {\n  const tag = getSystemTag();\n  const formulaUrl = getInternalFormulaUrl();\n  const caskUrl = getInternalCaskUrl();\n\n  cacheLogger.log(\"Internal API configuration\", {\n    systemTag: tag,\n    formulaUrl,\n    caskUrl,\n  });\n}\n", "/**\n * Memory diagnostics utilities.\n *\n * Provides functions for monitoring memory usage in Raycast's constrained\n * worker environment. Helps identify memory issues and potential leaks.\n *\n * Usage:\n *   import { memoryLogger, logMemory, withMemoryTracking } from \"./memory\";\n *\n *   // Simple logging\n *   logMemory(\"Before large operation\");\n *\n *   // Track memory around an operation\n *   const result = await withMemoryTracking(\"fetchFormulae\", async () => {\n *     return await fetchData();\n *   });\n */\n\nimport { Logger } from \"@chrismessina/raycast-logger\";\n\n/**\n * Memory logger instance.\n */\nexport const memoryLogger = new Logger({\n  prefix: \"[Brew]\",\n}).child(\"[Memory]\");\n\n/**\n * Memory usage snapshot with additional context.\n */\nexport interface MemorySnapshot {\n  /** Timestamp of the snapshot */\n  timestamp: number;\n  /** Label for this snapshot */\n  label: string;\n  /** Resident Set Size - total memory allocated to the process */\n  rss: number;\n  /** Total heap size allocated */\n  heapTotal: number;\n  /** Heap memory currently in use */\n  heapUsed: number;\n  /** Memory used by external C++ objects */\n  external: number;\n  /** Memory used by ArrayBuffers */\n  arrayBuffers: number;\n  /** Percentage of heap used (heapUsed / heapTotal) */\n  heapPercent: number;\n  /** Caller information (function name, file, line) */\n  caller?: CallerInfo;\n  /** Stack trace (if enabled) */\n  stack?: string;\n}\n\n/**\n * Caller information extracted from stack trace.\n */\nexport interface CallerInfo {\n  /** Function name */\n  functionName: string;\n  /** File path */\n  fileName: string;\n  /** Line number */\n  lineNumber: number;\n  /** Column number */\n  columnNumber: number;\n}\n\n/**\n * Memory tracking result for operations.\n */\nexport interface MemoryTrackingResult<T> {\n  /** The result of the tracked operation */\n  result: T;\n  /** Memory snapshot before the operation */\n  before: MemorySnapshot;\n  /** Memory snapshot after the operation */\n  after: MemorySnapshot;\n  /** Memory delta (after - before) */\n  delta: MemoryDelta;\n  /** Duration of the operation in milliseconds */\n  durationMs: number;\n}\n\n/**\n * Memory delta between two snapshots.\n */\nexport interface MemoryDelta {\n  rss: number;\n  heapTotal: number;\n  heapUsed: number;\n  external: number;\n  arrayBuffers: number;\n}\n\n/**\n * Warning thresholds for memory usage.\n */\nconst MEMORY_THRESHOLDS = {\n  /** Warn when heap usage exceeds this percentage */\n  heapPercentWarning: 70,\n  /** Critical when heap usage exceeds this percentage */\n  heapPercentCritical: 85,\n  /** Warn when a single operation increases heap by this many MB */\n  deltaWarningMB: 50,\n};\n\n/**\n * Format bytes to a human-readable string.\n */\nfunction formatBytes(bytes: number): string {\n  if (bytes < 1024) return `${bytes} B`;\n  if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;\n  return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;\n}\n\n/**\n * Parse a V8 stack trace line to extract caller info.\n * Format: \"    at functionName (filePath:line:column)\"\n * Or:     \"    at filePath:line:column\"\n */\nfunction parseStackLine(line: string): CallerInfo | undefined {\n  // Match: \"at functionName (filePath:line:column)\"\n  const withFunctionMatch = line.match(/at\\s+(.+?)\\s+\\((.+):(\\d+):(\\d+)\\)/);\n  if (withFunctionMatch) {\n    return {\n      functionName: withFunctionMatch[1],\n      fileName: withFunctionMatch[2],\n      lineNumber: parseInt(withFunctionMatch[3], 10),\n      columnNumber: parseInt(withFunctionMatch[4], 10),\n    };\n  }\n\n  // Match: \"at filePath:line:column\" (anonymous function)\n  const anonymousMatch = line.match(/at\\s+(.+):(\\d+):(\\d+)/);\n  if (anonymousMatch) {\n    return {\n      functionName: \"<anonymous>\",\n      fileName: anonymousMatch[1],\n      lineNumber: parseInt(anonymousMatch[2], 10),\n      columnNumber: parseInt(anonymousMatch[3], 10),\n    };\n  }\n\n  return undefined;\n}\n\n/**\n * Get caller information from the current stack trace.\n * @param skipFrames Number of stack frames to skip (default: 2 to skip this function and the caller)\n */\nfunction getCallerInfo(skipFrames = 2): CallerInfo | undefined {\n  const stack = new Error().stack;\n  if (!stack) return undefined;\n\n  const lines = stack.split(\"\\n\");\n  // Skip \"Error\" line and the specified number of frames\n  const callerLine = lines[skipFrames + 1];\n  if (!callerLine) return undefined;\n\n  return parseStackLine(callerLine);\n}\n\n/**\n * Get a cleaned stack trace string.\n * @param skipFrames Number of stack frames to skip\n * @param maxFrames Maximum number of frames to include\n */\nfunction getStackTrace(skipFrames = 2, maxFrames = 5): string {\n  const stack = new Error().stack;\n  if (!stack) return \"\";\n\n  const lines = stack.split(\"\\n\");\n  // Skip \"Error\" line and the specified number of frames\n  const relevantLines = lines.slice(skipFrames + 1, skipFrames + 1 + maxFrames);\n\n  return relevantLines.map((line) => line.trim()).join(\"\\n\");\n}\n\n/**\n * Take a memory snapshot with caller information.\n * @param label A descriptive label for this snapshot\n * @param includeStack Whether to include the full stack trace\n */\nexport function takeMemorySnapshot(label: string, includeStack = false): MemorySnapshot {\n  const mem = process.memoryUsage();\n  const heapPercent = mem.heapTotal > 0 ? (mem.heapUsed / mem.heapTotal) * 100 : 0;\n\n  const snapshot: MemorySnapshot = {\n    timestamp: Date.now(),\n    label,\n    rss: mem.rss,\n    heapTotal: mem.heapTotal,\n    heapUsed: mem.heapUsed,\n    external: mem.external,\n    arrayBuffers: mem.arrayBuffers,\n    heapPercent,\n    caller: getCallerInfo(3), // Skip: takeMemorySnapshot, logMemory/withMemoryTracking, actual caller\n  };\n\n  if (includeStack) {\n    snapshot.stack = getStackTrace(3);\n  }\n\n  return snapshot;\n}\n\n/**\n * Calculate the delta between two memory snapshots.\n */\nfunction calculateDelta(before: MemorySnapshot, after: MemorySnapshot): MemoryDelta {\n  return {\n    rss: after.rss - before.rss,\n    heapTotal: after.heapTotal - before.heapTotal,\n    heapUsed: after.heapUsed - before.heapUsed,\n    external: after.external - before.external,\n    arrayBuffers: after.arrayBuffers - before.arrayBuffers,\n  };\n}\n\n/**\n * Get a warning indicator based on heap percentage.\n */\nfunction getWarningIndicator(heapPercent: number): string {\n  if (heapPercent >= MEMORY_THRESHOLDS.heapPercentCritical) return \"\uD83D\uDD34 CRITICAL\";\n  if (heapPercent >= MEMORY_THRESHOLDS.heapPercentWarning) return \"\u26A0\uFE0F HIGH\";\n  return \"\";\n}\n\n/**\n * Format a memory snapshot for logging.\n */\nfunction formatSnapshot(snapshot: MemorySnapshot): Record<string, unknown> {\n  const warning = getWarningIndicator(snapshot.heapPercent);\n\n  const result: Record<string, unknown> = {\n    label: snapshot.label,\n    heapUsed: formatBytes(snapshot.heapUsed),\n    heapTotal: formatBytes(snapshot.heapTotal),\n    heapPercent: `${snapshot.heapPercent.toFixed(1)}%`,\n    rss: formatBytes(snapshot.rss),\n  };\n\n  if (warning) {\n    result.warning = warning;\n  }\n\n  if (snapshot.caller) {\n    const { functionName, fileName, lineNumber } = snapshot.caller;\n    // Shorten file path for readability\n    const shortFileName = fileName.split(\"/\").slice(-2).join(\"/\");\n    result.caller = `${functionName} (${shortFileName}:${lineNumber})`;\n  }\n\n  if (snapshot.stack) {\n    result.stack = snapshot.stack;\n  }\n\n  return result;\n}\n\n/**\n * Log current memory usage with caller information.\n * @param label A descriptive label for this log entry\n * @param includeStack Whether to include the full stack trace\n */\nexport function logMemory(label: string, includeStack = false): MemorySnapshot {\n  const snapshot = takeMemorySnapshot(label, includeStack);\n  memoryLogger.log(label, formatSnapshot(snapshot));\n  return snapshot;\n}\n\n/**\n * Log a warning if memory usage is high.\n * @param label A descriptive label\n * @param snapshot The memory snapshot to check\n */\nfunction logMemoryWarning(label: string, snapshot: MemorySnapshot): void {\n  if (snapshot.heapPercent >= MEMORY_THRESHOLDS.heapPercentCritical) {\n    memoryLogger.error(`${label} - CRITICAL memory usage`, {\n      ...formatSnapshot(snapshot),\n      recommendation: \"Consider reducing data size or clearing cache\",\n    });\n  } else if (snapshot.heapPercent >= MEMORY_THRESHOLDS.heapPercentWarning) {\n    memoryLogger.warn(`${label} - High memory usage`, formatSnapshot(snapshot));\n  }\n}\n\n/**\n * Track memory usage around an async operation.\n * Logs before/after snapshots and the delta.\n *\n * @param operationName Name of the operation being tracked\n * @param operation The async operation to track\n * @param options Tracking options\n * @returns The result of the operation along with memory tracking data\n */\nexport async function withMemoryTracking<T>(\n  operationName: string,\n  operation: () => Promise<T>,\n  options: { includeStack?: boolean; logAlways?: boolean } = {},\n): Promise<MemoryTrackingResult<T>> {\n  const { includeStack = false, logAlways = true } = options;\n\n  const before = takeMemorySnapshot(`Before ${operationName}`, includeStack);\n  const startTime = Date.now();\n\n  if (logAlways) {\n    memoryLogger.log(`Starting: ${operationName}`, formatSnapshot(before));\n  }\n\n  let result: T;\n  try {\n    result = await operation();\n  } catch (error) {\n    // Log memory state on error\n    const errorSnapshot = takeMemorySnapshot(`Error in ${operationName}`, true);\n    memoryLogger.error(`Memory state at error in ${operationName}`, {\n      ...formatSnapshot(errorSnapshot),\n      error: error instanceof Error ? error.message : String(error),\n    });\n    throw error;\n  }\n\n  const after = takeMemorySnapshot(`After ${operationName}`, includeStack);\n  const durationMs = Date.now() - startTime;\n  const delta = calculateDelta(before, after);\n\n  const deltaHeapMB = delta.heapUsed / (1024 * 1024);\n  const isLargeDelta = Math.abs(deltaHeapMB) >= MEMORY_THRESHOLDS.deltaWarningMB;\n\n  if (logAlways || isLargeDelta) {\n    memoryLogger.log(`Completed: ${operationName}`, {\n      durationMs,\n      heapDelta: formatBytes(delta.heapUsed),\n      heapBefore: formatBytes(before.heapUsed),\n      heapAfter: formatBytes(after.heapUsed),\n      heapPercent: `${after.heapPercent.toFixed(1)}%`,\n      ...(isLargeDelta ? { warning: `\u26A0\uFE0F Large heap change: ${deltaHeapMB.toFixed(1)} MB` } : {}),\n    });\n  }\n\n  // Check for warnings after operation\n  logMemoryWarning(operationName, after);\n\n  return {\n    result,\n    before,\n    after,\n    delta,\n    durationMs,\n  };\n}\n\n/**\n * Synchronous version of withMemoryTracking for non-async operations.\n */\nexport function withMemoryTrackingSync<T>(\n  operationName: string,\n  operation: () => T,\n  options: { includeStack?: boolean; logAlways?: boolean } = {},\n): MemoryTrackingResult<T> {\n  const { includeStack = false, logAlways = true } = options;\n\n  const before = takeMemorySnapshot(`Before ${operationName}`, includeStack);\n  const startTime = Date.now();\n\n  if (logAlways) {\n    memoryLogger.log(`Starting: ${operationName}`, formatSnapshot(before));\n  }\n\n  let result: T;\n  try {\n    result = operation();\n  } catch (error) {\n    const errorSnapshot = takeMemorySnapshot(`Error in ${operationName}`, true);\n    memoryLogger.error(`Memory state at error in ${operationName}`, {\n      ...formatSnapshot(errorSnapshot),\n      error: error instanceof Error ? error.message : String(error),\n    });\n    throw error;\n  }\n\n  const after = takeMemorySnapshot(`After ${operationName}`, includeStack);\n  const durationMs = Date.now() - startTime;\n  const delta = calculateDelta(before, after);\n\n  const deltaHeapMB = delta.heapUsed / (1024 * 1024);\n  const isLargeDelta = Math.abs(deltaHeapMB) >= MEMORY_THRESHOLDS.deltaWarningMB;\n\n  if (logAlways || isLargeDelta) {\n    memoryLogger.log(`Completed: ${operationName}`, {\n      durationMs,\n      heapDelta: formatBytes(delta.heapUsed),\n      heapBefore: formatBytes(before.heapUsed),\n      heapAfter: formatBytes(after.heapUsed),\n      heapPercent: `${after.heapPercent.toFixed(1)}%`,\n      ...(isLargeDelta ? { warning: `\u26A0\uFE0F Large heap change: ${deltaHeapMB.toFixed(1)} MB` } : {}),\n    });\n  }\n\n  logMemoryWarning(operationName, after);\n\n  return {\n    result,\n    before,\n    after,\n    delta,\n    durationMs,\n  };\n}\n\n/**\n * Get a summary of current memory usage.\n * Useful for periodic health checks.\n */\nexport function getMemorySummary(): {\n  heapUsed: string;\n  heapTotal: string;\n  heapPercent: string;\n  rss: string;\n  status: \"ok\" | \"warning\" | \"critical\";\n} {\n  const mem = process.memoryUsage();\n  const heapPercent = mem.heapTotal > 0 ? (mem.heapUsed / mem.heapTotal) * 100 : 0;\n\n  let status: \"ok\" | \"warning\" | \"critical\" = \"ok\";\n  if (heapPercent >= MEMORY_THRESHOLDS.heapPercentCritical) {\n    status = \"critical\";\n  } else if (heapPercent >= MEMORY_THRESHOLDS.heapPercentWarning) {\n    status = \"warning\";\n  }\n\n  return {\n    heapUsed: formatBytes(mem.heapUsed),\n    heapTotal: formatBytes(mem.heapTotal),\n    heapPercent: `${heapPercent.toFixed(1)}%`,\n    rss: formatBytes(mem.rss),\n    status,\n  };\n}\n", "/**\n * Homebrew data fetching utilities.\n *\n * Provides functions for fetching installed and outdated packages.\n *\n * Performance optimization: Uses a two-phase loading strategy:\n * 1. Fast initial load with `brew list --versions` (returns minimal data quickly)\n * 2. Background fetch with `brew info --json=v2 --installed` for full metadata\n *\n * When `useInternalApi` preference is enabled, uses Homebrew's internal API:\n * - Formula: ~1 MB vs ~30 MB (96% smaller, much faster)\n * - Cask: Similar size but in JWS format\n */\n\nimport * as fs from \"fs/promises\";\nimport { execSync } from \"child_process\";\nimport {\n  Cask,\n  Formula,\n  InstallableResults,\n  InstalledMap,\n  OutdatedResults,\n  Remote,\n  DownloadProgressCallback,\n} from \"../types\";\nimport { cachePath, fetchRemote } from \"../cache\";\nimport { brewPath } from \"./paths\";\nimport { execBrew } from \"./commands\";\nimport { brewLogger, cacheLogger } from \"../logger\";\nimport { preferences } from \"../preferences\";\nimport { downloadAndCacheInternalFormulae, logInternalApiConfig } from \"./internal-api\";\n\n/// Cache Paths\n\nconst installedCachePath = cachePath(\"installedv2.json\");\nconst formulaCachePath = cachePath(\"formula.json\");\nconst caskCachePath = cachePath(\"cask.json\");\n\n/// Remote URLs\n\nconst formulaURL = \"https://formulae.brew.sh/api/formula.json\";\nconst caskURL = \"https://formulae.brew.sh/api/cask.json\";\n\nconst formulaRemote: Remote<Formula> = { url: formulaURL, cachePath: formulaCachePath };\nconst caskRemote: Remote<Cask> = { url: caskURL, cachePath: caskCachePath };\n\n/**\n * Check if the search cache files exist (formula.json and cask.json).\n * Used to determine if this is a cold start (no cache) or warm start (cache exists).\n */\nexport async function hasSearchCache(): Promise<boolean> {\n  try {\n    const [formulaStats, caskStats] = await Promise.all([fs.stat(formulaCachePath), fs.stat(caskCachePath)]);\n    // Both files must exist and have content\n    return formulaStats.size > 0 && caskStats.size > 0;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Minimal installed package info parsed from `brew list --versions`.\n * This is much faster than `brew info --json=v2 --installed`.\n */\ninterface InstalledListItem {\n  name: string;\n  version: string;\n  installed_on_request: boolean;\n}\n\n/**\n * Parse `brew list --versions` output into InstalledListItem array.\n * Format: \"package_name version1 version2 ...\" (one per line)\n */\nfunction parseListVersionsOutput(output: string): InstalledListItem[] {\n  const items: InstalledListItem[] = [];\n  const lines = output\n    .trim()\n    .split(\"\\n\")\n    .filter((line) => line.length > 0);\n\n  for (const line of lines) {\n    const parts = line.split(/\\s+/);\n    if (parts.length >= 2) {\n      const name = parts[0];\n      // Use the first (most recent) version\n      const version = parts[1];\n      items.push({\n        name,\n        version,\n        // We don't know this from list output, default to true\n        installed_on_request: true,\n      });\n    }\n  }\n\n  return items;\n}\n\n/**\n * Fetch a fast list of installed packages (names and versions only).\n * Uses `brew list --versions` which is significantly faster than `brew info --json=v2 --installed`.\n *\n * @returns Minimal installed package data for quick initial display\n */\nexport async function brewFetchInstalledFast(cancel?: AbortSignal): Promise<InstalledMap | undefined> {\n  const startTime = Date.now();\n\n  try {\n    // Try to read from cache first\n    const cacheBuffer = await fs.readFile(installedCachePath);\n    const cached = JSON.parse(cacheBuffer.toString()) as InstallableResults;\n    const mapped = brewMapInstalled(cached);\n    const duration = Date.now() - startTime;\n\n    cacheLogger.log(\"Fast load from cache\", {\n      formulaeCount: mapped?.formulae.size ?? 0,\n      casksCount: mapped?.casks.size ?? 0,\n      durationMs: duration,\n    });\n\n    return mapped;\n  } catch {\n    // Cache miss - fall back to fast list command\n    const listStartTime = Date.now();\n\n    try {\n      // brew list --versions is fast and gives us name + version\n      // Note: --versions output is \"name version1 version2 ...\" per line\n      const [formulaeOutput, casksOutput] = await Promise.all([\n        execBrew(`list --formula --versions`, cancel ? { signal: cancel } : undefined),\n        execBrew(`list --cask --versions`, cancel ? { signal: cancel } : undefined),\n      ]);\n\n      const formulaeList = parseListVersionsOutput(formulaeOutput.stdout);\n      const casksList = parseListVersionsOutput(casksOutput.stdout);\n\n      // Create minimal Formula/Cask objects for display\n      const formulae = new Map<string, Formula>();\n      for (const item of formulaeList) {\n        formulae.set(item.name, createMinimalFormula(item));\n      }\n\n      const casks = new Map<string, Cask>();\n      for (const item of casksList) {\n        casks.set(item.name, createMinimalCask(item));\n      }\n\n      const duration = Date.now() - listStartTime;\n      brewLogger.log(\"Fast list fetched\", {\n        formulaeCount: formulae.size,\n        casksCount: casks.size,\n        durationMs: duration,\n      });\n\n      return { formulae, casks };\n    } catch (err) {\n      brewLogger.error(\"Fast list fetch failed\", { error: err });\n      return undefined;\n    }\n  }\n}\n\n/**\n * Create a minimal Formula object from list data.\n */\nfunction createMinimalFormula(item: InstalledListItem): Formula {\n  return {\n    name: item.name,\n    tap: \"\",\n    homepage: \"\",\n    versions: { stable: item.version, bottle: false },\n    outdated: false,\n    license: null,\n    aliases: [],\n    dependencies: [],\n    build_dependencies: [],\n    installed: [\n      {\n        version: item.version,\n        installed_as_dependency: !item.installed_on_request,\n        installed_on_request: item.installed_on_request,\n      },\n    ],\n    keg_only: false,\n    linked_key: \"\",\n    pinned: false,\n  };\n}\n\n/**\n * Create a minimal Cask object from list data.\n */\nfunction createMinimalCask(item: InstalledListItem): Cask {\n  return {\n    token: item.name,\n    name: [item.name],\n    tap: \"\",\n    homepage: \"\",\n    version: item.version,\n    versions: { stable: item.version, bottle: false },\n    outdated: false,\n    installed: item.version,\n    auto_updates: false,\n    depends_on: {},\n  };\n}\n\n/**\n * Fetch all installed packages with full metadata.\n */\nexport async function brewFetchInstalled(useCache: boolean, cancel?: AbortSignal): Promise<InstalledMap | undefined> {\n  const startTime = Date.now();\n  const results = await brewFetchInstallableResults(useCache, cancel);\n  const mapped = brewMapInstalled(results);\n  const duration = Date.now() - startTime;\n\n  if (mapped) {\n    brewLogger.log(\"Installed packages fetched\", {\n      formulaeCount: mapped.formulae.size,\n      casksCount: mapped.casks.size,\n      totalCount: mapped.formulae.size + mapped.casks.size,\n      durationMs: duration,\n      fromCache: useCache,\n    });\n  }\n\n  return mapped;\n}\n\nasync function brewFetchInstallableResults(\n  useCache: boolean,\n  cancel?: AbortSignal,\n): Promise<InstallableResults | undefined> {\n  async function installed(): Promise<string> {\n    return (await execBrew(`info --json=v2 --installed`, cancel ? { signal: cancel } : undefined)).stdout;\n  }\n\n  if (!useCache) {\n    return JSON.parse(await installed());\n  }\n\n  async function updateCache(): Promise<InstallableResults> {\n    const startTime = Date.now();\n    const info = await installed();\n    const parsed = JSON.parse(info) as InstallableResults;\n    const duration = Date.now() - startTime;\n\n    try {\n      await fs.writeFile(installedCachePath, info);\n      const responseSizeBytes = Buffer.byteLength(info, \"utf8\");\n      const responseSizeKb = (responseSizeBytes / 1024).toFixed(2);\n\n      cacheLogger.log(\"Updated installed cache\", {\n        path: installedCachePath,\n        formulaeCount: parsed.formulae.length,\n        casksCount: parsed.casks.length,\n        totalCount: parsed.formulae.length + parsed.casks.length,\n        durationMs: duration,\n        responseSizeBytes,\n        responseSizeKb: `${responseSizeKb} KB`,\n        usingInternalApi: preferences.useInternalApi,\n      });\n    } catch (err) {\n      cacheLogger.error(\"Failed to write installed cache\", {\n        path: installedCachePath,\n        formulaeCount: parsed.formulae.length,\n        casksCount: parsed.casks.length,\n        error: err,\n      });\n    }\n    return parsed;\n  }\n\n  async function mtimeMs(path: string): Promise<number> {\n    return (await fs.stat(path)).mtimeMs;\n  }\n\n  async function readCache(): Promise<InstallableResults> {\n    const cacheTime = await mtimeMs(installedCachePath);\n    // 'var/homebrew/locks' is updated after installed keg_only or linked formula.\n    const locksTime = await mtimeMs(brewPath(\"var/homebrew/locks\"));\n    // Casks\n    const caskroomTime = await mtimeMs(brewPath(\"Caskroom\"));\n\n    // 'var/homebrew/pinned' is updated after pin/unpin actions (but does not exist if there are no pinned formula).\n    let pinnedTime;\n    try {\n      pinnedTime = await mtimeMs(brewPath(\"var/homebrew/pinned\"));\n    } catch {\n      pinnedTime = 0;\n    }\n    // Because '/var/homebrew/pinned can be removed, we need to also check the parent directory'\n    const homebrewTime = await mtimeMs(brewPath(\"var/homebrew\"));\n\n    if (homebrewTime < cacheTime && caskroomTime < cacheTime && locksTime < cacheTime && pinnedTime < cacheTime) {\n      const cacheBuffer = await fs.readFile(installedCachePath);\n      const cached = JSON.parse(cacheBuffer.toString()) as InstallableResults;\n      cacheLogger.log(\"Using cached installed data\", {\n        path: installedCachePath,\n        formulaeCount: cached.formulae.length,\n        casksCount: cached.casks.length,\n        totalCount: cached.formulae.length + cached.casks.length,\n        cacheAgeMs: Date.now() - cacheTime,\n      });\n      return cached;\n    } else {\n      cacheLogger.log(\"Cache invalidated, refreshing\", {\n        reason: \"brew state changed\",\n        homebrewTime,\n        caskroomTime,\n        locksTime,\n        pinnedTime,\n        cacheTime,\n      });\n      return await updateCache();\n    }\n  }\n\n  try {\n    return await readCache();\n  } catch {\n    return await updateCache();\n  }\n}\n\nfunction brewMapInstalled(installed?: InstallableResults): InstalledMap | undefined {\n  if (!installed) {\n    return undefined;\n  }\n\n  const formulae = new Map<string, Formula>();\n  for (const formula of installed.formulae) {\n    formulae.set(formula.name, formula);\n  }\n\n  const casks = new Map<string, Cask>();\n  for (const cask of installed.casks) {\n    casks.set(cask.token, cask);\n  }\n\n  return { formulae: formulae, casks: casks };\n}\n\n/**\n * Fetch outdated packages.\n *\n * @param greedy - Include auto-updating casks\n * @param cancel - AbortController for cancellation\n * @param skipUpdate - Skip brew update (use cached index). Faster but may miss recent updates.\n */\nexport async function brewFetchOutdated(\n  greedy: boolean,\n  cancel?: AbortSignal,\n  skipUpdate = false,\n): Promise<OutdatedResults> {\n  brewLogger.log(\"Fetching outdated packages\", { greedy, skipUpdate });\n  let cmd = `outdated --json=v2`;\n  if (greedy) {\n    cmd += \" --greedy\"; // include auto_update casks\n  }\n  // 'outdated' is only reliable after performing a 'brew update'\n  // skipUpdate allows showing stale data quickly, then refreshing\n  if (!skipUpdate) {\n    await brewUpdate(cancel);\n  }\n  const output = await execBrew(cmd, cancel ? { signal: cancel } : undefined);\n  const results = JSON.parse(output.stdout) as OutdatedResults;\n  brewLogger.log(\"Outdated packages fetched\", {\n    formulaeCount: results.formulae.length,\n    casksCount: results.casks.length,\n    skipUpdate,\n  });\n  return results;\n}\n\n/**\n * Run brew update.\n */\nexport async function brewUpdate(cancel?: AbortSignal): Promise<void> {\n  brewLogger.log(\"Running brew update\");\n  await execBrew(`update`, cancel ? { signal: cancel } : undefined);\n  brewLogger.log(\"Brew update completed\");\n}\n\n// Track if we've logged internal API config (only log once per session)\nlet hasLoggedInternalApiConfig = false;\n\n// Mutex to prevent concurrent internal API cache updates\n// This prevents memory exhaustion when multiple search calls happen simultaneously\nlet formulaeCacheUpdateInProgress: Promise<void> | null = null;\n\n/**\n * Check if the internal API cache needs updating.\n * Uses HEAD request to check Last-Modified header.\n */\nasync function needsInternalApiCacheUpdate(internalApiUrl: string, localCachePath: string): Promise<boolean> {\n  try {\n    const stats = await fs.stat(localCachePath);\n    if (stats.size === 0) return true;\n\n    const response = await fetch(internalApiUrl, { method: \"HEAD\" });\n    const lastModified = Date.parse(response.headers.get(\"last-modified\") ?? \"\");\n\n    if (lastModified > stats.mtimeMs) {\n      cacheLogger.log(\"Internal API cache outdated\", {\n        cachePath: localCachePath,\n        cacheTime: stats.mtimeMs,\n        remoteTime: lastModified,\n      });\n      return true;\n    }\n\n    cacheLogger.log(\"Internal API cache up to date\", {\n      cachePath: localCachePath,\n      cacheAgeMs: Date.now() - stats.mtimeMs,\n    });\n    return false;\n  } catch {\n    // Cache doesn't exist or error checking\n    return true;\n  }\n}\n\n/**\n * Fetch all formulae from the remote API.\n * Uses internal API when `useInternalApi` preference is enabled.\n * Falls back to public API if internal API fails.\n *\n * Hybrid approach (when useInternalApi is enabled):\n * 1. Downloads smaller internal API (~1 MB vs ~30 MB)\n * 2. Converts to standard array format and writes to cache\n * 3. Uses existing stream-json parsing for memory-efficient reading\n *\n * Internal API benefits:\n * - ~1 MB download vs ~30 MB (96% smaller)\n * - Much faster initial load\n * - Note: No description field (search by name only)\n */\nexport async function brewFetchFormulae(onProgress?: DownloadProgressCallback): Promise<Formula[]> {\n  if (preferences.useInternalApi) {\n    if (!hasLoggedInternalApiConfig) {\n      logInternalApiConfig();\n      hasLoggedInternalApiConfig = true;\n    }\n    try {\n      // Check if we need to update the cache from internal API\n      const internalApiUrl = \"https://formulae.brew.sh/api/internal/formula.\" + getSystemTagForCache() + \".jws.json\";\n      const needsUpdate = await needsInternalApiCacheUpdate(internalApiUrl, formulaCachePath);\n\n      if (needsUpdate) {\n        // Use mutex to prevent concurrent cache updates (memory exhaustion)\n        if (formulaeCacheUpdateInProgress) {\n          brewLogger.log(\"Waiting for existing formulae cache update to complete\");\n          await formulaeCacheUpdateInProgress;\n        } else {\n          // Download internal API and write to standard cache format\n          brewLogger.log(\"Updating formulae cache from internal API\");\n          formulaeCacheUpdateInProgress = downloadAndCacheInternalFormulae(formulaCachePath, onProgress);\n          try {\n            await formulaeCacheUpdateInProgress;\n          } finally {\n            formulaeCacheUpdateInProgress = null;\n          }\n        }\n      }\n\n      // Now use the standard fetchRemote path which uses stream-json\n      // The cache file is already populated, so this will just read it\n      return await fetchRemote(formulaRemote, onProgress);\n    } catch (error) {\n      // Internal API failed, fall back to public API\n      brewLogger.warn(\"Internal formulae API failed, falling back to public API\", {\n        error: error instanceof Error ? error.message : String(error),\n      });\n      return await fetchRemote(formulaRemote, onProgress);\n    }\n  }\n  return await fetchRemote(formulaRemote, onProgress);\n}\n\n/**\n * Fetch all casks from the remote API.\n * Always uses the public API with stream-json parsing for memory efficiency.\n *\n * Note: The internal API for casks is ~13 MB (vs ~30 MB public) but requires\n * complex JWS parsing that adds memory pressure. The public API's stream-json\n * parsing is more memory-efficient overall, so we use it exclusively for casks.\n *\n * The internal API is only used for formulae where the size difference is\n * significant (~1 MB vs ~30 MB, 96% smaller).\n */\nexport async function brewFetchCasks(onProgress?: DownloadProgressCallback): Promise<Cask[]> {\n  // Always use public API for casks - stream-json parsing is more memory-efficient\n  // than the JWS parsing overhead of the internal API\n  return await fetchRemote(caskRemote, onProgress);\n}\n\n/**\n * Get the system tag for internal API URLs.\n * This is a local helper to avoid circular imports.\n */\nfunction getSystemTagForCache(): string {\n  // Use the same logic as internal-api.ts\n  const arch = process.arch === \"arm64\" ? \"arm64\" : \"x86_64\";\n\n  // Get macOS version name\n  let osVersion = \"sequoia\"; // default\n  try {\n    const swVersOutput = execSync(\"sw_vers -productVersion\", {\n      encoding: \"utf8\",\n      timeout: 5000,\n      stdio: [\"pipe\", \"pipe\", \"pipe\"],\n    }).trim();\n    const majorVersion = parseInt(swVersOutput.split(\".\")[0], 10);\n\n    const versionNames: Record<number, string> = {\n      15: \"sequoia\",\n      14: \"sonoma\",\n      13: \"ventura\",\n      12: \"monterey\",\n      11: \"big_sur\",\n    };\n    osVersion = versionNames[majorVersion] || \"sequoia\";\n  } catch {\n    // Use default\n  }\n\n  return `${arch}_${osVersion}`;\n}\n\n/**\n * Fetch info for a single formula by name.\n * Much faster than fetching all installed packages.\n */\nexport async function brewFetchFormulaInfo(name: string, cancel?: AbortSignal): Promise<Formula | undefined> {\n  const startTime = Date.now();\n  brewLogger.log(\"Fetching formula info\", { name });\n\n  try {\n    const output = await execBrew(`info --json=v2 ${name}`, cancel ? { signal: cancel } : undefined);\n    const results = JSON.parse(output.stdout) as InstallableResults;\n    const duration = Date.now() - startTime;\n\n    if (results.formulae.length > 0) {\n      brewLogger.log(\"Formula info fetched\", { name, durationMs: duration });\n      return results.formulae[0];\n    }\n\n    brewLogger.warn(\"Formula not found\", { name, durationMs: duration });\n    return undefined;\n  } catch (err) {\n    brewLogger.error(\"Failed to fetch formula info\", { name, error: err });\n    return undefined;\n  }\n}\n\n/**\n * Fetch info for a single cask by token.\n * Much faster than fetching all installed packages.\n */\nexport async function brewFetchCaskInfo(token: string, cancel?: AbortSignal): Promise<Cask | undefined> {\n  const startTime = Date.now();\n  brewLogger.log(\"Fetching cask info\", { token });\n\n  try {\n    const output = await execBrew(`info --json=v2 ${token}`, cancel ? { signal: cancel } : undefined);\n    const results = JSON.parse(output.stdout) as InstallableResults;\n    const duration = Date.now() - startTime;\n\n    if (results.casks.length > 0) {\n      brewLogger.log(\"Cask info fetched\", { token, durationMs: duration });\n      return results.casks[0];\n    }\n\n    brewLogger.warn(\"Cask not found\", { token, durationMs: duration });\n    return undefined;\n  } catch (err) {\n    brewLogger.error(\"Failed to fetch cask info\", { token, error: err });\n    return undefined;\n  }\n}\n", "/**\n * Homebrew action utilities.\n *\n * Provides functions for installing, uninstalling, and upgrading packages.\n */\n\nimport { Cask, Formula, Nameable, OutdatedFormula } from \"../types\";\nimport { actionsLogger } from \"../logger\";\nimport { preferences } from \"../preferences\";\nimport { execBrew } from \"./commands\";\nimport { execBrewWithProgress, ProgressCallback } from \"./progress\";\nimport { brewIdentifier, brewCaskOption, isCask } from \"./helpers\";\nimport { ExecError } from \"../types\";\n\n/**\n * Install a package.\n */\nexport async function brewInstall(installable: Cask | Formula, cancel?: AbortSignal): Promise<void> {\n  const identifier = brewIdentifier(installable);\n  const isCaskType = isCask(installable);\n  actionsLogger.log(\"Installing package\", {\n    identifier,\n    type: isCaskType ? \"cask\" : \"formula\",\n  });\n  await execBrew(`install ${brewCaskOption(installable)} ${identifier}`, cancel ? { signal: cancel } : undefined);\n  if (isCaskType) {\n    (installable as Cask).installed = (installable as Cask).version;\n  } else {\n    installable.installed = [\n      { version: installable.versions.stable, installed_as_dependency: false, installed_on_request: true },\n    ];\n  }\n  actionsLogger.log(\"Package installed successfully\", { identifier });\n}\n\n/**\n * Install a package with real-time progress updates.\n */\nexport async function brewInstallWithProgress(\n  installable: Cask | Formula,\n  onProgress?: ProgressCallback,\n  cancel?: AbortSignal,\n): Promise<void> {\n  const identifier = brewIdentifier(installable);\n  const isCaskType = isCask(installable);\n  actionsLogger.log(\"Installing package with progress\", {\n    identifier,\n    type: isCaskType ? \"cask\" : \"formula\",\n  });\n  await execBrewWithProgress(`install ${brewCaskOption(installable)} ${identifier}`, onProgress, cancel);\n  if (isCaskType) {\n    (installable as Cask).installed = (installable as Cask).version;\n  } else {\n    installable.installed = [\n      { version: installable.versions.stable, installed_as_dependency: false, installed_on_request: true },\n    ];\n  }\n  actionsLogger.log(\"Package installed successfully\", { identifier });\n}\n\n/**\n * Uninstall a package.\n */\nexport async function brewUninstall(installable: Cask | Nameable, cancel?: AbortSignal): Promise<void> {\n  const identifier = brewIdentifier(installable);\n  actionsLogger.log(\"Uninstalling package\", {\n    identifier,\n    type: isCask(installable) ? \"cask\" : \"formula\",\n    zap: preferences.zapCask,\n  });\n  await execBrew(`rm ${brewCaskOption(installable, true)} ${identifier}`, cancel ? { signal: cancel } : undefined);\n  actionsLogger.log(\"Package uninstalled successfully\", { identifier });\n}\n\n/**\n * Upgrade a package.\n */\nexport async function brewUpgrade(upgradable: Cask | Nameable, cancel?: AbortSignal): Promise<void> {\n  const identifier = brewIdentifier(upgradable);\n  actionsLogger.log(\"Upgrading package\", {\n    identifier,\n    type: isCask(upgradable) ? \"cask\" : \"formula\",\n  });\n  await execBrew(`upgrade ${brewCaskOption(upgradable)} ${identifier}`, cancel ? { signal: cancel } : undefined);\n  actionsLogger.log(\"Package upgraded successfully\", { identifier });\n}\n\n/**\n * Upgrade a package with real-time progress updates.\n */\nexport async function brewUpgradeSingleWithProgress(\n  upgradable: Cask | Nameable,\n  onProgress?: ProgressCallback,\n  cancel?: AbortSignal,\n): Promise<void> {\n  const identifier = brewIdentifier(upgradable);\n  actionsLogger.log(\"Upgrading package with progress\", {\n    identifier,\n    type: isCask(upgradable) ? \"cask\" : \"formula\",\n  });\n  await execBrewWithProgress(`upgrade ${brewCaskOption(upgradable)} ${identifier}`, onProgress, cancel);\n  actionsLogger.log(\"Package upgraded successfully\", { identifier });\n}\n\n/**\n * Upgrade all packages.\n */\nexport async function brewUpgradeAll(greedy: boolean, cancel?: AbortSignal): Promise<void> {\n  actionsLogger.log(\"Upgrading all packages\", { greedy });\n  let cmd = `upgrade`;\n  if (greedy) {\n    cmd += \" --greedy\";\n  }\n  await execBrew(cmd, cancel ? { signal: cancel } : undefined);\n  actionsLogger.log(\"All packages upgraded successfully\");\n}\n\n/**\n * Run cleanup to remove old versions.\n */\nexport async function brewCleanup(withoutThreshold: boolean, cancel?: AbortSignal): Promise<void> {\n  actionsLogger.log(\"Running cleanup\", { pruneAll: withoutThreshold });\n  let cmd = `cleanup`;\n  if (withoutThreshold) {\n    cmd += \" --prune=all\";\n  }\n  await execBrew(cmd, cancel ? { signal: cancel } : undefined);\n  actionsLogger.log(\"Cleanup completed successfully\");\n}\n\n/**\n * Pin a formula to prevent upgrades.\n */\nexport async function brewPinFormula(formula: Formula | OutdatedFormula): Promise<void> {\n  actionsLogger.log(\"Pinning formula\", { name: formula.name });\n  await execBrew(`pin ${formula.name}`);\n  formula.pinned = true;\n  actionsLogger.log(\"Formula pinned successfully\", { name: formula.name });\n}\n\n/**\n * Unpin a formula to allow upgrades.\n */\nexport async function brewUnpinFormula(formula: Formula | OutdatedFormula): Promise<void> {\n  actionsLogger.log(\"Unpinning formula\", { name: formula.name });\n  await execBrew(`unpin ${formula.name}`);\n  formula.pinned = false;\n  actionsLogger.log(\"Formula unpinned successfully\", { name: formula.name });\n}\n\n/**\n * Run brew doctor to check for issues.\n */\nexport async function brewDoctor(): Promise<string> {\n  try {\n    const output = await execBrew(`doctor`);\n    return output.stdout;\n  } catch (err) {\n    const execErr = err as ExecError;\n    if (execErr?.code === 1) {\n      return execErr.stderr;\n    } else {\n      return `${err}`;\n    }\n  }\n}\n", "/**\n * Toast utilities for the Brew extension.\n *\n * Provides functions for displaying toast notifications.\n */\n\nimport { Clipboard, Toast, showHUD } from \"@raycast/api\";\nimport { ExecError } from \"./types\";\nimport { uiLogger } from \"./logger\";\nimport { isRecoverableError, getErrorMessage, isBrewLockError } from \"./errors\";\nimport { preferences } from \"./preferences\";\n\n/// Toast Types\n\ninterface ActionToastOptions {\n  title: string;\n  message?: string;\n  cancelable: boolean;\n}\n\n/**\n * Result from showActionToast that allows updating progress and showing final HUD.\n */\nexport interface ActionToastHandle {\n  /** AbortController for cancellation (if cancelable) */\n  abort?: AbortController;\n  /** Update the toast message to show progress */\n  updateMessage: (message: string) => void;\n  /** Update the toast title */\n  updateTitle: (title: string) => void;\n  /** Show success HUD (persists after Raycast closes) */\n  showSuccessHUD: (message: string) => Promise<void>;\n  /** Show failure HUD (persists after Raycast closes) */\n  showFailureHUD: (message: string) => Promise<void>;\n  /** Hide the toast */\n  hide: () => void;\n}\n\n/**\n * Show an animated toast with optional cancel action.\n * Returns a handle for updating progress and showing final HUD notifications.\n */\nexport function showActionToast(actionOptions: ActionToastOptions): ActionToastHandle {\n  const options: Toast.Options = {\n    style: Toast.Style.Animated,\n    title: actionOptions.title,\n    message: actionOptions.message,\n  };\n\n  let controller: AbortController | undefined;\n\n  if (actionOptions.cancelable) {\n    controller = new AbortController();\n    options.primaryAction = {\n      title: \"Cancel\",\n      onAction: () => {\n        controller?.abort();\n        toast.hide();\n      },\n    };\n  }\n\n  const toast = new Toast(options);\n  toast.show();\n\n  return {\n    abort: controller,\n    updateMessage: (message: string) => {\n      toast.message = message;\n    },\n    updateTitle: (title: string) => {\n      toast.title = title;\n    },\n    showSuccessHUD: async (message: string) => {\n      if (preferences.closeAfterAction) {\n        toast.hide();\n        // Close window and show HUD\n        await showHUD(`\u2705 ${message}`);\n      } else {\n        // Keep window open - update existing toast in-place to avoid stale detail HUD\n        toast.style = Toast.Style.Success;\n        toast.title = message;\n        toast.message = undefined;\n        toast.primaryAction = undefined;\n      }\n    },\n    showFailureHUD: async (message: string) => {\n      if (preferences.closeAfterAction) {\n        toast.hide();\n        // Close window and show HUD\n        await showHUD(`\u274C ${message}`);\n      } else {\n        // Keep window open - update existing toast in-place to avoid stale detail HUD\n        toast.style = Toast.Style.Failure;\n        toast.title = message;\n        toast.message = undefined;\n        toast.primaryAction = undefined;\n      }\n    },\n    hide: () => {\n      toast.hide();\n    },\n  };\n}\n\n/**\n * Show a Brew-specific failure toast with error details and optional retry action.\n *\n * Unlike the standard `showFailureToast` from `@raycast/utils`, this function:\n * - Detects Homebrew lock errors and shows \"Brew is Busy\" with helpful context\n * - Logs structured error details (stderr, exit code, error type) via uiLogger\n * - Provides a \"Copy Logs\" action with brew-specific troubleshooting tips\n * - Supports conditional retry for recoverable brew errors\n * - Silently ignores AbortError (user-initiated cancellations)\n *\n * Use this for all Homebrew operations. Use `showFailureToast` from `@raycast/utils`\n * for general extension errors unrelated to brew commands.\n */\nexport async function showBrewFailureToast(\n  title: string,\n  error: Error,\n  options?: { retryAction?: () => Promise<void> },\n): Promise<void> {\n  if (error.name === \"AbortError\") {\n    uiLogger.log(\"Operation aborted by user\");\n    return;\n  }\n\n  const execError = error as ExecError;\n  const errorMessage = getErrorMessage(error);\n  const isLockError = isBrewLockError(error);\n\n  uiLogger.error(title, {\n    errorType: error.name,\n    message: error.message,\n    stderr: execError.stderr,\n    code: execError.code,\n    recoverable: isRecoverableError(error),\n    isLockError,\n  });\n\n  // Use a more specific title for lock errors\n  const toastTitle = isLockError ? \"Brew is Busy\" : title;\n\n  const toastOptions: Toast.Options = {\n    style: Toast.Style.Failure,\n    title: toastTitle,\n    message: errorMessage,\n    primaryAction: {\n      title: \"Copy Logs\",\n      onAction: () => {\n        // For lock errors, include more context in the copied log\n        const logContent = isLockError\n          ? `${toastTitle}\\n${errorMessage}\\n\\nTip: Check Activity Monitor or run 'ps aux | grep brew' in Terminal to see what's running.`\n          : errorMessage;\n        Clipboard.copy(logContent);\n      },\n    },\n  };\n\n  // Add retry action for recoverable errors (including lock errors)\n  if (isRecoverableError(error) && options?.retryAction) {\n    const retryAction = options.retryAction;\n    toastOptions.secondaryAction = {\n      title: \"Retry\",\n      onAction: async (toast) => {\n        toast.style = Toast.Style.Animated;\n        toast.title = \"Retrying...\";\n        toast.message = undefined;\n        try {\n          await retryAction();\n          toast.style = Toast.Style.Success;\n          toast.title = \"Success\";\n        } catch (retryError) {\n          toast.style = Toast.Style.Failure;\n          toast.title = isBrewLockError(retryError) ? \"Brew is Busy\" : title;\n          toast.message = getErrorMessage(retryError);\n        }\n      },\n    };\n  }\n\n  const toast = new Toast(toastOptions);\n  await toast.show();\n}\n", "/**\n * Array prototype extensions for the Brew extension.\n *\n * Adds utility methods to Array prototype for convenience.\n * These are used throughout the extension for working with search results.\n */\n\n/// Array Extensions\n\ndeclare global {\n  interface Array<T> {\n    /** Total length before truncation (for paginated results) */\n    totalLength?: number;\n    /** Get the first element of the array */\n    first(): T | undefined;\n    /** Get the last element of the array */\n    last(): T | undefined;\n    /** Check if the array was truncated (totalLength > length) */\n    isTruncated(): boolean;\n  }\n}\n\nif (!Array.prototype.first) {\n  Array.prototype.first = function <T>(this: T[]): T | undefined {\n    return this.at(0);\n  };\n}\n\nif (!Array.prototype.last) {\n  Array.prototype.last = function <T>(this: T[]): T | undefined {\n    return this.at(-1);\n  };\n}\n\nif (!Array.prototype.isTruncated) {\n  Array.prototype.isTruncated = function <T>(this: T[]): boolean {\n    if (this.totalLength) {\n      return this.length < this.totalLength;\n    }\n    return false;\n  };\n}\n\n/// String Extensions\n\ndeclare global {\n  interface StringConstructor {\n    ellipsis: string;\n  }\n}\n\nif (!String.ellipsis) {\n  String.ellipsis = \"\u2026\";\n}\n\n// Export empty object to make this a module\nexport {};\n"],
  "mappings": "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",
  "names": ["exports", "redactString", "sanitizeArgs", "maskEmail", "text", "_m", "p1", "p2", "input", "s", "redactValueByKey", "key", "value", "k", "json", "prop", "val", "args", "arg", "api_1", "redaction_1", "Logger", "_Logger", "config", "error", "message", "args", "formattedMessage", "processedMessage", "processedArgs", "prefix", "childPrefix", "exports", "logger_1", "exports", "redaction_1", "require_stream_chain", "__commonJSMin", "exports", "module", "Readable", "Writable", "Duplex", "Transform", "none", "finalSymbol", "manySymbol", "final", "value", "many", "values", "isFinal", "o", "isMany", "getFinalValue", "getManyValues", "runAsyncGenerator", "gen", "stream", "data", "Chain", "wrapFunction", "fn", "chunk", "encoding", "callback", "result", "error", "wrapArray", "fns", "i", "isReadableNodeStream", "obj", "isWritableNodeStream", "isDuplexNodeStream", "_Chain", "options", "index", "s", "output", "_1", "_2", "e", "require_Utf8Stream", "__commonJSMin", "exports", "module", "Transform", "StringDecoder", "Utf8Stream", "options", "chunk", "encoding", "callback", "_", "require_Parser", "__commonJSMin", "exports", "module", "Utf8Stream", "patterns", "MAX_PATTERN_SIZE", "noSticky", "key", "src", "values", "expected", "fromHex", "codes", "Parser", "_Parser", "options", "callback", "error", "match", "value", "index", "main", "t", "require_emit", "__commonJSMin", "exports", "module", "emit", "stream", "item", "require_stream_json", "__commonJSMin", "exports", "module", "Parser", "emit", "make", "options", "require_FilterBase", "__commonJSMin", "exports", "module", "Transform", "FilterBase", "_FilterBase", "string", "separator", "stack", "path", "regExp", "array", "options", "filter", "replacement", "chunk", "_", "callback", "passValue", "last", "post", "expected", "skipValue", "require_withParser", "__commonJSMin", "exports", "module", "chain", "Parser", "withParser", "fn", "options", "require_Filter", "__commonJSMin", "exports", "module", "FilterBase", "withParser", "Filter", "_Filter", "options", "callback", "chunk", "stack", "last", "stackLength", "lastLength", "commonLength", "n", "i", "key", "require_Assembler", "__commonJSMin", "exports", "module", "EventEmitter", "startObject", "Ctr", "Assembler", "_Assembler", "stream", "options", "chunk", "path", "i", "key", "level", "index", "value", "require_StreamBase", "__commonJSMin", "exports", "module", "Transform", "Assembler", "Counter", "initialDepth", "StreamBase", "options", "chunk", "encoding", "callback", "result", "require_StreamArray", "__commonJSMin", "exports", "module", "StreamBase", "withParser", "StreamArray", "_StreamArray", "options", "chunk", "_", "callback", "discard", "require_Pick", "__commonJSMin", "exports", "module", "FilterBase", "withParser", "Pick", "_Pick", "options", "chunk", "require_StreamObject", "__commonJSMin", "exports", "module", "StreamBase", "withParser", "StreamObject", "_StreamObject", "options", "chunk", "_", "callback", "discard", "clean_up_exports", "__export", "clean_up_default", "__toCommonJS", "import_api", "import_child_process", "import_path", "import_os", "import_api", "preferences", "brewPrefix", "preferences", "path_join", "brewPath", "suffix", "brewExecutable", "import_child_process", "import_util", "import_fs", "fs", "import_path", "import_api", "import_raycast_logger", "logger", "brewLogger", "cacheLogger", "actionsLogger", "fetchLogger", "searchLogger", "uiLogger", "BrewError", "message", "options", "NetworkError", "BrewCommandError", "BrewError", "message", "options", "BrewNotFoundError", "BrewLockError", "BrewError", "message", "options", "DownloadTimeoutError", "StaleProcessError", "PackageNotFoundError", "PackageDisabledError", "PackageConflictError", "UnsupportedMacOSError", "isNetworkError", "error", "NetworkError", "isBrewLockError", "BrewLockError", "isDownloadTimeoutError", "DownloadTimeoutError", "isStaleProcessError", "StaleProcessError", "isRecoverableError", "error", "isNetworkError", "isBrewLockError", "isDownloadTimeoutError", "isStaleProcessError", "BREW_LOCK_PATTERNS", "DISABLED_PACKAGE_PATTERN", "isBrewLockMessage", "message", "BREW_LOCK_PATTERNS", "pattern", "parseDisabledPackageMessage", "message", "match", "DISABLED_PACKAGE_PATTERN", "ensureError", "err", "getErrorMessage", "error", "BrewLockError", "DownloadTimeoutError", "pkg", "phase", "StaleProcessError", "PackageDisabledError", "type", "message", "PackageConflictError", "conflicts", "UnsupportedMacOSError", "NetworkError", "BrewNotFoundError", "PackageNotFoundError", "BrewCommandError", "disabledInfo", "parseDisabledPackageMessage", "BrewError", "execError", "import_api", "import_path", "import_fs", "import_stream_chain", "import_stream_json", "import_Filter", "import_StreamArray", "import_node_timers", "wait", "ms", "resolve", "supportPath", "fs", "cacheLogger", "bundleIdentifier", "path", "comp", "cachePath", "name", "execp", "homebrewEnvLogged", "execBrew", "cmd", "options", "env", "execBrewEnv", "brewExecutable", "err", "execErr", "errorOutput", "isBrewLockMessage", "brewLogger", "BrewLockError", "preferences", "askpassPath", "path_join", "fs_constants", "bundleIdentifier", "downloadConcurrencyDisabled", "useInternalApi", "DEFAULT_STALE_TIMEOUT_MS", "DOWNLOAD_PHASE_TIMEOUT_MS", "import_stream_chain", "import_stream_json", "import_Pick", "import_StreamObject", "import_raycast_logger", "memoryLogger", "installedCachePath", "cachePath", "formulaCachePath", "caskCachePath", "brewCleanup", "withoutThreshold", "cancel", "actionsLogger", "cmd", "execBrew", "import_api", "showActionToast", "actionOptions", "options", "controller", "toast", "message", "title", "preferences", "showBrewFailureToast", "error", "uiLogger", "execError", "errorMessage", "getErrorMessage", "isLockError", "isBrewLockError", "isRecoverableError", "toastTitle", "toastOptions", "logContent", "retryAction", "retryError", "clean_up_default", "handle", "showActionToast", "brewCleanup", "preferences", "err", "showBrewFailureToast", "ensureError", "wait"]
}
