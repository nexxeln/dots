{
  "version": 3,
  "sources": ["../node_modules/@chrismessina/raycast-logger/src/redaction.ts", "../node_modules/@chrismessina/raycast-logger/src/logger.ts", "../node_modules/@chrismessina/raycast-logger/src/index.ts", "../node_modules/stream-chain/index.js", "../node_modules/stream-json/utils/Utf8Stream.js", "../node_modules/stream-json/Parser.js", "../node_modules/stream-json/utils/emit.js", "../node_modules/stream-json/index.js", "../node_modules/stream-json/filters/FilterBase.js", "../node_modules/stream-json/utils/withParser.js", "../node_modules/stream-json/filters/Filter.js", "../node_modules/stream-json/Assembler.js", "../node_modules/stream-json/streamers/StreamBase.js", "../node_modules/stream-json/streamers/StreamArray.js", "../node_modules/stream-json/filters/Pick.js", "../node_modules/stream-json/streamers/StreamObject.js", "../src/search.tsx", "../node_modules/dequal/lite/index.mjs", "../node_modules/@raycast/utils/dist/src/index.ts", "../node_modules/@raycast/utils/dist/src/usePromise.ts", "../node_modules/@raycast/utils/dist/src/useDeepMemo.ts", "../node_modules/@raycast/utils/dist/src/useLatest.ts", "../node_modules/@raycast/utils/dist/src/showFailureToast.ts", "../node_modules/@raycast/utils/dist/src/useCachedState.ts", "../node_modules/@raycast/utils/dist/src/helpers.ts", "../node_modules/@raycast/utils/dist/src/vendors/type-hasher.ts", "../node_modules/@raycast/utils/dist/src/useCachedPromise.ts", "../node_modules/@raycast/utils/dist/src/useFetch.ts", "../node_modules/@raycast/utils/dist/src/fetch-utils.ts", "../node_modules/@raycast/utils/dist/src/useExec.ts", "../node_modules/@raycast/utils/dist/src/exec-utils.ts", "../node_modules/@raycast/utils/dist/src/vendors/signal-exit.ts", "../node_modules/@raycast/utils/dist/src/useStreamJSON.ts", "../node_modules/@raycast/utils/dist/src/vendors/stream-chain.ts", "../node_modules/@raycast/utils/dist/src/vendors/stream-json.ts", "../node_modules/@raycast/utils/dist/src/useSQL.tsx", "../node_modules/@raycast/utils/dist/src/sql-utils.ts", "../node_modules/@raycast/utils/dist/src/useForm.tsx", "../node_modules/@raycast/utils/dist/src/useAI.ts", "../node_modules/@raycast/utils/dist/src/useFrecencySorting.ts", "../node_modules/@raycast/utils/dist/src/useLocalStorage.ts", "../node_modules/@raycast/utils/dist/src/icon/index.ts", "../node_modules/@raycast/utils/dist/src/icon/avatar.ts", "../node_modules/@raycast/utils/dist/src/icon/color.ts", "../node_modules/@raycast/utils/dist/src/icon/favicon.ts", "../node_modules/@raycast/utils/dist/src/icon/progress.ts", "../node_modules/@raycast/utils/dist/src/oauth/index.ts", "../node_modules/@raycast/utils/dist/src/oauth/OAuthService.ts", "../node_modules/@raycast/utils/dist/src/oauth/providers.ts", "../node_modules/@raycast/utils/dist/src/oauth/withAccessToken.tsx", "../node_modules/@raycast/utils/dist/src/createDeeplink.ts", "../node_modules/@raycast/utils/dist/src/executeSQL.ts", "../node_modules/@raycast/utils/dist/src/run-applescript.ts", "../node_modules/@raycast/utils/dist/src/run-powershell-script.ts", "../node_modules/@raycast/utils/dist/src/cache.ts", "../src/hooks/useBrewInstalled.ts", "../src/utils/preferences.ts", "../src/utils/logger.ts", "../src/utils/errors.ts", "../src/utils/cache.ts", "../src/utils/async.ts", "../src/utils/toast.ts", "../src/utils/array.ts", "../src/utils/memory.ts", "../src/utils/brew/paths.ts", "../src/utils/brew/commands.ts", "../src/utils/brew/progress.ts", "../src/utils/brew/fetch.ts", "../src/utils/brew/internal-api.ts", "../src/utils/brew/helpers.ts", "../src/utils/brew/search.ts", "../src/utils/brew/actions.ts", "../src/hooks/useBrewSearch.ts", "../src/components/filter.tsx", "../src/components/list.tsx", "../src/components/actionPanels.tsx", "../src/components/formulaInfo.tsx", "../src/components/dependencies.tsx", "../src/components/caskInfo.tsx", "../src/components/actions.tsx", "../src/components/runInTerminal.ts"],
  "sourcesContent": [null, null, null, "'use strict';\n\nconst {Readable, Writable, Duplex, Transform} = require('stream');\n\nconst none = Symbol.for('object-stream.none');\nconst finalSymbol = Symbol.for('object-stream.final');\nconst manySymbol = Symbol.for('object-stream.many');\n\nconst final = value => ({[finalSymbol]: value});\nconst many = values => ({[manySymbol]: values});\n\nconst isFinal = o => o && typeof o == 'object' && finalSymbol in o;\nconst isMany = o => o && typeof o == 'object' && manySymbol in o;\n\nconst getFinalValue = o => o[finalSymbol];\nconst getManyValues = o => o[manySymbol];\n\nconst runAsyncGenerator = async (gen, stream) => {\n  for (;;) {\n    let data = gen.next();\n    if (data && typeof data.then == 'function') {\n      data = await data;\n    }\n    if (data.done) break;\n    let value = data.value;\n    if (value && typeof value.then == 'function') {\n      value = await value;\n    }\n    Chain.sanitize(value, stream);\n  }\n};\n\nconst wrapFunction = fn =>\n  new Transform({\n    writableObjectMode: true,\n    readableObjectMode: true,\n    transform(chunk, encoding, callback) {\n      try {\n        const result = fn.call(this, chunk, encoding);\n        if (result && typeof result.then == 'function') {\n          // thenable\n          result.then(\n            result => (Chain.sanitize(result, this), callback(null)),\n            error => callback(error)\n          );\n          return;\n        }\n        if (result && typeof result.next == 'function') {\n          // generator\n          runAsyncGenerator(result, this).then(\n            () => callback(null),\n            error => callback(error)\n          );\n          return;\n        }\n        Chain.sanitize(result, this);\n        callback(null);\n      } catch (error) {\n        callback(error);\n      }\n    }\n  });\n\nconst wrapArray = fns =>\n  new Transform({\n    writableObjectMode: true,\n    readableObjectMode: true,\n    transform(chunk, encoding, callback) {\n      try {\n        let value = chunk;\n        for (let i = 0; i < fns.length; ++i) {\n          const result = fns[i].call(this, value, encoding);\n          if (result === Chain.none) {\n            callback(null);\n            return;\n          }\n          if (Chain.isFinal(result)) {\n            value = Chain.getFinalValue(result);\n            break;\n          }\n          value = result;\n        }\n        Chain.sanitize(value, this);\n        callback(null);\n      } catch (error) {\n        callback(error);\n      }\n    }\n  });\n\n// is*NodeStream functions taken from https://github.com/nodejs/node/blob/master/lib/internal/streams/utils.js\nconst isReadableNodeStream = obj =>\n  obj &&\n  typeof obj.pipe === 'function' &&\n  typeof obj.on === 'function' &&\n  (!obj._writableState || (typeof obj._readableState === 'object' ? obj._readableState.readable : null) !== false) && // Duplex\n  (!obj._writableState || obj._readableState); // Writable has .pipe.\n\nconst isWritableNodeStream = obj =>\n  obj &&\n  typeof obj.write === 'function' &&\n  typeof obj.on === 'function' &&\n  (!obj._readableState || (typeof obj._writableState === 'object' ? obj._writableState.writable : null) !== false); // Duplex\n\nconst isDuplexNodeStream = obj =>\n  obj && typeof obj.pipe === 'function' && obj._readableState && typeof obj.on === 'function' && typeof obj.write === 'function';\n\nclass Chain extends Duplex {\n  constructor(fns, options) {\n    super(options || {writableObjectMode: true, readableObjectMode: true});\n\n    if (!(fns instanceof Array) || !fns.length) {\n      throw Error(\"Chain's argument should be a non-empty array.\");\n    }\n\n    this.streams = fns\n      .filter(fn => fn)\n      .map((fn, index, fns) => {\n        if (typeof fn === 'function' || fn instanceof Array) return Chain.convertToTransform(fn);\n        if (isDuplexNodeStream(fn) || (!index && isReadableNodeStream(fn)) || (index === fns.length - 1 && isWritableNodeStream(fn))) {\n          return fn;\n        }\n        throw Error('Arguments should be functions, arrays or streams.');\n      })\n      .filter(s => s);\n    this.input = this.streams[0];\n    this.output = this.streams.reduce((output, stream) => (output && output.pipe(stream)) || stream);\n\n    if (!isWritableNodeStream(this.input)) {\n      this._write = (_1, _2, callback) => callback(null);\n      this._final = callback => callback(null); // unavailable in Node 6\n      this.input.on('end', () => this.end());\n    }\n\n    if (isReadableNodeStream(this.output)) {\n      this.output.on('data', chunk => !this.push(chunk) && this.output.pause());\n      this.output.on('end', () => this.push(null));\n    } else {\n      this._read = () => {}; // nop\n      this.resume();\n      this.output.on('finish', () => this.push(null));\n    }\n\n    // connect events\n    if (!options || !options.skipEvents) {\n      this.streams.forEach(stream => stream.on('error', error => this.emit('error', error)));\n    }\n  }\n  _write(chunk, encoding, callback) {\n    let error = null;\n    try {\n      this.input.write(chunk, encoding, e => callback(e || error));\n    } catch (e) {\n      error = e;\n    }\n  }\n  _final(callback) {\n    let error = null;\n    try {\n      this.input.end(null, null, e => callback(e || error));\n    } catch (e) {\n      error = e;\n    }\n  }\n  _read() {\n    this.output.resume();\n  }\n  static make(fns, options) {\n    return new Chain(fns, options);\n  }\n  static sanitize(result, stream) {\n    if (Chain.isFinal(result)) {\n      result = Chain.getFinalValue(result);\n    } else if (Chain.isMany(result)) {\n      result = Chain.getManyValues(result);\n    }\n    if (result !== undefined && result !== null && result !== Chain.none) {\n      if (result instanceof Array) {\n        result.forEach(value => value !== undefined && value !== null && stream.push(value));\n      } else {\n        stream.push(result);\n      }\n    }\n  }\n  static convertToTransform(fn) {\n    if (typeof fn === 'function') return wrapFunction(fn);\n    if (fn instanceof Array) return fn.length ? wrapArray(fn) : null;\n    return null;\n  }\n}\n\nChain.none = none;\nChain.final = final;\nChain.isFinal = isFinal;\nChain.getFinalValue = getFinalValue;\nChain.many = many;\nChain.isMany = isMany;\nChain.getManyValues = getManyValues;\n\nChain.chain = Chain.make;\nChain.make.Constructor = Chain;\n\nmodule.exports = Chain;\n", "'use strict';\n\nconst {Transform} = require('stream');\nconst {StringDecoder} = require('string_decoder');\n\nclass Utf8Stream extends Transform {\n  constructor(options) {\n    super(Object.assign({}, options, {writableObjectMode: false}));\n    this._buffer = '';\n  }\n\n  _transform(chunk, encoding, callback) {\n    if (typeof chunk == 'string') {\n      this._transform = this._transformString;\n    } else {\n      this._stringDecoder = new StringDecoder();\n      this._transform = this._transformBuffer;\n    }\n    this._transform(chunk, encoding, callback);\n  }\n\n  _transformBuffer(chunk, _, callback) {\n    this._buffer += this._stringDecoder.write(chunk);\n    this._processBuffer(callback);\n  }\n\n  _transformString(chunk, _, callback) {\n    this._buffer += chunk.toString();\n    this._processBuffer(callback);\n  }\n\n  _processBuffer(callback) {\n    if (this._buffer) {\n      this.push(this._buffer, 'utf8');\n      this._buffer = '';\n    }\n    callback(null);\n  }\n\n  _flushInput() {\n    // meant to be called from _flush()\n    if (this._stringDecoder) {\n      this._buffer += this._stringDecoder.end();\n    }\n  }\n\n  _flush(callback) {\n    this._flushInput();\n    this._processBuffer(callback);\n  }\n}\n\nmodule.exports = Utf8Stream;\n", "'use strict';\n\nconst Utf8Stream = require('./utils/Utf8Stream');\n\nconst patterns = {\n  value1: /^(?:[\\\"\\{\\[\\]\\-\\d]|true\\b|false\\b|null\\b|\\s{1,256})/,\n  string: /^(?:[^\\x00-\\x1f\\\"\\\\]{1,256}|\\\\[bfnrt\\\"\\\\\\/]|\\\\u[\\da-fA-F]{4}|\\\")/,\n  key1: /^(?:[\\\"\\}]|\\s{1,256})/,\n  colon: /^(?:\\:|\\s{1,256})/,\n  comma: /^(?:[\\,\\]\\}]|\\s{1,256})/,\n  ws: /^\\s{1,256}/,\n  numberStart: /^\\d/,\n  numberDigit: /^\\d{0,256}/,\n  numberFraction: /^[\\.eE]/,\n  numberExponent: /^[eE]/,\n  numberExpSign: /^[-+]/\n};\nconst MAX_PATTERN_SIZE = 16;\n\nlet noSticky = true;\ntry {\n  new RegExp('.', 'y');\n  noSticky = false;\n} catch (e) {\n  // suppress\n}\n\n!noSticky &&\n  Object.keys(patterns).forEach(key => {\n    let src = patterns[key].source.slice(1); // lop off ^\n    if (src.slice(0, 3) === '(?:' && src.slice(-1) === ')') {\n      src = src.slice(3, -1);\n    }\n    patterns[key] = new RegExp(src, 'y');\n  });\n\npatterns.numberFracStart = patterns.numberExpStart = patterns.numberStart;\npatterns.numberFracDigit = patterns.numberExpDigit = patterns.numberDigit;\n\nconst values = {true: true, false: false, null: null},\n  expected = {object: 'objectStop', array: 'arrayStop', '': 'done'};\n\n// long hexadecimal codes: \\uXXXX\nconst fromHex = s => String.fromCharCode(parseInt(s.slice(2), 16));\n\n// short codes: \\b \\f \\n \\r \\t \\\" \\\\ \\/\nconst codes = {b: '\\b', f: '\\f', n: '\\n', r: '\\r', t: '\\t', '\"': '\"', '\\\\': '\\\\', '/': '/'};\n\nclass Parser extends Utf8Stream {\n  static make(options) {\n    return new Parser(options);\n  }\n\n  constructor(options) {\n    super(Object.assign({}, options, {readableObjectMode: true}));\n\n    this._packKeys = this._packStrings = this._packNumbers = this._streamKeys = this._streamStrings = this._streamNumbers = true;\n    if (options) {\n      'packValues' in options && (this._packKeys = this._packStrings = this._packNumbers = options.packValues);\n      'packKeys' in options && (this._packKeys = options.packKeys);\n      'packStrings' in options && (this._packStrings = options.packStrings);\n      'packNumbers' in options && (this._packNumbers = options.packNumbers);\n      'streamValues' in options && (this._streamKeys = this._streamStrings = this._streamNumbers = options.streamValues);\n      'streamKeys' in options && (this._streamKeys = options.streamKeys);\n      'streamStrings' in options && (this._streamStrings = options.streamStrings);\n      'streamNumbers' in options && (this._streamNumbers = options.streamNumbers);\n      this._jsonStreaming = options.jsonStreaming;\n    }\n    !this._packKeys && (this._streamKeys = true);\n    !this._packStrings && (this._streamStrings = true);\n    !this._packNumbers && (this._streamNumbers = true);\n\n    this._done = false;\n    this._expect = this._jsonStreaming ? 'done' : 'value';\n    this._stack = [];\n    this._parent = '';\n    this._open_number = false;\n    this._accumulator = '';\n  }\n\n  _flush(callback) {\n    this._done = true;\n    super._flush(error => {\n      if (error) return callback(error);\n      if (this._open_number) {\n        if (this._streamNumbers) {\n          this.push({name: 'endNumber'});\n        }\n        this._open_number = false;\n        if (this._packNumbers) {\n          this.push({name: 'numberValue', value: this._accumulator});\n          this._accumulator = '';\n        }\n      }\n      callback(null);\n    });\n  }\n\n  _processBuffer(callback) {\n    let match,\n      value,\n      index = 0;\n    main: for (;;) {\n      switch (this._expect) {\n        case 'value1':\n        case 'value':\n          patterns.value1.lastIndex = index;\n          match = patterns.value1.exec(this._buffer);\n          if (!match) {\n            if (this._done || index + MAX_PATTERN_SIZE < this._buffer.length) {\n              if (index < this._buffer.length) return callback(new Error('Parser cannot parse input: expected a value'));\n              return callback(new Error('Parser has expected a value'));\n            }\n            break main; // wait for more input\n          }\n          value = match[0];\n          switch (value) {\n            case '\"':\n              this._streamStrings && this.push({name: 'startString'});\n              this._expect = 'string';\n              break;\n            case '{':\n              this.push({name: 'startObject'});\n              this._stack.push(this._parent);\n              this._parent = 'object';\n              this._expect = 'key1';\n              break;\n            case '[':\n              this.push({name: 'startArray'});\n              this._stack.push(this._parent);\n              this._parent = 'array';\n              this._expect = 'value1';\n              break;\n            case ']':\n              if (this._expect !== 'value1') return callback(new Error(\"Parser cannot parse input: unexpected token ']'\"));\n              if (this._open_number) {\n                this._streamNumbers && this.push({name: 'endNumber'});\n                this._open_number = false;\n                if (this._packNumbers) {\n                  this.push({name: 'numberValue', value: this._accumulator});\n                  this._accumulator = '';\n                }\n              }\n              this.push({name: 'endArray'});\n              this._parent = this._stack.pop();\n              this._expect = expected[this._parent];\n              break;\n            case '-':\n              this._open_number = true;\n              if (this._streamNumbers) {\n                this.push({name: 'startNumber'});\n                this.push({name: 'numberChunk', value: '-'});\n              }\n              this._packNumbers && (this._accumulator = '-');\n              this._expect = 'numberStart';\n              break;\n            case '0':\n              this._open_number = true;\n              if (this._streamNumbers) {\n                this.push({name: 'startNumber'});\n                this.push({name: 'numberChunk', value: '0'});\n              }\n              this._packNumbers && (this._accumulator = '0');\n              this._expect = 'numberFraction';\n              break;\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n              this._open_number = true;\n              if (this._streamNumbers) {\n                this.push({name: 'startNumber'});\n                this.push({name: 'numberChunk', value: value});\n              }\n              this._packNumbers && (this._accumulator = value);\n              this._expect = 'numberDigit';\n              break;\n            case 'true':\n            case 'false':\n            case 'null':\n              if (this._buffer.length - index === value.length && !this._done) break main; // wait for more input\n              this.push({name: value + 'Value', value: values[value]});\n              this._expect = expected[this._parent];\n              break;\n            // default: // ws\n          }\n          if (noSticky) {\n            this._buffer = this._buffer.slice(value.length);\n          } else {\n            index += value.length;\n          }\n          break;\n        case 'keyVal':\n        case 'string':\n          patterns.string.lastIndex = index;\n          match = patterns.string.exec(this._buffer);\n          if (!match) {\n            if (index < this._buffer.length && (this._done || this._buffer.length - index >= 6))\n              return callback(new Error('Parser cannot parse input: escaped characters'));\n            if (this._done) return callback(new Error('Parser has expected a string value'));\n            break main; // wait for more input\n          }\n          value = match[0];\n          if (value === '\"') {\n            if (this._expect === 'keyVal') {\n              this._streamKeys && this.push({name: 'endKey'});\n              if (this._packKeys) {\n                this.push({name: 'keyValue', value: this._accumulator});\n                this._accumulator = '';\n              }\n              this._expect = 'colon';\n            } else {\n              this._streamStrings && this.push({name: 'endString'});\n              if (this._packStrings) {\n                this.push({name: 'stringValue', value: this._accumulator});\n                this._accumulator = '';\n              }\n              this._expect = expected[this._parent];\n            }\n          } else if (value.length > 1 && value.charAt(0) === '\\\\') {\n            const t = value.length == 2 ? codes[value.charAt(1)] : fromHex(value);\n            if (this._expect === 'keyVal' ? this._streamKeys : this._streamStrings) {\n              this.push({name: 'stringChunk', value: t});\n            }\n            if (this._expect === 'keyVal' ? this._packKeys : this._packStrings) {\n              this._accumulator += t;\n            }\n          } else {\n            if (this._expect === 'keyVal' ? this._streamKeys : this._streamStrings) {\n              this.push({name: 'stringChunk', value: value});\n            }\n            if (this._expect === 'keyVal' ? this._packKeys : this._packStrings) {\n              this._accumulator += value;\n            }\n          }\n          if (noSticky) {\n            this._buffer = this._buffer.slice(value.length);\n          } else {\n            index += value.length;\n          }\n          break;\n        case 'key1':\n        case 'key':\n          patterns.key1.lastIndex = index;\n          match = patterns.key1.exec(this._buffer);\n          if (!match) {\n            if (index < this._buffer.length || this._done) return callback(new Error('Parser cannot parse input: expected an object key'));\n            break main; // wait for more input\n          }\n          value = match[0];\n          if (value === '\"') {\n            this._streamKeys && this.push({name: 'startKey'});\n            this._expect = 'keyVal';\n          } else if (value === '}') {\n            if (this._expect !== 'key1') return callback(new Error(\"Parser cannot parse input: unexpected token '}'\"));\n            this.push({name: 'endObject'});\n            this._parent = this._stack.pop();\n            this._expect = expected[this._parent];\n          }\n          if (noSticky) {\n            this._buffer = this._buffer.slice(value.length);\n          } else {\n            index += value.length;\n          }\n          break;\n        case 'colon':\n          patterns.colon.lastIndex = index;\n          match = patterns.colon.exec(this._buffer);\n          if (!match) {\n            if (index < this._buffer.length || this._done) return callback(new Error(\"Parser cannot parse input: expected ':'\"));\n            break main; // wait for more input\n          }\n          value = match[0];\n          value === ':' && (this._expect = 'value');\n          if (noSticky) {\n            this._buffer = this._buffer.slice(value.length);\n          } else {\n            index += value.length;\n          }\n          break;\n        case 'arrayStop':\n        case 'objectStop':\n          patterns.comma.lastIndex = index;\n          match = patterns.comma.exec(this._buffer);\n          if (!match) {\n            if (index < this._buffer.length || this._done) return callback(new Error(\"Parser cannot parse input: expected ','\"));\n            break main; // wait for more input\n          }\n          if (this._open_number) {\n            this._streamNumbers && this.push({name: 'endNumber'});\n            this._open_number = false;\n            if (this._packNumbers) {\n              this.push({name: 'numberValue', value: this._accumulator});\n              this._accumulator = '';\n            }\n          }\n          value = match[0];\n          if (value === ',') {\n            this._expect = this._expect === 'arrayStop' ? 'value' : 'key';\n          } else if (value === '}' || value === ']') {\n            if (value === '}' ? this._expect === 'arrayStop' : this._expect !== 'arrayStop') {\n              return callback(new Error(\"Parser cannot parse input: expected '\" + (this._expect === 'arrayStop' ? ']' : '}') + \"'\"));\n            }\n            this.push({name: value === '}' ? 'endObject' : 'endArray'});\n            this._parent = this._stack.pop();\n            this._expect = expected[this._parent];\n          }\n          if (noSticky) {\n            this._buffer = this._buffer.slice(value.length);\n          } else {\n            index += value.length;\n          }\n          break;\n        // number chunks\n        case 'numberStart': // [0-9]\n          patterns.numberStart.lastIndex = index;\n          match = patterns.numberStart.exec(this._buffer);\n          if (!match) {\n            if (index < this._buffer.length || this._done) return callback(new Error('Parser cannot parse input: expected a starting digit'));\n            break main; // wait for more input\n          }\n          value = match[0];\n          this._streamNumbers && this.push({name: 'numberChunk', value: value});\n          this._packNumbers && (this._accumulator += value);\n          this._expect = value === '0' ? 'numberFraction' : 'numberDigit';\n          if (noSticky) {\n            this._buffer = this._buffer.slice(value.length);\n          } else {\n            index += value.length;\n          }\n          break;\n        case 'numberDigit': // [0-9]*\n          patterns.numberDigit.lastIndex = index;\n          match = patterns.numberDigit.exec(this._buffer);\n          if (!match) {\n            if (index < this._buffer.length || this._done) return callback(new Error('Parser cannot parse input: expected a digit'));\n            break main; // wait for more input\n          }\n          value = match[0];\n          if (value) {\n            this._streamNumbers && this.push({name: 'numberChunk', value: value});\n            this._packNumbers && (this._accumulator += value);\n            if (noSticky) {\n              this._buffer = this._buffer.slice(value.length);\n            } else {\n              index += value.length;\n            }\n          } else {\n            if (index < this._buffer.length) {\n              this._expect = 'numberFraction';\n              break;\n            }\n            if (this._done) {\n              this._expect = expected[this._parent];\n              break;\n            }\n            break main; // wait for more input\n          }\n          break;\n        case 'numberFraction': // [\\.eE]?\n          patterns.numberFraction.lastIndex = index;\n          match = patterns.numberFraction.exec(this._buffer);\n          if (!match) {\n            if (index < this._buffer.length || this._done) {\n              this._expect = expected[this._parent];\n              break;\n            }\n            break main; // wait for more input\n          }\n          value = match[0];\n          this._streamNumbers && this.push({name: 'numberChunk', value: value});\n          this._packNumbers && (this._accumulator += value);\n          this._expect = value === '.' ? 'numberFracStart' : 'numberExpSign';\n          if (noSticky) {\n            this._buffer = this._buffer.slice(value.length);\n          } else {\n            index += value.length;\n          }\n          break;\n        case 'numberFracStart': // [0-9]\n          patterns.numberFracStart.lastIndex = index;\n          match = patterns.numberFracStart.exec(this._buffer);\n          if (!match) {\n            if (index < this._buffer.length || this._done) return callback(new Error('Parser cannot parse input: expected a fractional part of a number'));\n            break main; // wait for more input\n          }\n          value = match[0];\n          this._streamNumbers && this.push({name: 'numberChunk', value: value});\n          this._packNumbers && (this._accumulator += value);\n          this._expect = 'numberFracDigit';\n          if (noSticky) {\n            this._buffer = this._buffer.slice(value.length);\n          } else {\n            index += value.length;\n          }\n          break;\n        case 'numberFracDigit': // [0-9]*\n          patterns.numberFracDigit.lastIndex = index;\n          match = patterns.numberFracDigit.exec(this._buffer);\n          value = match[0];\n          if (value) {\n            this._streamNumbers && this.push({name: 'numberChunk', value: value});\n            this._packNumbers && (this._accumulator += value);\n            if (noSticky) {\n              this._buffer = this._buffer.slice(value.length);\n            } else {\n              index += value.length;\n            }\n          } else {\n            if (index < this._buffer.length) {\n              this._expect = 'numberExponent';\n              break;\n            }\n            if (this._done) {\n              this._expect = expected[this._parent];\n              break;\n            }\n            break main; // wait for more input\n          }\n          break;\n        case 'numberExponent': // [eE]?\n          patterns.numberExponent.lastIndex = index;\n          match = patterns.numberExponent.exec(this._buffer);\n          if (!match) {\n            if (index < this._buffer.length) {\n              this._expect = expected[this._parent];\n              break;\n            }\n            if (this._done) {\n              this._expect = 'done';\n              break;\n            }\n            break main; // wait for more input\n          }\n          value = match[0];\n          this._streamNumbers && this.push({name: 'numberChunk', value: value});\n          this._packNumbers && (this._accumulator += value);\n          this._expect = 'numberExpSign';\n          if (noSticky) {\n            this._buffer = this._buffer.slice(value.length);\n          } else {\n            index += value.length;\n          }\n          break;\n        case 'numberExpSign': // [-+]?\n          patterns.numberExpSign.lastIndex = index;\n          match = patterns.numberExpSign.exec(this._buffer);\n          if (!match) {\n            if (index < this._buffer.length) {\n              this._expect = 'numberExpStart';\n              break;\n            }\n            if (this._done) return callback(new Error('Parser has expected an exponent value of a number'));\n            break main; // wait for more input\n          }\n          value = match[0];\n          this._streamNumbers && this.push({name: 'numberChunk', value: value});\n          this._packNumbers && (this._accumulator += value);\n          this._expect = 'numberExpStart';\n          if (noSticky) {\n            this._buffer = this._buffer.slice(value.length);\n          } else {\n            index += value.length;\n          }\n          break;\n        case 'numberExpStart': // [0-9]\n          patterns.numberExpStart.lastIndex = index;\n          match = patterns.numberExpStart.exec(this._buffer);\n          if (!match) {\n            if (index < this._buffer.length || this._done) return callback(new Error('Parser cannot parse input: expected an exponent part of a number'));\n            break main; // wait for more input\n          }\n          value = match[0];\n          this._streamNumbers && this.push({name: 'numberChunk', value: value});\n          this._packNumbers && (this._accumulator += value);\n          this._expect = 'numberExpDigit';\n          if (noSticky) {\n            this._buffer = this._buffer.slice(value.length);\n          } else {\n            index += value.length;\n          }\n          break;\n        case 'numberExpDigit': // [0-9]*\n          patterns.numberExpDigit.lastIndex = index;\n          match = patterns.numberExpDigit.exec(this._buffer);\n          value = match[0];\n          if (value) {\n            this._streamNumbers && this.push({name: 'numberChunk', value: value});\n            this._packNumbers && (this._accumulator += value);\n            if (noSticky) {\n              this._buffer = this._buffer.slice(value.length);\n            } else {\n              index += value.length;\n            }\n          } else {\n            if (index < this._buffer.length || this._done) {\n              this._expect = expected[this._parent];\n              break;\n            }\n            break main; // wait for more input\n          }\n          break;\n        case 'done':\n          patterns.ws.lastIndex = index;\n          match = patterns.ws.exec(this._buffer);\n          if (!match) {\n            if (index < this._buffer.length) {\n              if (this._jsonStreaming) {\n                this._expect = 'value';\n                break;\n              }\n              return callback(new Error('Parser cannot parse input: unexpected characters'));\n            }\n            break main; // wait for more input\n          }\n          value = match[0];\n          if (this._open_number) {\n            this._streamNumbers && this.push({name: 'endNumber'});\n            this._open_number = false;\n            if (this._packNumbers) {\n              this.push({name: 'numberValue', value: this._accumulator});\n              this._accumulator = '';\n            }\n          }\n          if (noSticky) {\n            this._buffer = this._buffer.slice(value.length);\n          } else {\n            index += value.length;\n          }\n          break;\n      }\n    }\n    !noSticky && (this._buffer = this._buffer.slice(index));\n    callback(null);\n  }\n}\nParser.parser = Parser.make;\nParser.make.Constructor = Parser;\n\nmodule.exports = Parser;\n", "'use strict';\n\nconst emit = stream => stream.on('data', item => stream.emit(item.name, item.value));\n\nmodule.exports = emit;\n", "'use strict';\n\nconst Parser = require('./Parser');\nconst emit = require('./utils/emit');\n\nconst make = options => emit(new Parser(options));\n\nmake.Parser = Parser;\nmake.parser = Parser.parser;\n\nmodule.exports = make;\n", "'use strict';\n\nconst {Transform} = require('stream');\n\nclass FilterBase extends Transform {\n  static stringFilter(string, separator) {\n    return stack => {\n      const path = stack.join(separator);\n      return (\n        (path.length === string.length && path === string) ||\n        (path.length > string.length && path.substr(0, string.length) === string && path.substr(string.length, separator.length) === separator)\n      );\n    };\n  }\n\n  static regExpFilter(regExp, separator) {\n    return stack => regExp.test(stack.join(separator));\n  }\n\n  static arrayReplacement(array) {\n    return () => array;\n  }\n\n  constructor(options) {\n    super(Object.assign({}, options, {writableObjectMode: true, readableObjectMode: true}));\n    this._transform = this._check;\n    this._stack = [];\n\n    const filter = options && options.filter,\n      separator = (options && options.pathSeparator) || '.';\n    if (typeof filter == 'string') {\n      this._filter = FilterBase.stringFilter(filter, separator);\n    } else if (typeof filter == 'function') {\n      this._filter = filter;\n    } else if (filter instanceof RegExp) {\n      this._filter = FilterBase.regExpFilter(filter, separator);\n    }\n\n    const replacement = options && options.replacement;\n    if (typeof replacement == 'function') {\n      this._replacement = replacement;\n    } else {\n      this._replacement = FilterBase.arrayReplacement(replacement || FilterBase.defaultReplacement);\n    }\n    this._allowEmptyReplacement = options && options.allowEmptyReplacement;\n\n    this._streamKeys = true;\n    if (options) {\n      'streamValues' in options && (this._streamKeys = options.streamValues);\n      'streamKeys' in options && (this._streamKeys = options.streamKeys);\n    }\n\n    this._once = options && options.once;\n    this._previousToken = '';\n  }\n\n  _check(chunk, _, callback) {\n    // update the last stack key\n    switch (chunk.name) {\n      case 'startObject':\n      case 'startArray':\n      case 'startString':\n      case 'startNumber':\n      case 'nullValue':\n      case 'trueValue':\n      case 'falseValue':\n        if (typeof this._stack[this._stack.length - 1] == 'number') {\n          // array\n          ++this._stack[this._stack.length - 1];\n        }\n        break;\n      case 'keyValue':\n        this._stack[this._stack.length - 1] = chunk.value;\n        break;\n      case 'numberValue':\n        if (this._previousToken !== 'endNumber' && typeof this._stack[this._stack.length - 1] == 'number') {\n          // array\n          ++this._stack[this._stack.length - 1];\n        }\n        break;\n      case 'stringValue':\n        if (this._previousToken !== 'endString' && typeof this._stack[this._stack.length - 1] == 'number') {\n          // array\n          ++this._stack[this._stack.length - 1];\n        }\n        break;\n    }\n    this._previousToken = chunk.name;\n    // check, if we allow a chunk\n    if (this._checkChunk(chunk)) {\n      return callback(null);\n    }\n    // update the stack\n    switch (chunk.name) {\n      case 'startObject':\n        this._stack.push(null);\n        break;\n      case 'startArray':\n        this._stack.push(-1);\n        break;\n      case 'endObject':\n      case 'endArray':\n        this._stack.pop();\n        break;\n    }\n    callback(null);\n  }\n\n  _passObject(chunk, _, callback) {\n    this.push(chunk);\n    switch (chunk.name) {\n      case 'startObject':\n      case 'startArray':\n        ++this._depth;\n        break;\n      case 'endObject':\n      case 'endArray':\n        --this._depth;\n        break;\n    }\n    if (!this._depth) {\n      this._transform = this._once ? this._skip : this._check;\n    }\n    callback(null);\n  }\n\n  _pass(chunk, _, callback) {\n    this.push(chunk);\n    callback(null);\n  }\n\n  _skipObject(chunk, _, callback) {\n    switch (chunk.name) {\n      case 'startObject':\n      case 'startArray':\n        ++this._depth;\n        break;\n      case 'endObject':\n      case 'endArray':\n        --this._depth;\n        break;\n    }\n    if (!this._depth) {\n      this._transform = this._once ? this._pass : this._check;\n    }\n    callback(null);\n  }\n\n  _skip(chunk, _, callback) {\n    callback(null);\n  }\n}\n\nFilterBase.defaultReplacement = [{name: 'nullValue', value: null}];\n\nconst passValue = (last, post) =>\n  function(chunk, _, callback) {\n    if (this._expected) {\n      const expected = this._expected;\n      this._expected = '';\n      this._transform = this._once ? this._skip : this._check;\n      if (expected === chunk.name) {\n        this.push(chunk);\n      } else {\n        return this._transform(chunk, _, callback);\n      }\n    } else {\n      this.push(chunk);\n      if (chunk.name === last) {\n        this._expected = post;\n      }\n    }\n    callback(null);\n  };\n\nFilterBase.prototype._passNumber = passValue('endNumber', 'numberValue');\nFilterBase.prototype._passString = passValue('endString', 'stringValue');\nFilterBase.prototype._passKey = passValue('endKey', 'keyValue');\n\nconst skipValue = (last, post) =>\n  function(chunk, _, callback) {\n    if (this._expected) {\n      const expected = this._expected;\n      this._expected = '';\n      this._transform = this._once ? this._pass : this._check;\n      if (expected !== chunk.name) {\n        return this._transform(chunk, _, callback);\n      }\n    } else {\n      if (chunk.name === last) {\n        this._expected = post;\n      }\n    }\n    callback(null);\n  };\n\nFilterBase.prototype._skipNumber = skipValue('endNumber', 'numberValue');\nFilterBase.prototype._skipString = skipValue('endString', 'stringValue');\nFilterBase.prototype._skipKey = skipValue('endKey', 'keyValue');\n\nmodule.exports = FilterBase;\n", "'use strict';\n\nconst {chain} = require('stream-chain');\n\nconst Parser = require('../Parser');\n\nconst withParser = (fn, options) =>\n  chain([new Parser(options), fn(options)], Object.assign({}, options, {writableObjectMode: false, readableObjectMode: true}));\n\nmodule.exports = withParser;\n", "'use strict';\n\nconst FilterBase = require('./FilterBase');\nconst withParser = require('../utils/withParser');\n\nclass Filter extends FilterBase {\n  static make(options) {\n    return new Filter(options);\n  }\n\n  static withParser(options) {\n    return withParser(Filter.make, options);\n  }\n\n  constructor(options) {\n    super(options);\n    this._once = false;\n    this._lastStack = [];\n  }\n\n  _flush(callback) {\n    this._syncStack();\n    callback(null);\n  }\n\n  _checkChunk(chunk) {\n    switch (chunk.name) {\n      case 'startObject':\n        if (this._filter(this._stack, chunk)) {\n          this._syncStack();\n          this.push(chunk);\n          this._lastStack.push(null);\n        }\n        break;\n      case 'startArray':\n        if (this._filter(this._stack, chunk)) {\n          this._syncStack();\n          this.push(chunk);\n          this._lastStack.push(-1);\n        }\n        break;\n      case 'nullValue':\n      case 'trueValue':\n      case 'falseValue':\n      case 'stringValue':\n      case 'numberValue':\n        if (this._filter(this._stack, chunk)) {\n          this._syncStack();\n          this.push(chunk);\n        }\n        break;\n      case 'startString':\n        if (this._filter(this._stack, chunk)) {\n          this._syncStack();\n          this.push(chunk);\n          this._transform = this._passString;\n        } else {\n          this._transform = this._skipString;\n        }\n        break;\n      case 'startNumber':\n        if (this._filter(this._stack, chunk)) {\n          this._syncStack();\n          this.push(chunk);\n          this._transform = this._passNumber;\n        } else {\n          this._transform = this._skipNumber;\n        }\n        break;\n    }\n    return false;\n  }\n\n  _syncStack() {\n    const stack = this._stack,\n      last = this._lastStack,\n      stackLength = stack.length,\n      lastLength = last.length;\n\n    // find the common part\n    let commonLength = 0;\n    for (const n = Math.min(stackLength, lastLength); commonLength < n && stack[commonLength] === last[commonLength]; ++commonLength);\n\n    // close old objects\n    for (let i = lastLength - 1; i > commonLength; --i) {\n      this.push({name: typeof last[i] == 'number' ? 'endArray' : 'endObject'});\n    }\n    if (commonLength < lastLength) {\n      if (commonLength < stackLength) {\n        if (typeof stack[commonLength] == 'string') {\n          const key = stack[commonLength];\n          if (this._streamKeys) {\n            this.push({name: 'startKey'});\n            this.push({name: 'stringChunk', value: key});\n            this.push({name: 'endKey'});\n          }\n          this.push({name: 'keyValue', value: key});\n        }\n        ++commonLength;\n      } else {\n        this.push({name: typeof last[commonLength] == 'number' ? 'endArray' : 'endObject'});\n      }\n    }\n\n    // open new objects\n    for (let i = commonLength; i < stackLength; ++i) {\n      const key = stack[i];\n      if (typeof key == 'number') {\n        if (key >= 0) {\n          this.push({name: 'startArray'});\n        }\n      } else if (typeof key == 'string') {\n        this.push({name: 'startObject'});\n        if (this._streamKeys) {\n          this.push({name: 'startKey'});\n          this.push({name: 'stringChunk', value: key});\n          this.push({name: 'endKey'});\n        }\n        this.push({name: 'keyValue', value: key});\n      }\n    }\n\n    // update the last stack\n    this._lastStack = Array.prototype.concat.call(stack);\n  }\n}\nFilter.filter = Filter.make;\nFilter.make.Constructor = Filter;\n\nmodule.exports = Filter;\n", "'use strict';\n\nconst EventEmitter = require('events');\n\nconst startObject = Ctr =>\n  function () {\n    if (this.done) {\n      this.done = false;\n    } else {\n      this.stack.push(this.current, this.key);\n    }\n    this.current = new Ctr();\n    this.key = null;\n  };\n\nclass Assembler extends EventEmitter {\n  static connectTo(stream, options) {\n    return new Assembler(options).connectTo(stream);\n  }\n\n  constructor(options) {\n    super();\n    this.stack = [];\n    this.current = this.key = null;\n    this.done = true;\n    if (options) {\n      this.reviver = typeof options.reviver == 'function' && options.reviver;\n      if (this.reviver) {\n        this.stringValue = this._saveValue = this._saveValueWithReviver;\n      }\n      if (options.numberAsString) {\n        this.numberValue = this.stringValue;\n      }\n    }\n  }\n\n  connectTo(stream) {\n    stream.on('data', chunk => {\n      if (this[chunk.name]) {\n        this[chunk.name](chunk.value);\n        if (this.done) this.emit('done', this);\n      }\n    });\n    return this;\n  }\n\n  get depth() {\n    return (this.stack.length >> 1) + (this.done ? 0 : 1);\n  }\n\n  get path() {\n    const path = [];\n    for (let i = 0; i < this.stack.length; i += 2) {\n      const key = this.stack[i + 1];\n      path.push(key === null ? this.stack[i].length : key);\n    }\n    return path;\n  }\n\n  dropToLevel(level) {\n    if (level < this.depth) {\n      if (level) {\n        const index = (level - 1) << 1;\n        this.current = this.stack[index];\n        this.key = this.stack[index + 1];\n        this.stack.splice(index);\n      } else {\n        this.stack = [];\n        this.current = this.key = null;\n        this.done = true;\n      }\n    }\n    return this;\n  }\n\n  consume(chunk) {\n    this[chunk.name] && this[chunk.name](chunk.value);\n    return this;\n  }\n\n  keyValue(value) {\n    this.key = value;\n  }\n\n  //stringValue() - aliased below to _saveValue()\n\n  numberValue(value) {\n    this._saveValue(parseFloat(value));\n  }\n  nullValue() {\n    this._saveValue(null);\n  }\n  trueValue() {\n    this._saveValue(true);\n  }\n  falseValue() {\n    this._saveValue(false);\n  }\n\n  //startObject() - assigned below\n\n  endObject() {\n    if (this.stack.length) {\n      const value = this.current;\n      this.key = this.stack.pop();\n      this.current = this.stack.pop();\n      this._saveValue(value);\n    } else {\n      this.done = true;\n    }\n  }\n\n  //startArray() - assigned below\n  //endArray() - aliased below to endObject()\n\n  _saveValue(value) {\n    if (this.done) {\n      this.current = value;\n    } else {\n      if (this.current instanceof Array) {\n        this.current.push(value);\n      } else {\n        this.current[this.key] = value;\n        this.key = null;\n      }\n    }\n  }\n  _saveValueWithReviver(value) {\n    if (this.done) {\n      this.current = this.reviver('', value);\n    } else {\n      if (this.current instanceof Array) {\n        value = this.reviver('' + this.current.length, value);\n        this.current.push(value);\n        if (value === undefined) {\n          delete this.current[this.current.length - 1];\n        }\n      } else {\n        value = this.reviver(this.key, value);\n        if (value !== undefined) {\n          this.current[this.key] = value;\n        }\n        this.key = null;\n      }\n    }\n  }\n}\n\nAssembler.prototype.stringValue = Assembler.prototype._saveValue;\nAssembler.prototype.startObject = startObject(Object);\nAssembler.prototype.startArray = startObject(Array);\nAssembler.prototype.endArray = Assembler.prototype.endObject;\n\nmodule.exports = Assembler;\n", "'use strict';\n\nconst {Transform} = require('stream');\nconst Assembler = require('../Assembler');\n\nclass Counter {\n  constructor(initialDepth) {\n    this.depth = initialDepth;\n  }\n  startObject() {\n    ++this.depth;\n  }\n  endObject() {\n    --this.depth;\n  }\n  startArray() {\n    ++this.depth;\n  }\n  endArray() {\n    --this.depth;\n  }\n}\n\nclass StreamBase extends Transform {\n  constructor(options) {\n    super(Object.assign({}, options, {writableObjectMode: true, readableObjectMode: true}));\n    if (options) {\n      this.objectFilter = options.objectFilter;\n      this.includeUndecided = options.includeUndecided;\n    }\n    if (typeof this.objectFilter != 'function') {\n      this._filter = this._transform;\n    }\n    this._transform = this._wait || this._filter;\n    this._assembler = new Assembler(options);\n  }\n\n  _transform(chunk, encoding, callback) {\n    if (this._assembler[chunk.name]) {\n      this._assembler[chunk.name](chunk.value);\n      if (this._assembler.depth === this._level) {\n        this._push();\n      }\n    }\n    callback(null);\n  }\n\n  _filter(chunk, encoding, callback) {\n    if (this._assembler[chunk.name]) {\n      this._assembler[chunk.name](chunk.value);\n      const result = this.objectFilter(this._assembler);\n      if (result) {\n        if (this._assembler.depth === this._level) {\n          this._push();\n          this._transform = this._filter;\n        }\n        this._transform = this._accept;\n        return callback(null);\n      }\n      if (result === false) {\n        this._saved_assembler = this._assembler;\n        this._assembler = new Counter(this._saved_assembler.depth);\n        this._saved_assembler.dropToLevel(this._level);\n        if (this._assembler.depth === this._level) {\n          this._assembler = this._saved_assembler;\n          this._transform = this._filter;\n        }\n        this._transform = this._reject;\n        return callback(null);\n      }\n      if (this._assembler.depth === this._level) {\n        this._push(!this.includeUndecided);\n      }\n    }\n    callback(null);\n  }\n\n  _accept(chunk, encoding, callback) {\n    if (this._assembler[chunk.name]) {\n      this._assembler[chunk.name](chunk.value);\n      if (this._assembler.depth === this._level) {\n        this._push();\n        this._transform = this._filter;\n      }\n    }\n    callback(null);\n  }\n\n  _reject(chunk, encoding, callback) {\n    if (this._assembler[chunk.name]) {\n      this._assembler[chunk.name](chunk.value);\n      if (this._assembler.depth === this._level) {\n        this._assembler = this._saved_assembler;\n        this._transform = this._filter;\n      }\n    }\n    callback(null);\n  }\n}\n\nmodule.exports = StreamBase;\n", "'use strict';\n\nconst StreamBase = require('./StreamBase');\nconst withParser = require('../utils/withParser');\n\nclass StreamArray extends StreamBase {\n  static make(options) {\n    return new StreamArray(options);\n  }\n\n  static withParser(options) {\n    return withParser(StreamArray.make, options);\n  }\n\n  constructor(options) {\n    super(options);\n    this._level = 1;\n    this._counter = 0;\n  }\n\n  _wait(chunk, _, callback) {\n    // first chunk should open an array\n    if (chunk.name !== 'startArray') {\n      return callback(new Error('Top-level object should be an array.'));\n    }\n    this._transform = this._filter;\n    return this._transform(chunk, _, callback);\n  }\n\n  _push(discard) {\n    if (this._assembler.current.length) {\n      if (discard) {\n        ++this._counter;\n        this._assembler.current.pop();\n      } else {\n        this.push({key: this._counter++, value: this._assembler.current.pop()});\n      }\n    }\n  }\n}\nStreamArray.streamArray = StreamArray.make;\nStreamArray.make.Constructor = StreamArray;\n\nmodule.exports = StreamArray;\n", "'use strict';\n\nconst FilterBase = require('./FilterBase');\nconst withParser = require('../utils/withParser');\n\nclass Pick extends FilterBase {\n  static make(options) {\n    return new Pick(options);\n  }\n\n  static withParser(options) {\n    return withParser(Pick.make, options);\n  }\n\n  _checkChunk(chunk) {\n    switch (chunk.name) {\n      case 'startObject':\n      case 'startArray':\n        if (this._filter(this._stack, chunk)) {\n          this.push(chunk);\n          this._transform = this._passObject;\n          this._depth = 1;\n          return true;\n        }\n        break;\n      case 'startString':\n        if (this._filter(this._stack, chunk)) {\n          this.push(chunk);\n          this._transform = this._passString;\n          return true;\n        }\n        break;\n      case 'startNumber':\n        if (this._filter(this._stack, chunk)) {\n          this.push(chunk);\n          this._transform = this._passNumber;\n          return true;\n        }\n        break;\n      case 'nullValue':\n      case 'trueValue':\n      case 'falseValue':\n      case 'stringValue':\n      case 'numberValue':\n        if (this._filter(this._stack, chunk)) {\n          this.push(chunk);\n          this._transform = this._once ? this._skip : this._check;\n          return true;\n        }\n        break;\n    }\n    return false;\n  }\n}\nPick.pick = Pick.make;\nPick.make.Constructor = Pick;\n\nmodule.exports = Pick;\n", "'use strict';\n\nconst StreamBase = require('./StreamBase');\nconst withParser = require('../utils/withParser');\n\nclass StreamObject extends StreamBase {\n  static make(options) {\n    return new StreamObject(options);\n  }\n\n  static withParser(options) {\n    return withParser(StreamObject.make, options);\n  }\n\n  constructor(options) {\n    super(options);\n    this._level = 1;\n    this._lastKey = null;\n  }\n\n  _wait(chunk, _, callback) {\n    // first chunk should open an array\n    if (chunk.name !== 'startObject') {\n      return callback(new Error('Top-level object should be an object.'));\n    }\n    this._transform = this._filter;\n    return this._transform(chunk, _, callback);\n  }\n\n  _push(discard) {\n    if (this._lastKey === null) {\n      this._lastKey = this._assembler.key;\n    } else {\n      !discard && this.push({key: this._lastKey, value: this._assembler.current[this._lastKey]});\n      this._assembler.current = {};\n      this._lastKey = null;\n    }\n  }\n}\nStreamObject.streamObject = StreamObject.make;\nStreamObject.make.Constructor = StreamObject;\n\nmodule.exports = StreamObject;\n", "/**\n * Search command for browsing and searching brew packages.\n */\n\nimport { useEffect, useRef, useState } from \"react\";\nimport { Color, Icon, List, showToast, Toast } from \"@raycast/api\";\nimport { getProgressIcon } from \"@raycast/utils\";\nimport { useBrewInstalled } from \"./hooks/useBrewInstalled\";\nimport { useBrewSearch, isInstalled } from \"./hooks/useBrewSearch\";\nimport type { FileDownloadProgress } from \"./hooks/useBrewSearch\";\nimport { InstallableFilterDropdown, InstallableFilterType, placeholder } from \"./components/filter\";\nimport { FormulaList } from \"./components/list\";\n\n/**\n * Format bytes to human-readable string (e.g., \"12.5 MB\")\n */\nfunction formatBytes(bytes: number): string {\n  if (bytes === 0) return \"0 B\";\n  const k = 1024;\n  const sizes = [\"B\", \"KB\", \"MB\", \"GB\"];\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\n  return `${(bytes / Math.pow(k, i)).toFixed(1)} ${sizes[i]}`;\n}\n\n/**\n * Format a number with commas (e.g., 8081 -> \"8,081\")\n */\nfunction formatNumber(num: number): string {\n  return num.toLocaleString();\n}\n\n/**\n * Get subtitle text showing download progress (left side)\n */\nfunction getDownloadSubtitle(progress: FileDownloadProgress, isProcessing: boolean): string {\n  if (progress.complete) {\n    return \"\";\n  }\n  if (isProcessing && progress.itemsProcessed > 0) {\n    return `${formatNumber(progress.itemsProcessed)} processed`;\n  }\n  if (isProcessing) {\n    return \"Processing...\";\n  }\n  if (!progress.started) {\n    return \"\";\n  }\n  // Show download progress: \"15% downloaded (4.6 MB)\"\n  if (progress.bytesDownloaded > 0) {\n    const downloaded = formatBytes(progress.bytesDownloaded);\n    // Cap percent at 100 to avoid display issues\n    const percent = progress.percent > 0 ? Math.min(progress.percent, 100) : 0;\n    if (percent > 0) {\n      return `${percent}% downloaded (${downloaded})`;\n    }\n    return `${downloaded} downloaded`;\n  }\n  return \"Starting...\";\n}\n\n/**\n * Get accessory text showing total size or status (right side)\n */\nfunction getDownloadAccessory(progress: FileDownloadProgress, isProcessing: boolean, itemType: string): string {\n  if (progress.complete && progress.totalItems > 0) {\n    return `${formatNumber(progress.totalItems)} ${itemType}`;\n  }\n  if (progress.complete) {\n    return \"Done\";\n  }\n  if (isProcessing && progress.itemsProcessed > 0 && progress.totalItems > 0) {\n    return `${formatNumber(progress.itemsProcessed)} of ${formatNumber(progress.totalItems)} ${itemType}`;\n  }\n  if (isProcessing) {\n    return \"Processing...\";\n  }\n  if (!progress.started) {\n    return \"Waiting\";\n  }\n  // Show total file size: \"29.4 MB Total\"\n  if (progress.totalBytes > 0) {\n    return `${formatBytes(progress.totalBytes)} Total`;\n  }\n  return \"Downloading...\";\n}\n\n/**\n * Get the icon for a download step based on progress\n * @param progress - The download progress\n * @param isProcessing - Whether we're currently processing this file\n */\nfunction getDownloadIcon(progress: FileDownloadProgress, isProcessing = false) {\n  if (progress.complete) {\n    return { source: Icon.CheckCircle, tintColor: Color.Green };\n  }\n  if (isProcessing) {\n    // Show animated progress icon during processing with dynamic color\n    return getProgressIcon(0.9, Color.PrimaryText);\n  }\n  if (!progress.started) {\n    return { source: Icon.Circle, tintColor: Color.SecondaryText };\n  }\n  // Show progress icon with actual percentage (capped at 100%) and dynamic color\n  const percent = progress.percent > 0 ? Math.min(progress.percent, 100) : 0;\n  const fraction = percent > 0 ? percent / 100 : 0.05;\n  return getProgressIcon(fraction, Color.PrimaryText);\n}\n\nexport default function SearchView() {\n  const [searchText, setSearchText] = useState(\"\");\n  const [filter, setFilter] = useState(InstallableFilterType.all);\n\n  const { isLoading: isLoadingInstalled, data: installed, revalidate: revalidateInstalled } = useBrewInstalled();\n\n  // useBrewSearch automatically applies installed status via useMemo\n  // whenever either search results or installed data changes\n  const {\n    isLoading: isLoadingSearch,\n    hasCacheFiles,\n    loadingState,\n    data: results,\n    indexTotals,\n  } = useBrewSearch({\n    searchText,\n    installed,\n  });\n\n  const formulae = filter != InstallableFilterType.casks ? (results?.formulae ?? []) : [];\n  const casks = filter != InstallableFilterType.formulae ? (results?.casks ?? []) : [];\n\n  // Track if we've shown the completion toast (persists across renders)\n  const hasShownCompletionToast = useRef(false);\n\n  // Extract primitive for stable dependency (avoids render loops from object changes)\n  const phase = loadingState.phase;\n\n  // Show completion toast when download AND processing are fully complete\n  // Wait for phase === \"complete\" to ensure we have accurate totals\n  useEffect(() => {\n    if (phase === \"complete\" && !hasShownCompletionToast.current && results) {\n      hasShownCompletionToast.current = true;\n      // Use indexTotals for accurate counts (total packages in index, not filtered results)\n      const totalFormulae = indexTotals?.formulae || 0;\n      const totalCasks = indexTotals?.casks || 0;\n      showToast({\n        style: Toast.Style.Success,\n        title: \"Package Index Ready\",\n        message: `${formatNumber(totalFormulae)} formulae and ${formatNumber(totalCasks)} casks loaded`,\n      });\n    }\n  }, [phase, results]);\n\n  // Determine which loading UI to show during initial load:\n  // - hasCacheFiles === null: Still checking if cache exists, show simple loading\n  // - hasCacheFiles === true: Cache exists (warm start), show normal list with spinner\n  // - hasCacheFiles === false: No cache (cold start), show download progress UI\n\n  // While checking cache existence, show a simple loading state\n  if (loadingState.isInitialLoad && hasCacheFiles === null) {\n    return (\n      <List navigationTitle=\"Search\" searchBarPlaceholder=\"Checking cache...\" isLoading={true}>\n        <List.EmptyView icon={Icon.MagnifyingGlass} title=\"Loading...\" />\n      </List>\n    );\n  }\n\n  // Show download progress UI only when cache files don't exist (first run / cold start)\n  // Keep showing until phase is \"complete\" to ensure user sees full download and processing progress\n  const showDownloadProgress = hasCacheFiles === false && phase !== \"complete\";\n\n  if (showDownloadProgress) {\n    const { phase, casksProgress, formulaeProgress } = loadingState;\n\n    // Cold start: show detailed download progress\n    // Detect processing state: download is at 100% (or bytes match) but phase hasn't moved on\n    // This happens because processing takes a long time after download completes\n    // Handle edge case where percent is -1 (unknown total) by checking bytes directly\n    const isCasksDownloadDone =\n      casksProgress.percent >= 100 ||\n      (casksProgress.bytesDownloaded > 0 &&\n        casksProgress.totalBytes > 0 &&\n        casksProgress.bytesDownloaded >= casksProgress.totalBytes);\n    const isFormulaeDownloadDone =\n      formulaeProgress.percent >= 100 ||\n      (formulaeProgress.bytesDownloaded > 0 &&\n        formulaeProgress.totalBytes > 0 &&\n        formulaeProgress.bytesDownloaded >= formulaeProgress.totalBytes);\n\n    const isProcessingCasks = phase === \"casks\" && isCasksDownloadDone && !casksProgress.complete;\n    const isProcessingFormulae = phase === \"formulae\" && isFormulaeDownloadDone && !formulaeProgress.complete;\n\n    // Formulae haven't started yet if we're still in casks phase\n    const formulaeNotStarted = phase === \"casks\";\n\n    // Build status message for search bar (simple, no counts)\n    let statusMessage = \"Loading package index...\";\n    if (isProcessingCasks) {\n      statusMessage = \"Processing casks...\";\n    } else if (isProcessingFormulae) {\n      statusMessage = \"Processing formulae...\";\n    } else if (phase === \"casks\" && casksProgress.percent > 0) {\n      statusMessage = `Downloading casks... ${Math.min(casksProgress.percent, 100)}%`;\n    } else if (phase === \"formulae\" && formulaeProgress.percent > 0) {\n      statusMessage = `Downloading formulae... ${Math.min(formulaeProgress.percent, 100)}%`;\n    } else if (phase === \"casks\") {\n      statusMessage = \"Downloading casks...\";\n    } else if (phase === \"formulae\") {\n      statusMessage = \"Downloading formulae...\";\n    } else if (phase === \"parsing\") {\n      statusMessage = \"Processing package data...\";\n    }\n\n    // Build casks subtitle - show download progress on left\n    const casksSubtitle = getDownloadSubtitle(casksProgress, isProcessingCasks);\n\n    // Build formulae subtitle - empty when waiting, otherwise show progress\n    const formulaeSubtitle = formulaeNotStarted ? \"\" : getDownloadSubtitle(formulaeProgress, isProcessingFormulae);\n\n    // Build formulae title based on state\n    let formulaeTitle = \"Download Formulae\";\n    if (isProcessingFormulae) {\n      formulaeTitle = \"Processing Formulae\";\n    } else if (!formulaeNotStarted && formulaeProgress.started) {\n      formulaeTitle = \"Downloading Formulae\";\n    }\n\n    // Build formulae accessory text (right side)\n    let formulaeAccessoryText = \"Waiting\";\n    if (formulaeNotStarted) {\n      formulaeAccessoryText = isProcessingCasks ? \"Waiting on Casks processing...\" : \"Waiting on Casks to finish...\";\n    } else {\n      formulaeAccessoryText = getDownloadAccessory(formulaeProgress, isProcessingFormulae, \"formulae\");\n    }\n\n    // Build formulae icon - show empty circle if not started\n    const formulaeIcon = formulaeNotStarted\n      ? { source: Icon.Circle, tintColor: Color.SecondaryText }\n      : getDownloadIcon(formulaeProgress, isProcessingFormulae);\n\n    return (\n      <List navigationTitle=\"First-time setup\" searchBarPlaceholder={statusMessage} isLoading={true}>\n        <List.Section title=\"Initializing...\">\n          <List.Item\n            icon={getDownloadIcon(casksProgress, isProcessingCasks)}\n            title={isProcessingCasks ? \"Processing Casks\" : \"Downloading Casks\"}\n            subtitle={casksSubtitle}\n            accessories={[{ text: getDownloadAccessory(casksProgress, isProcessingCasks, \"casks\") }]}\n          />\n          <List.Item\n            icon={formulaeIcon}\n            title={formulaeTitle}\n            subtitle={formulaeSubtitle}\n            accessories={[{ text: formulaeAccessoryText }]}\n          />\n        </List.Section>\n      </List>\n    );\n  }\n\n  return (\n    <FormulaList\n      formulae={formulae}\n      casks={casks}\n      searchBarPlaceholder={placeholder(filter)}\n      searchBarAccessory={<InstallableFilterDropdown onSelect={setFilter} />}\n      isLoading={isLoadingInstalled || isLoadingSearch}\n      onSearchTextChange={(searchText) => setSearchText(searchText.trim())}\n      filtering={false}\n      isInstalled={(name) => isInstalled(name, installed)}\n      onAction={() => revalidateInstalled()}\n      dataFetched={loadingState.phase === \"complete\"}\n    />\n  );\n}\n", "var has = Object.prototype.hasOwnProperty;\n\nexport function dequal(foo, bar) {\n\tvar ctor, len;\n\tif (foo === bar) return true;\n\n\tif (foo && bar && (ctor=foo.constructor) === bar.constructor) {\n\t\tif (ctor === Date) return foo.getTime() === bar.getTime();\n\t\tif (ctor === RegExp) return foo.toString() === bar.toString();\n\n\t\tif (ctor === Array) {\n\t\t\tif ((len=foo.length) === bar.length) {\n\t\t\t\twhile (len-- && dequal(foo[len], bar[len]));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (!ctor || typeof foo === 'object') {\n\t\t\tlen = 0;\n\t\t\tfor (ctor in foo) {\n\t\t\t\tif (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;\n\t\t\t\tif (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;\n\t\t\t}\n\t\t\treturn Object.keys(bar).length === len;\n\t\t}\n\t}\n\n\treturn foo !== foo && bar !== bar;\n}\n", "/// <reference types=\"node\" />\n\nexport { usePromise } from \"./usePromise\";\nexport { useCachedState } from \"./useCachedState\";\nexport { useCachedPromise } from \"./useCachedPromise\";\nexport { useFetch } from \"./useFetch\";\nexport { useExec } from \"./useExec\";\nexport { useStreamJSON } from \"./useStreamJSON\";\nexport { useSQL } from \"./useSQL\";\nexport { useForm, FormValidation } from \"./useForm\";\nexport { useAI } from \"./useAI\";\nexport { useFrecencySorting } from \"./useFrecencySorting\";\nexport { useLocalStorage } from \"./useLocalStorage\";\n\nexport { getAvatarIcon, getFavicon, getProgressIcon } from \"./icon\";\n\nexport { OAuthService, withAccessToken, getAccessToken } from \"./oauth\";\n\nexport { createDeeplink, createExtensionDeeplink, createScriptCommandDeeplink, DeeplinkType } from \"./createDeeplink\";\nexport { executeSQL } from \"./executeSQL\";\nexport { runAppleScript } from \"./run-applescript\";\nexport { runPowerShellScript } from \"./run-powershell-script\";\nexport { showFailureToast } from \"./showFailureToast\";\nexport { withCache } from \"./cache\";\n\nexport type { PromiseOptions } from \"./usePromise\";\nexport type { CachedPromiseOptions } from \"./useCachedPromise\";\nexport type {\n  OAuthServiceOptions,\n  OnAuthorizeParams,\n  WithAccessTokenComponentOrFn,\n  ProviderWithDefaultClientOptions,\n  ProviderOptions,\n} from \"./oauth\";\nexport type { AsyncState, MutatePromise } from \"./types\";\n", "import { useEffect, useCallback, RefObject, useRef, useState } from \"react\";\nimport { environment, LaunchType, Toast } from \"@raycast/api\";\nimport { useDeepMemo } from \"./useDeepMemo\";\nimport {\n  FunctionReturningPromise,\n  MutatePromise,\n  UsePromiseReturnType,\n  AsyncState,\n  FunctionReturningPaginatedPromise,\n  UnwrapReturn,\n  PaginationOptions,\n} from \"./types\";\nimport { useLatest } from \"./useLatest\";\nimport { showFailureToast } from \"./showFailureToast\";\n\nexport type PromiseOptions<T extends FunctionReturningPromise | FunctionReturningPaginatedPromise> = {\n  /**\n   * A reference to an `AbortController` to cancel a previous call when triggering a new one\n   */\n  abortable?: RefObject<AbortController | null | undefined>;\n  /**\n   * Whether to actually execute the function or not.\n   * This is useful for cases where one of the function's arguments depends on something that\n   * might not be available right away (for example, depends on some user inputs). Because React requires\n   * every hooks to be defined on the render, this flag enables you to define the hook right away but\n   * wait util you have all the arguments ready to execute the function.\n   */\n  execute?: boolean;\n  /**\n   * Options for the generic failure toast.\n   * It allows you to customize the title, message, and primary action of the failure toast.\n   */\n  failureToastOptions?: Partial<Pick<Toast.Options, \"title\" | \"primaryAction\" | \"message\">>;\n  /**\n   * Called when an execution fails. By default it will log the error and show\n   * a generic failure toast.\n   */\n  onError?: (error: Error) => void | Promise<void>;\n  /**\n   * Called when an execution succeeds.\n   */\n  onData?: (data: UnwrapReturn<T>, pagination?: PaginationOptions<UnwrapReturn<T>>) => void | Promise<void>;\n  /**\n   * Called when an execution will start\n   */\n  onWillExecute?: (parameters: Parameters<T>) => void;\n};\n\n/**\n * Wraps an asynchronous function or a function that returns a Promise in another function, and returns the {@link AsyncState} corresponding to the execution of the function.\n *\n * @remark This overload should be used when working with paginated data sources.\n *\n * @example\n * ```\n * import { setTimeout } from \"node:timers/promises\";\n * import { useState } from \"react\";\n * import { List } from \"@raycast/api\";\n * import { usePromise } from \"@raycast/utils\";\n *\n * export default function Command() {\n *   const [searchText, setSearchText] = useState(\"\");\n *\n *   const { isLoading, data, pagination } = usePromise(\n *     (searchText: string) => async (options: { page: number }) => {\n *       await setTimeout(200);\n *       const newData = Array.from({ length: 25 }, (_v, index) => ({\n *         index,\n *         page: options.page,\n *         text: searchText,\n *       }));\n *       return { data: newData, hasMore: options.page < 10 };\n *     },\n *     [searchText]\n *   );\n *\n *   return (\n *     <List isLoading={isLoading} onSearchTextChange={setSearchText} pagination={pagination}>\n *       {data?.map((item) => (\n *         <List.Item\n *           key={`${item.page} ${item.index} ${item.text}`}\n *           title={`Page ${item.page} Item ${item.index}`}\n *           subtitle={item.text}\n *         />\n *       ))}\n *     </List>\n *   );\n * };\n * ```\n */\nexport function usePromise<T extends FunctionReturningPaginatedPromise<[]>>(\n  fn: T,\n): UsePromiseReturnType<UnwrapReturn<T>>;\nexport function usePromise<T extends FunctionReturningPaginatedPromise>(\n  fn: T,\n  args: Parameters<T>,\n  options?: PromiseOptions<T>,\n): UsePromiseReturnType<UnwrapReturn<T>>;\n\n/**\n * Wraps an asynchronous function or a function that returns a Promise and returns the {@link AsyncState} corresponding to the execution of the function.\n *\n * @remark The function is assumed to be constant (eg. changing it won't trigger a revalidation).\n *\n * @example\n * ```\n * import { usePromise } from '@raycast/utils';\n *\n * export default function Command() {\n *   const abortable = useRef<AbortController>();\n *   const { isLoading, data, revalidate } = usePromise(async (url: string) => {\n *     const response = await fetch(url, { signal: abortable.current?.signal });\n *     const result = await response.text();\n *     return result\n *   },\n *   ['https://api.example'],\n *   {\n *     abortable\n *   });\n *\n *   return (\n *     <Detail\n *       isLoading={isLoading}\n *       markdown={data}\n *       actions={\n *         <ActionPanel>\n *           <Action title=\"Reload\" onAction={() => revalidate()} />\n *         </ActionPanel>\n *       }\n *     />\n *   );\n * };\n * ```\n */\nexport function usePromise<T extends FunctionReturningPromise<[]>>(fn: T): UsePromiseReturnType<UnwrapReturn<T>>;\nexport function usePromise<T extends FunctionReturningPromise>(\n  fn: T,\n  args: Parameters<T>,\n  options?: PromiseOptions<T>,\n): UsePromiseReturnType<UnwrapReturn<T>>;\n\nexport function usePromise<T extends FunctionReturningPromise | FunctionReturningPaginatedPromise>(\n  fn: T,\n  args?: Parameters<T>,\n  options?: PromiseOptions<T>,\n): UsePromiseReturnType<any> {\n  const lastCallId = useRef(0);\n  const [state, set] = useState<AsyncState<UnwrapReturn<T>>>({ isLoading: true });\n\n  const fnRef = useLatest(fn);\n  const latestAbortable = useLatest(options?.abortable);\n  const latestArgs = useLatest(args || []);\n  const latestOnError = useLatest(options?.onError);\n  const latestOnData = useLatest(options?.onData);\n  const latestOnWillExecute = useLatest(options?.onWillExecute);\n  const latestFailureToast = useLatest(options?.failureToastOptions);\n  const latestValue = useLatest(state.data);\n  const latestCallback = useRef<(...args: Parameters<T>) => Promise<UnwrapReturn<T>>>(null);\n\n  const paginationArgsRef = useRef<PaginationOptions>({ page: 0 });\n  const usePaginationRef = useRef(false);\n  const hasMoreRef = useRef(true);\n  const pageSizeRef = useRef(50);\n\n  const abort = useCallback(() => {\n    if (latestAbortable.current) {\n      latestAbortable.current.current?.abort();\n      latestAbortable.current.current = new AbortController();\n    }\n    return ++lastCallId.current;\n  }, [latestAbortable]);\n\n  const callback = useCallback(\n    (...args: Parameters<T>): Promise<UnwrapReturn<T>> => {\n      const callId = abort();\n\n      latestOnWillExecute.current?.(args);\n\n      set((prevState) => ({ ...prevState, isLoading: true }));\n\n      const promiseOrPaginatedPromise = bindPromiseIfNeeded(fnRef.current)(...args);\n\n      function handleError(error: any) {\n        if (error.name == \"AbortError\") {\n          return error;\n        }\n\n        if (callId === lastCallId.current) {\n          // handle errors\n          if (latestOnError.current) {\n            latestOnError.current(error);\n          } else {\n            if (environment.launchType !== LaunchType.Background) {\n              showFailureToast(error, {\n                title: \"Failed to fetch latest data\",\n                primaryAction: {\n                  title: \"Retry\",\n                  onAction(toast) {\n                    toast.hide();\n                    latestCallback.current?.(...((latestArgs.current || []) as Parameters<T>));\n                  },\n                },\n                ...latestFailureToast.current,\n              });\n            }\n          }\n          set({ error, isLoading: false });\n        }\n\n        return error;\n      }\n\n      if (typeof promiseOrPaginatedPromise === \"function\") {\n        usePaginationRef.current = true;\n        return promiseOrPaginatedPromise(paginationArgsRef.current).then(\n          // @ts-expect-error too complicated for TS\n          ({ data, hasMore, cursor }: { data: UnwrapReturn<T>; hasMore: boolean; cursor?: any }) => {\n            if (callId === lastCallId.current) {\n              if (paginationArgsRef.current) {\n                paginationArgsRef.current.cursor = cursor;\n                paginationArgsRef.current.lastItem = data?.[data.length - 1];\n              }\n\n              if (latestOnData.current) {\n                latestOnData.current(data, paginationArgsRef.current);\n              }\n\n              if (hasMore) {\n                pageSizeRef.current = data.length;\n              }\n              hasMoreRef.current = hasMore;\n\n              set((previousData) => {\n                if (paginationArgsRef.current.page === 0) {\n                  return { data, isLoading: false };\n                }\n                // @ts-expect-error we know it's an array here\n                return { data: (previousData.data || [])?.concat(data), isLoading: false };\n              });\n            }\n\n            return data;\n          },\n          (error: unknown) => {\n            hasMoreRef.current = false;\n            return handleError(error);\n          },\n        ) as Promise<UnwrapReturn<T>>;\n      }\n\n      usePaginationRef.current = false;\n      return promiseOrPaginatedPromise.then((data: UnwrapReturn<T>) => {\n        if (callId === lastCallId.current) {\n          if (latestOnData.current) {\n            latestOnData.current(data);\n          }\n          set({ data, isLoading: false });\n        }\n\n        return data;\n      }, handleError) as Promise<UnwrapReturn<T>>;\n    },\n    [\n      latestOnData,\n      latestOnError,\n      latestArgs,\n      fnRef,\n      set,\n      latestCallback,\n      latestOnWillExecute,\n      paginationArgsRef,\n      latestFailureToast,\n      abort,\n    ],\n  );\n\n  latestCallback.current = callback;\n\n  const revalidate = useCallback(() => {\n    // reset the pagination\n    paginationArgsRef.current = { page: 0 };\n\n    const args = (latestArgs.current || []) as Parameters<T>;\n    return callback(...args);\n  }, [callback, latestArgs]);\n\n  const mutate = useCallback<MutatePromise<Awaited<ReturnType<T>>, undefined>>(\n    async (asyncUpdate, options) => {\n      let dataBeforeOptimisticUpdate: Awaited<ReturnType<T>> | undefined;\n      try {\n        if (options?.optimisticUpdate) {\n          // cancel the in-flight request to make sure it won't overwrite the optimistic update\n          abort();\n\n          if (typeof options?.rollbackOnError !== \"function\" && options?.rollbackOnError !== false) {\n            // keep track of the data before the optimistic update,\n            // but only if we need it (eg. only when we want to automatically rollback after)\n            dataBeforeOptimisticUpdate = structuredClone(latestValue.current?.value);\n          }\n          const update = options.optimisticUpdate;\n          set((prevState) => ({ ...prevState, data: update(prevState.data) }));\n        }\n        return await asyncUpdate;\n      } catch (err) {\n        if (typeof options?.rollbackOnError === \"function\") {\n          const update = options.rollbackOnError;\n          set((prevState) => ({ ...prevState, data: update(prevState.data) }));\n        } else if (options?.optimisticUpdate && options?.rollbackOnError !== false) {\n          set((prevState) => ({ ...prevState, data: dataBeforeOptimisticUpdate }));\n        }\n        throw err;\n      } finally {\n        if (options?.shouldRevalidateAfter !== false) {\n          if (environment.launchType === LaunchType.Background || environment.commandMode === \"menu-bar\") {\n            // when in the background or in a menu bar, we are going to await the revalidation\n            // to make sure we get the right data at the end of the mutation\n            await revalidate();\n          } else {\n            revalidate();\n          }\n        }\n      }\n    },\n    [revalidate, latestValue, set, abort],\n  );\n\n  const onLoadMore = useCallback(() => {\n    paginationArgsRef.current.page += 1;\n    const args = (latestArgs.current || []) as Parameters<T>;\n    callback(...args);\n  }, [paginationArgsRef, latestArgs, callback]);\n\n  // revalidate when the args change\n  useEffect(() => {\n    // reset the pagination\n    paginationArgsRef.current = { page: 0 };\n\n    if (options?.execute !== false) {\n      callback(...((args || []) as Parameters<T>));\n    } else {\n      // cancel the previous request if we don't want to execute anymore\n      abort();\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [useDeepMemo([args, options?.execute, callback]), latestAbortable, paginationArgsRef]);\n\n  // abort request when unmounting\n  useEffect(() => {\n    return () => {\n      abort();\n    };\n  }, [abort]);\n\n  // we only want to show the loading indicator if the promise is executing\n  const isLoading = options?.execute !== false ? state.isLoading : false;\n\n  // @ts-expect-error loading is has some fixed value in the enum which\n  const stateWithLoadingFixed: AsyncState<Awaited<ReturnType<T>>> = { ...state, isLoading };\n\n  const pagination = usePaginationRef.current\n    ? {\n        pageSize: pageSizeRef.current,\n        hasMore: hasMoreRef.current,\n        onLoadMore,\n      }\n    : undefined;\n\n  return { ...stateWithLoadingFixed, revalidate, mutate, pagination };\n}\n\n/** Bind the fn if it's a Promise method */\nfunction bindPromiseIfNeeded<T>(fn: T): T {\n  if (fn === (Promise.all as any)) {\n    // @ts-expect-error this is fine\n    return fn.bind(Promise);\n  }\n  if (fn === (Promise.race as any)) {\n    // @ts-expect-error this is fine\n    return fn.bind(Promise);\n  }\n  if (fn === (Promise.resolve as any)) {\n    // @ts-expect-error this is fine\n    return fn.bind(Promise as any);\n  }\n  if (fn === (Promise.reject as any)) {\n    // @ts-expect-error this is fine\n    return fn.bind(Promise);\n  }\n  return fn;\n}\n", "import { useRef, useMemo } from \"react\";\nimport { dequal } from \"dequal/lite\";\n\n/**\n * @param value the value to be memoized (usually a dependency list)\n * @returns a memoized version of the value as long as it remains deeply equal\n */\nexport function useDeepMemo<T>(value: T) {\n  const ref = useRef<T>(value);\n  const signalRef = useRef<number>(0);\n\n  if (!dequal(value, ref.current)) {\n    ref.current = value;\n    signalRef.current += 1;\n  }\n\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  return useMemo(() => ref.current, [signalRef.current]);\n}\n", "import { useRef } from \"react\";\n\n/**\n * Returns the latest state.\n *\n * This is mostly useful to get access to the latest value of some props or state inside an asynchronous callback, instead of that value at the time the callback was created from.\n */\nexport function useLatest<T>(value: T): { readonly current: T } {\n  const ref = useRef(value);\n  ref.current = value;\n  return ref;\n}\n", "import * as fs from \"node:fs\";\nimport * as path from \"node:path\";\nimport { Clipboard, environment, open, Toast, showToast } from \"@raycast/api\";\n\n/**\n * Shows a failure Toast for a given Error.\n *\n * @example\n * ```typescript\n * import { showHUD } from \"@raycast/api\";\n * import { runAppleScript, showFailureToast } from \"@raycast/utils\";\n *\n * export default async function () {\n *   try {\n *     const res = await runAppleScript(\n *       `\n *       on run argv\n *         return \"hello, \" & item 1 of argv & \".\"\n *       end run\n *       `,\n *       [\"world\"]\n *     );\n *     await showHUD(res);\n *   } catch (error) {\n *     showFailureToast(error, { title: \"Could not run AppleScript\" });\n *   }\n * }\n * ```\n */\nexport function showFailureToast(\n  error: unknown,\n  options?: Partial<Pick<Toast.Options, \"title\" | \"primaryAction\" | \"message\">>,\n) {\n  const message = error instanceof Error ? error.message : String(error);\n  return showToast({\n    style: Toast.Style.Failure,\n    title: options?.title ?? \"Something went wrong\",\n    message: options?.message ?? message,\n    primaryAction: options?.primaryAction ?? handleErrorToastAction(error),\n    secondaryAction: options?.primaryAction ? handleErrorToastAction(error) : undefined,\n  });\n}\n\nconst handleErrorToastAction = (error: unknown): Toast.ActionOptions => {\n  let privateExtension = true;\n  let title = \"[Extension Name]...\";\n  let extensionURL = \"\";\n  try {\n    const packageJSON = JSON.parse(fs.readFileSync(path.join(environment.assetsPath, \"..\", \"package.json\"), \"utf8\"));\n    title = `[${packageJSON.title}]...`;\n    extensionURL = `https://raycast.com/${packageJSON.owner || packageJSON.author}/${packageJSON.name}`;\n    if (!packageJSON.owner || packageJSON.access === \"public\") {\n      privateExtension = false;\n    }\n  } catch (err) {\n    // no-op\n  }\n\n  // if it's a private extension, we can't construct the URL to report the error\n  // so we fallback to copying the error to the clipboard\n  const fallback = environment.isDevelopment || privateExtension;\n\n  const stack = error instanceof Error ? error?.stack || error?.message || \"\" : String(error);\n\n  return {\n    title: fallback ? \"Copy Logs\" : \"Report Error\",\n    onAction(toast) {\n      toast.hide();\n      if (fallback) {\n        Clipboard.copy(stack);\n      } else {\n        open(\n          `https://github.com/raycast/extensions/issues/new?&labels=extension%2Cbug&template=extension_bug_report.yml&title=${encodeURIComponent(\n            title,\n          )}&extension-url=${encodeURI(extensionURL)}&description=${encodeURIComponent(\n            `#### Error:\n\\`\\`\\`\n${stack}\n\\`\\`\\`\n`,\n          )}`,\n        );\n      }\n    },\n  };\n};\n", "import { useCallback, Dispatch, SetStateAction, useSyncExternalStore, useMemo } from \"react\";\nimport { Cache } from \"@raycast/api\";\nimport { useLatest } from \"./useLatest\";\nimport { replacer, reviver } from \"./helpers\";\n\nconst rootCache = /* #__PURE__ */ Symbol(\"cache without namespace\");\nconst cacheMap = /* #__PURE__ */ new Map<string | symbol, Cache>();\n\n/**\n * Returns a stateful value, and a function to update it. The value will be kept between command runs.\n *\n * @remark The value needs to be JSON serializable.\n *\n * @param key - The unique identifier of the state. This can be used to share the state across components and/or commands.\n * @param initialState - The initial value of the state if there aren't any in the Cache yet.\n */\nexport function useCachedState<T>(\n  key: string,\n  initialState: T,\n  config?: { cacheNamespace?: string },\n): [T, Dispatch<SetStateAction<T>>];\nexport function useCachedState<T = undefined>(key: string): [T | undefined, Dispatch<SetStateAction<T | undefined>>];\nexport function useCachedState<T>(\n  key: string,\n  initialState?: T,\n  config?: { cacheNamespace?: string },\n): [T, Dispatch<SetStateAction<T>>] {\n  const cacheKey = config?.cacheNamespace || rootCache;\n  const cache =\n    cacheMap.get(cacheKey) || cacheMap.set(cacheKey, new Cache({ namespace: config?.cacheNamespace })).get(cacheKey);\n\n  if (!cache) {\n    throw new Error(\"Missing cache\");\n  }\n\n  const keyRef = useLatest(key);\n  const initialValueRef = useLatest(initialState);\n\n  const cachedState = useSyncExternalStore(cache.subscribe, () => {\n    try {\n      return cache.get(keyRef.current);\n    } catch (error) {\n      console.error(\"Could not get Cache data:\", error);\n      return undefined;\n    }\n  });\n\n  const state = useMemo(() => {\n    if (typeof cachedState !== \"undefined\") {\n      if (cachedState === \"undefined\") {\n        return undefined;\n      }\n      try {\n        return JSON.parse(cachedState, reviver);\n      } catch (err) {\n        // the data got corrupted somehow\n        console.warn(\"The cached data is corrupted\", err);\n        return initialValueRef.current;\n      }\n    } else {\n      return initialValueRef.current;\n    }\n  }, [cachedState, initialValueRef]);\n\n  const stateRef = useLatest(state);\n\n  const setStateAndCache = useCallback(\n    (updater: SetStateAction<T>) => {\n      // @ts-expect-error TS struggles to infer the types as T could potentially be a function\n      const newValue = typeof updater === \"function\" ? updater(stateRef.current) : updater;\n      if (typeof newValue === \"undefined\") {\n        cache.set(keyRef.current, \"undefined\");\n      } else {\n        const stringifiedValue = JSON.stringify(newValue, replacer);\n        cache.set(keyRef.current, stringifiedValue);\n      }\n      return newValue;\n    },\n    [cache, keyRef, stateRef],\n  );\n\n  return [state, setStateAndCache];\n}\n", "import crypto from \"node:crypto\";\nimport { typeHasher } from \"./vendors/type-hasher\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function replacer(this: any, key: string, _value: unknown) {\n  const value = this[key];\n  if (value instanceof Date) {\n    return `__raycast_cached_date__${value.toISOString()}`;\n  }\n  if (Buffer.isBuffer(value)) {\n    return `__raycast_cached_buffer__${value.toString(\"base64\")}`;\n  }\n  return _value;\n}\n\nexport function reviver(_key: string, value: unknown) {\n  if (typeof value === \"string\" && value.startsWith(\"__raycast_cached_date__\")) {\n    return new Date(value.replace(\"__raycast_cached_date__\", \"\"));\n  }\n  if (typeof value === \"string\" && value.startsWith(\"__raycast_cached_buffer__\")) {\n    return Buffer.from(value.replace(\"__raycast_cached_buffer__\", \"\"), \"base64\");\n  }\n  return value;\n}\n\nexport function hash(object: any) {\n  const hashingStream = crypto.createHash(\"sha1\");\n  const hasher = typeHasher(hashingStream);\n  hasher.dispatch(object);\n\n  return hashingStream.digest(\"hex\");\n}\n", "/* eslint-disable @typescript-eslint/ban-ts-comment */\n/* eslint-disable @typescript-eslint/no-this-alias */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport crypto from \"node:crypto\";\n\n/** Check if the given function is a native function */\nfunction isNativeFunction(f: any) {\n  if (typeof f !== \"function\") {\n    return false;\n  }\n  const exp = /^function\\s+\\w*\\s*\\(\\s*\\)\\s*{\\s+\\[native code\\]\\s+}$/i;\n  return exp.exec(Function.prototype.toString.call(f)) !== null;\n}\n\nfunction hashReplacer(value: any): string {\n  if (value instanceof URLSearchParams) {\n    return value.toString();\n  }\n  return value;\n}\n\nexport function typeHasher(\n  writeTo:\n    | crypto.Hash\n    | {\n        buf: string;\n        write: (b: any) => void;\n        end: (b: any) => void;\n        read: () => string;\n      },\n  context: any[] = [],\n) {\n  function write(str: string) {\n    if (\"update\" in writeTo) {\n      return writeTo.update(str, \"utf8\");\n    } else {\n      return writeTo.write(str);\n    }\n  }\n\n  return {\n    dispatch: function (value: any) {\n      value = hashReplacer(value);\n\n      const type = typeof value;\n      if (value === null) {\n        this[\"_null\"]();\n      } else {\n        // @ts-ignore\n        this[\"_\" + type](value);\n      }\n    },\n    _object: function (object: any) {\n      const pattern = /\\[object (.*)\\]/i;\n      const objString = Object.prototype.toString.call(object);\n      let objType = pattern.exec(objString)?.[1] ?? \"unknown:[\" + objString + \"]\";\n      objType = objType.toLowerCase();\n\n      let objectNumber = null as any;\n\n      if ((objectNumber = context.indexOf(object)) >= 0) {\n        this.dispatch(\"[CIRCULAR:\" + objectNumber + \"]\");\n        return;\n      } else {\n        context.push(object);\n      }\n\n      if (Buffer.isBuffer(object)) {\n        write(\"buffer:\");\n        return write(object.toString(\"utf8\"));\n      }\n\n      if (objType !== \"object\" && objType !== \"function\" && objType !== \"asyncfunction\") {\n        // @ts-ignore\n        if (this[\"_\" + objType]) {\n          // @ts-ignore\n          this[\"_\" + objType](object);\n        } else {\n          throw new Error('Unknown object type \"' + objType + '\"');\n        }\n      } else {\n        let keys = Object.keys(object);\n        keys = keys.sort();\n        // Make sure to incorporate special properties, so\n        // Types with different prototypes will produce\n        // a different hash and objects derived from\n        // different functions (`new Foo`, `new Bar`) will\n        // produce different hashes.\n        // We never do this for native functions since some\n        // seem to break because of that.\n        if (!isNativeFunction(object)) {\n          keys.splice(0, 0, \"prototype\", \"__proto__\", \"constructor\");\n        }\n\n        write(\"object:\" + keys.length + \":\");\n        const self = this;\n        return keys.forEach(function (key) {\n          self.dispatch(key);\n          write(\":\");\n          self.dispatch(object[key]);\n          write(\",\");\n        });\n      }\n    },\n    _array: function (arr: any[], unordered: boolean) {\n      unordered = typeof unordered !== \"undefined\" ? unordered : false; // default to options.unorderedArrays\n\n      const self = this;\n      write(\"array:\" + arr.length + \":\");\n      if (!unordered || arr.length <= 1) {\n        arr.forEach(function (entry: any) {\n          self.dispatch(entry);\n        });\n        return;\n      }\n\n      // the unordered case is a little more complicated:\n      // since there is no canonical ordering on objects,\n      // i.e. {a:1} < {a:2} and {a:1} > {a:2} are both false,\n      // we first serialize each entry using a PassThrough stream\n      // before sorting.\n      // also: we cant use the same context array for all entries\n      // since the order of hashing should *not* matter. instead,\n      // we keep track of the additions to a copy of the context array\n      // and add all of them to the global context array when were done\n      let contextAdditions: any[] = [];\n      const entries = arr.map(function (entry: any) {\n        const strm = PassThrough();\n        const localContext = context.slice(); // make copy\n        const hasher = typeHasher(strm, localContext);\n        hasher.dispatch(entry);\n        // take only what was added to localContext and append it to contextAdditions\n        contextAdditions = contextAdditions.concat(localContext.slice(context.length));\n        return strm.read().toString();\n      });\n      context = context.concat(contextAdditions);\n      entries.sort();\n      this._array(entries, false);\n    },\n    _date: function (date: Date) {\n      write(\"date:\" + date.toJSON());\n    },\n    _symbol: function (sym: symbol) {\n      write(\"symbol:\" + sym.toString());\n    },\n    _error: function (err: Error) {\n      write(\"error:\" + err.toString());\n    },\n    _boolean: function (bool: boolean) {\n      write(\"bool:\" + bool.toString());\n    },\n    _string: function (string: string) {\n      write(\"string:\" + string.length + \":\");\n      write(string.toString());\n    },\n    _function: function (fn: any) {\n      write(\"fn:\");\n      if (isNativeFunction(fn)) {\n        this.dispatch(\"[native]\");\n      } else {\n        this.dispatch(fn.toString());\n      }\n\n      // Make sure we can still distinguish native functions\n      // by their name, otherwise String and Function will\n      // have the same hash\n      this.dispatch(\"function-name:\" + String(fn.name));\n\n      this._object(fn);\n    },\n    _number: function (number: number) {\n      write(\"number:\" + number.toString());\n    },\n    _xml: function (xml: any) {\n      write(\"xml:\" + xml.toString());\n    },\n    _null: function () {\n      write(\"Null\");\n    },\n    _undefined: function () {\n      write(\"Undefined\");\n    },\n    _regexp: function (regex: RegExp) {\n      write(\"regex:\" + regex.toString());\n    },\n    _uint8array: function (arr: Uint8Array) {\n      write(\"uint8array:\");\n      this.dispatch(Array.prototype.slice.call(arr));\n    },\n    _uint8clampedarray: function (arr: Uint8ClampedArray) {\n      write(\"uint8clampedarray:\");\n      this.dispatch(Array.prototype.slice.call(arr));\n    },\n    _int8array: function (arr: Int8Array) {\n      write(\"int8array:\");\n      this.dispatch(Array.prototype.slice.call(arr));\n    },\n    _uint16array: function (arr: Uint16Array) {\n      write(\"uint16array:\");\n      this.dispatch(Array.prototype.slice.call(arr));\n    },\n    _int16array: function (arr: Int16Array) {\n      write(\"int16array:\");\n      this.dispatch(Array.prototype.slice.call(arr));\n    },\n    _uint32array: function (arr: Uint32Array) {\n      write(\"uint32array:\");\n      this.dispatch(Array.prototype.slice.call(arr));\n    },\n    _int32array: function (arr: Int32Array) {\n      write(\"int32array:\");\n      this.dispatch(Array.prototype.slice.call(arr));\n    },\n    _float32array: function (arr: Float32Array) {\n      write(\"float32array:\");\n      this.dispatch(Array.prototype.slice.call(arr));\n    },\n    _float64array: function (arr: Float64Array) {\n      write(\"float64array:\");\n      this.dispatch(Array.prototype.slice.call(arr));\n    },\n    _arraybuffer: function (arr: ArrayBuffer) {\n      write(\"arraybuffer:\");\n      this.dispatch(new Uint8Array(arr));\n    },\n    _url: function (url: URL) {\n      write(\"url:\" + url.toString());\n    },\n    _map: function (map: Map<any, any>) {\n      write(\"map:\");\n      const arr = Array.from(map);\n      this._array(arr, true);\n    },\n    _set: function (set: Set<any>) {\n      write(\"set:\");\n      const arr = Array.from(set);\n      this._array(arr, true);\n    },\n    _file: function (file: any) {\n      write(\"file:\");\n      this.dispatch([file.name, file.size, file.type, file.lastModified]);\n    },\n    _blob: function () {\n      throw Error(\n        \"Hashing Blob objects is currently not supported\\n\" +\n          \"(see https://github.com/puleos/object-hash/issues/26)\\n\" +\n          'Use \"options.replacer\" or \"options.ignoreUnknown\"\\n',\n      );\n    },\n    _domwindow: function () {\n      write(\"domwindow\");\n    },\n    _bigint: function (number: bigint) {\n      write(\"bigint:\" + number.toString());\n    },\n    /* Node.js standard native objects */\n    _process: function () {\n      write(\"process\");\n    },\n    _timer: function () {\n      write(\"timer\");\n    },\n    _pipe: function () {\n      write(\"pipe\");\n    },\n    _tcp: function () {\n      write(\"tcp\");\n    },\n    _udp: function () {\n      write(\"udp\");\n    },\n    _tty: function () {\n      write(\"tty\");\n    },\n    _statwatcher: function () {\n      write(\"statwatcher\");\n    },\n    _securecontext: function () {\n      write(\"securecontext\");\n    },\n    _connection: function () {\n      write(\"connection\");\n    },\n    _zlib: function () {\n      write(\"zlib\");\n    },\n    _context: function () {\n      write(\"context\");\n    },\n    _nodescript: function () {\n      write(\"nodescript\");\n    },\n    _httpparser: function () {\n      write(\"httpparser\");\n    },\n    _dataview: function () {\n      write(\"dataview\");\n    },\n    _signal: function () {\n      write(\"signal\");\n    },\n    _fsevent: function () {\n      write(\"fsevent\");\n    },\n    _tlswrap: function () {\n      write(\"tlswrap\");\n    },\n  };\n}\n\n// Mini-implementation of stream.PassThrough\n// We are far from having need for the full implementation, and we can\n// make assumptions like \"many writes, then only one final read\"\n// and we can ignore encoding specifics\nfunction PassThrough() {\n  return {\n    buf: \"\",\n\n    write: function (b: string) {\n      this.buf += b;\n    },\n\n    end: function (b: string) {\n      this.buf += b;\n    },\n\n    read: function () {\n      return this.buf;\n    },\n  };\n}\n", "import { useEffect, useRef, useCallback } from \"react\";\nimport {\n  FunctionReturningPromise,\n  UseCachedPromiseReturnType,\n  MutatePromise,\n  FunctionReturningPaginatedPromise,\n  UnwrapReturn,\n  PaginationOptions,\n} from \"./types\";\nimport { useCachedState } from \"./useCachedState\";\nimport { usePromise, PromiseOptions } from \"./usePromise\";\nimport { useLatest } from \"./useLatest\";\nimport { hash } from \"./helpers\";\n\n// Symbol to differentiate an empty cache from `undefined`\nconst emptyCache = /* #__PURE__ */ Symbol();\n\nexport type CachedPromiseOptions<\n  T extends FunctionReturningPromise | FunctionReturningPaginatedPromise,\n  U,\n> = PromiseOptions<T> & {\n  /**\n   * The initial data if there aren't any in the Cache yet.\n   */\n  initialData?: U;\n  /**\n   * Tells the hook to keep the previous results instead of returning the initial value\n   * if there aren't any in the cache for the new arguments.\n   * This is particularly useful when used for data for a List to avoid flickering.\n   */\n  keepPreviousData?: boolean;\n};\n\n/**\n * Wraps an asynchronous function or a function that returns a Promise in another function, and returns the {@link AsyncState} corresponding to the execution of the function. The last value will be kept between command runs.\n *\n * @remark This overload should be used when working with paginated data sources.\n * @remark When paginating, only the first page will be cached.\n *\n * @example\n * ```\n * import { setTimeout } from \"node:timers/promises\";\n * import { useState } from \"react\";\n * import { List } from \"@raycast/api\";\n * import { useCachedPromise } from \"@raycast/utils\";\n *\n * export default function Command() {\n *   const [searchText, setSearchText] = useState(\"\");\n *\n *   const { isLoading, data, pagination } = useCachedPromise(\n *     (searchText: string) => async (options: { page: number }) => {\n *       await setTimeout(200);\n *       const newData = Array.from({ length: 25 }, (_v, index) => ({\n *         index,\n *         page: options.page,\n *         text: searchText,\n *       }));\n *       return { data: newData, hasMore: options.page < 10 };\n *     },\n *     [searchText],\n *   );\n *\n *   return (\n *     <List isLoading={isLoading} onSearchTextChange={setSearchText} pagination={pagination}>\n *       {data?.map((item) => (\n *         <List.Item\n *           key={`${item.page} ${item.index} ${item.text}`}\n *           title={`Page ${item.page} Item ${item.index}`}\n *           subtitle={item.text}\n *         />\n *       ))}\n *     </List>\n *   );\n * }\n * ```\n */\nexport function useCachedPromise<T extends FunctionReturningPaginatedPromise<[]>>(\n  fn: T,\n): UseCachedPromiseReturnType<UnwrapReturn<T>, undefined>;\nexport function useCachedPromise<T extends FunctionReturningPaginatedPromise, U extends any[] = any[]>(\n  fn: T,\n  args: Parameters<T>,\n  options?: CachedPromiseOptions<T, U>,\n): UseCachedPromiseReturnType<UnwrapReturn<T>, U>;\n\n/**\n * Wraps an asynchronous function or a function that returns a Promise and returns the {@link AsyncState} corresponding to the execution of the function. The last value will be kept between command runs.\n *\n * @remark The value needs to be JSON serializable.\n * @remark The function is assumed to be constant (eg. changing it won't trigger a revalidation).\n *\n * @example\n * ```\n * import { useCachedPromise } from '@raycast/utils';\n *\n * export default function Command() {\n *   const abortable = useRef<AbortController>();\n *   const { isLoading, data, revalidate } = useCachedPromise(async (url: string) => {\n *     const response = await fetch(url, { signal: abortable.current?.signal });\n *     const result = await response.text();\n *     return result\n *   },\n *   ['https://api.example'],\n *   {\n *     abortable\n *   });\n *\n *   return (\n *     <Detail\n *       isLoading={isLoading}\n *       markdown={data}\n *       actions={\n *         <ActionPanel>\n *           <Action title=\"Reload\" onAction={() => revalidate()} />\n *         </ActionPanel>\n *       }\n *     />\n *   );\n * };\n * ```\n */\nexport function useCachedPromise<T extends FunctionReturningPromise<[]>>(\n  fn: T,\n): UseCachedPromiseReturnType<UnwrapReturn<T>, undefined>;\nexport function useCachedPromise<T extends FunctionReturningPromise, U = undefined>(\n  fn: T,\n  args: Parameters<T>,\n  options?: CachedPromiseOptions<T, U>,\n): UseCachedPromiseReturnType<UnwrapReturn<T>, U>;\n\nexport function useCachedPromise<\n  T extends FunctionReturningPromise | FunctionReturningPaginatedPromise,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  U extends any[] | undefined = undefined,\n>(fn: T, args?: Parameters<T>, options?: CachedPromiseOptions<T, U>) {\n  /**\n   * The hook generates a cache key from the promise it receives & its arguments.\n   * Sometimes that's not enough to guarantee uniqueness, so hooks that build on top of `useCachedPromise` can\n   * use an `internal_cacheKeySuffix` to help it.\n   *\n   * @remark For internal use only.\n   */\n  const {\n    initialData,\n    keepPreviousData,\n    internal_cacheKeySuffix,\n    ...usePromiseOptions\n  }: CachedPromiseOptions<T, U> & { internal_cacheKeySuffix?: string } = options || {};\n  const lastUpdateFrom = useRef<\"cache\" | \"promise\">(null);\n\n  const [cachedData, mutateCache] = useCachedState<typeof emptyCache | (UnwrapReturn<T> | U)>(\n    hash(args || []) + internal_cacheKeySuffix,\n    emptyCache,\n    {\n      cacheNamespace: hash(fn),\n    },\n  );\n\n  // Use a ref to store previous returned data. Use the inital data as its inital value from the cache.\n  const laggyDataRef = useRef<Awaited<ReturnType<T>> | U>(cachedData !== emptyCache ? cachedData : (initialData as U));\n  const paginationArgsRef = useRef<PaginationOptions<UnwrapReturn<T> | U> | undefined>(undefined);\n\n  const {\n    mutate: _mutate,\n    revalidate,\n    ...state\n    // @ts-expect-error fn has the same signature in both usePromise and useCachedPromise\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  } = usePromise(fn, args || ([] as any as Parameters<T>), {\n    ...usePromiseOptions,\n    onData(data, pagination) {\n      paginationArgsRef.current = pagination;\n      if (usePromiseOptions.onData) {\n        usePromiseOptions.onData(data, pagination);\n      }\n      if (pagination && pagination.page > 0) {\n        // don't cache beyond the first page\n        return;\n      }\n      lastUpdateFrom.current = \"promise\";\n      laggyDataRef.current = data;\n      mutateCache(data);\n    },\n  });\n\n  let returnedData: U | Awaited<ReturnType<T>> | UnwrapReturn<T>;\n  const pagination = state.pagination;\n  // when paginating, only the first page gets cached, so we return the data we get from `usePromise`, because\n  // it will be accumulated.\n  if (paginationArgsRef.current && paginationArgsRef.current.page > 0 && state.data) {\n    returnedData = state.data as UnwrapReturn<T>;\n    // if the latest update if from the Promise, we keep it\n  } else if (lastUpdateFrom.current === \"promise\") {\n    returnedData = laggyDataRef.current;\n  } else if (keepPreviousData && cachedData !== emptyCache) {\n    // if we want to keep the latest data, we pick the cache but only if it's not empty\n    returnedData = cachedData;\n    if (pagination) {\n      pagination.hasMore = true;\n      pagination.pageSize = cachedData.length;\n    }\n  } else if (keepPreviousData && cachedData === emptyCache) {\n    // if the cache is empty, we will return the previous data\n    returnedData = laggyDataRef.current;\n    // there are no special cases, so either return the cache or initial data\n  } else if (cachedData !== emptyCache) {\n    returnedData = cachedData;\n    if (pagination) {\n      pagination.hasMore = true;\n      pagination.pageSize = cachedData.length;\n    }\n  } else {\n    returnedData = initialData as U;\n  }\n\n  const latestData = useLatest(returnedData);\n\n  // we rewrite the mutate function to update the cache instead\n  const mutate = useCallback<MutatePromise<Awaited<ReturnType<T>> | U>>(\n    async (asyncUpdate, options) => {\n      let dataBeforeOptimisticUpdate;\n      try {\n        if (options?.optimisticUpdate) {\n          if (typeof options?.rollbackOnError !== \"function\" && options?.rollbackOnError !== false) {\n            // keep track of the data before the optimistic update,\n            // but only if we need it (eg. only when we want to automatically rollback after)\n            dataBeforeOptimisticUpdate = structuredClone(latestData.current);\n          }\n          const data = options.optimisticUpdate(latestData.current);\n          lastUpdateFrom.current = \"cache\";\n          laggyDataRef.current = data;\n          mutateCache(data);\n        }\n        return await _mutate(asyncUpdate, { shouldRevalidateAfter: options?.shouldRevalidateAfter });\n      } catch (err) {\n        if (typeof options?.rollbackOnError === \"function\") {\n          const data = options.rollbackOnError(latestData.current);\n          lastUpdateFrom.current = \"cache\";\n          laggyDataRef.current = data;\n          mutateCache(data);\n        } else if (options?.optimisticUpdate && options?.rollbackOnError !== false) {\n          lastUpdateFrom.current = \"cache\";\n          // @ts-expect-error when undefined, it's expected\n          laggyDataRef.current = dataBeforeOptimisticUpdate;\n          // @ts-expect-error when undefined, it's expected\n          mutateCache(dataBeforeOptimisticUpdate);\n        }\n        throw err;\n      }\n    },\n    [mutateCache, _mutate, latestData, laggyDataRef, lastUpdateFrom],\n  );\n\n  useEffect(() => {\n    if (cachedData !== emptyCache) {\n      lastUpdateFrom.current = \"cache\";\n      laggyDataRef.current = cachedData;\n    }\n  }, [cachedData]);\n\n  return {\n    data: returnedData,\n    isLoading: state.isLoading,\n    error: state.error,\n    mutate: paginationArgsRef.current && paginationArgsRef.current.page > 0 ? _mutate : mutate,\n    pagination,\n    revalidate,\n  };\n}\n", "import { useCallback, useMemo, useRef } from \"react\";\nimport { useCachedPromise, CachedPromiseOptions } from \"./useCachedPromise\";\nimport { useLatest } from \"./useLatest\";\nimport { FunctionReturningPaginatedPromise, FunctionReturningPromise, UseCachedPromiseReturnType } from \"./types\";\nimport { isJSON } from \"./fetch-utils\";\nimport { hash } from \"./helpers\";\n\nasync function defaultParsing(response: Response) {\n  if (!response.ok) {\n    throw new Error(response.statusText);\n  }\n\n  const contentTypeHeader = response.headers.get(\"content-type\");\n\n  if (contentTypeHeader && isJSON(contentTypeHeader)) {\n    return await response.json();\n  }\n  return await response.text();\n}\n\nfunction defaultMapping<V, T extends unknown[]>(result: V): { data: T; hasMore?: boolean; cursor?: any } {\n  return { data: result as unknown as T, hasMore: false };\n}\n\ntype RequestInfo = string | URL | globalThis.Request;\ntype PaginatedRequestInfo = (pagination: { page: number; lastItem?: any; cursor?: any }) => RequestInfo;\n\n/**\n * Fetches the paginatedURL and returns the {@link AsyncState} corresponding to the execution of the fetch. The last value will be kept between command runs.\n *\n * @remark This overload should be used when working with paginated data sources.\n * @remark When paginating, only the first page will be cached.\n *\n * @example\n * ```\n * import { Icon, Image, List } from \"@raycast/api\";\n * import { useFetch } from \"@raycast/utils\";\n * import { useState } from \"react\";\n *\n * type SearchResult = { companies: Company[]; page: number; totalPages: number };\n * type Company = { id: number; name: string; smallLogoUrl?: string };\n * export default function Command() {\n *   const [searchText, setSearchText] = useState(\"\");\n *   const { isLoading, data, pagination } = useFetch(\n *     (options) =>\n *       \"https://api.ycombinator.com/v0.1/companies?\" +\n *       new URLSearchParams({ page: String(options.page + 1), q: searchText }).toString(),\n *     {\n *       mapResult(result: SearchResult) {\n *         return {\n *           data: result.companies,\n *           hasMore: result.page < result.totalPages,\n *         };\n *       },\n *       keepPreviousData: true,\n *       initialData: [],\n *     },\n *   );\n *\n *   return (\n *     <List isLoading={isLoading} pagination={pagination} onSearchTextChange={setSearchText}>\n *       {data.map((company) => (\n *         <List.Item\n *           key={company.id}\n *           icon={{ source: company.smallLogoUrl ?? Icon.MinusCircle, mask: Image.Mask.RoundedRectangle }}\n *           title={company.name}\n *         />\n *       ))}\n *     </List>\n *   );\n * }\n * ```\n */\nexport function useFetch<V = unknown, U = undefined, T extends unknown[] = unknown[]>(\n  url: PaginatedRequestInfo,\n  options: RequestInit & {\n    mapResult: (result: V) => { data: T; hasMore?: boolean; cursor?: any };\n    parseResponse?: (response: Response) => Promise<V>;\n  } & Omit<CachedPromiseOptions<(url: RequestInfo, options?: RequestInit) => Promise<T>, U>, \"abortable\">,\n): UseCachedPromiseReturnType<T, U>;\n/**\n * Fetch the URL and returns the {@link AsyncState} corresponding to the execution of the fetch. The last value will be kept between command runs.\n *\n * @example\n * ```\n * import { useFetch } from '@raycast/utils';\n *\n * export default function Command() {\n *   const { isLoading, data, revalidate } = useFetch('https://api.example');\n *\n *   return (\n *     <Detail\n *       isLoading={isLoading}\n *       markdown={data}\n *       actions={\n *         <ActionPanel>\n *           <Action title=\"Reload\" onAction={() => revalidate()} />\n *         </ActionPanel>\n *       }\n *     />\n *   );\n * };\n * ```\n */\nexport function useFetch<V = unknown, U = undefined, T = V>(\n  url: RequestInfo,\n  options?: RequestInit & {\n    mapResult?: (result: V) => { data: T; hasMore?: boolean; cursor?: any };\n    parseResponse?: (response: Response) => Promise<V>;\n  } & Omit<CachedPromiseOptions<(url: RequestInfo, options?: RequestInit) => Promise<T>, U>, \"abortable\">,\n): UseCachedPromiseReturnType<T, U> & { pagination: undefined };\n\nexport function useFetch<V = unknown, U = undefined, T extends unknown[] = unknown[]>(\n  url: RequestInfo | PaginatedRequestInfo,\n  options?: RequestInit & {\n    mapResult?: (result: V) => { data: T; hasMore?: boolean; cursor?: any };\n    parseResponse?: (response: Response) => Promise<V>;\n  } & Omit<CachedPromiseOptions<(url: RequestInfo, options?: RequestInit) => Promise<T>, U>, \"abortable\">,\n): UseCachedPromiseReturnType<T, U> {\n  const {\n    parseResponse,\n    mapResult,\n    initialData,\n    execute,\n    keepPreviousData,\n    onError,\n    onData,\n    onWillExecute,\n    failureToastOptions,\n    ...fetchOptions\n  } = options || {};\n\n  const useCachedPromiseOptions: CachedPromiseOptions<(url: RequestInfo, options?: RequestInit) => Promise<T>, U> = {\n    initialData,\n    execute,\n    keepPreviousData,\n    onError,\n    onData,\n    onWillExecute,\n    failureToastOptions,\n  };\n\n  const parseResponseRef = useLatest(parseResponse || defaultParsing);\n  const mapResultRef = useLatest(mapResult || defaultMapping);\n  const urlRef = useRef<RequestInfo | PaginatedRequestInfo>(null);\n  const firstPageUrlRef = useRef<RequestInfo | undefined>(null);\n  const firstPageUrl = typeof url === \"function\" ? url({ page: 0 }) : undefined;\n  /**\n   * When paginating, `url` is a `PaginatedRequestInfo`, so we only want to update the ref when the `firstPageUrl` changes.\n   * When not paginating, `url` is a `RequestInfo`, so we want to update the ref whenever `url` changes.\n   */\n  if (!urlRef.current || typeof firstPageUrlRef.current === \"undefined\" || firstPageUrlRef.current !== firstPageUrl) {\n    urlRef.current = url;\n  }\n  firstPageUrlRef.current = firstPageUrl;\n  const abortable = useRef<AbortController>(null);\n\n  const paginatedFn: FunctionReturningPaginatedPromise<[PaginatedRequestInfo, typeof fetchOptions], T> = useCallback(\n    (url: PaginatedRequestInfo, options?: RequestInit) => async (pagination: { page: number }) => {\n      const res = await fetch(url(pagination), { signal: abortable.current?.signal, ...options });\n      const parsed = (await parseResponseRef.current(res)) as V;\n      return mapResultRef.current?.(parsed);\n    },\n    [parseResponseRef, mapResultRef],\n  );\n  const fn: FunctionReturningPromise<[RequestInfo, RequestInit?], T> = useCallback(\n    async (url: RequestInfo, options?: RequestInit) => {\n      const res = await fetch(url, { signal: abortable.current?.signal, ...options });\n      const parsed = (await parseResponseRef.current(res)) as V;\n      const mapped = mapResultRef.current(parsed);\n      return mapped?.data as unknown as T;\n    },\n    [parseResponseRef, mapResultRef],\n  );\n\n  const promise = useMemo(() => {\n    if (firstPageUrlRef.current) {\n      return paginatedFn;\n    }\n    return fn;\n  }, [firstPageUrlRef, fn, paginatedFn]);\n\n  // @ts-expect-error lastItem can't be inferred properly\n  return useCachedPromise(promise, [urlRef.current as PaginatedRequestInfo, fetchOptions], {\n    ...useCachedPromiseOptions,\n    internal_cacheKeySuffix: firstPageUrlRef.current + hash(mapResultRef.current) + hash(parseResponseRef.current),\n    abortable,\n  });\n}\n", "export function isJSON(contentTypeHeader: string | null | undefined): boolean {\n  if (contentTypeHeader) {\n    const mediaType = parseContentType(contentTypeHeader);\n\n    if (!mediaType) {\n      return false;\n    }\n\n    if (mediaType.subtype === \"json\") {\n      return true;\n    }\n\n    if (mediaType.suffix === \"json\") {\n      return true;\n    }\n\n    if (mediaType.suffix && /\\bjson\\b/i.test(mediaType.suffix)) {\n      return true;\n    }\n\n    if (mediaType.subtype && /\\bjson\\b/i.test(mediaType.subtype)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * RegExp to match type in RFC 6838 with an optional trailing `;` because some Apple APIs returns one...\n *\n * type-name = restricted-name\n * subtype-name = restricted-name\n * restricted-name = restricted-name-first *126restricted-name-chars\n * restricted-name-first  = ALPHA / DIGIT\n * restricted-name-chars  = ALPHA / DIGIT / \"!\" / \"#\" /\n *                          \"$\" / \"&\" / \"-\" / \"^\" / \"_\"\n * restricted-name-chars =/ \".\" ; Characters before first dot always\n *                              ; specify a facet name\n * restricted-name-chars =/ \"+\" ; Characters after last plus always\n *                              ; specify a structured syntax suffix\n * ALPHA =  %x41-5A / %x61-7A   ; A-Z / a-z\n * DIGIT =  %x30-39             ; 0-9\n */\nconst MEDIA_TYPE_REGEXP = /^([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126});?$/;\n\nfunction parseContentType(header: string) {\n  const headerDelimitationindex = header.indexOf(\";\");\n  const contentType = headerDelimitationindex !== -1 ? header.slice(0, headerDelimitationindex).trim() : header.trim();\n\n  const match = MEDIA_TYPE_REGEXP.exec(contentType.toLowerCase().toLowerCase());\n\n  if (!match) {\n    return;\n  }\n\n  const type = match[1];\n  let subtype = match[2];\n  let suffix;\n\n  // suffix after last +\n  const index = subtype.lastIndexOf(\"+\");\n  if (index !== -1) {\n    suffix = subtype.substring(index + 1);\n    subtype = subtype.substring(0, index);\n  }\n\n  return { type, subtype, suffix };\n}\n", "/*\n * Inspired by Execa\n */\n\nimport childProcess from \"node:child_process\";\nimport { useCallback, useRef } from \"react\";\n\nimport { useCachedPromise, CachedPromiseOptions } from \"./useCachedPromise\";\nimport { useLatest } from \"./useLatest\";\nimport { UseCachedPromiseReturnType } from \"./types\";\nimport {\n  getSpawnedPromise,\n  getSpawnedResult,\n  handleOutput,\n  defaultParsing,\n  ParseExecOutputHandler,\n} from \"./exec-utils\";\n\ntype ExecOptions = {\n  /**\n   * If `true`, runs the command inside of a shell. Uses `/bin/sh`. A different shell can be specified as a string. The shell should understand the `-c` switch.\n   *\n   * We recommend against using this option since it is:\n   * - not cross-platform, encouraging shell-specific syntax.\n   * - slower, because of the additional shell interpretation.\n   * - unsafe, potentially allowing command injection.\n   *\n   * @default false\n   */\n  shell?: boolean | string;\n  /**\n   * Strip the final newline character from the output.\n   * @default true\n   */\n  stripFinalNewline?: boolean;\n  /**\n   * Current working directory of the child process.\n   * @default process.cwd()\n   */\n  cwd?: string;\n  /**\n   * Environment key-value pairs. Extends automatically from `process.env`.\n   * @default process.env\n   */\n  env?: NodeJS.ProcessEnv;\n  /**\n   * Specify the character encoding used to decode the stdout and stderr output. If set to `\"buffer\"`, then stdout and stderr will be a Buffer instead of a string.\n   *\n   * @default \"utf8\"\n   */\n  encoding?: BufferEncoding | \"buffer\";\n  /**\n   * Write some input to the `stdin` of your binary.\n   */\n  input?: string | Buffer;\n  /** If timeout is greater than `0`, the parent will send the signal `SIGTERM` if the child runs longer than timeout milliseconds.\n   *\n   * @default 10000\n   */\n  timeout?: number;\n};\n\nconst SPACES_REGEXP = / +/g;\nfunction parseCommand(command: string, args?: string[]) {\n  if (args) {\n    return [command, ...args];\n  }\n  const tokens: string[] = [];\n  for (const token of command.trim().split(SPACES_REGEXP)) {\n    // Allow spaces to be escaped by a backslash if not meant as a delimiter\n    const previousToken = tokens[tokens.length - 1];\n    if (previousToken && previousToken.endsWith(\"\\\\\")) {\n      // Merge previous token with current one\n      tokens[tokens.length - 1] = `${previousToken.slice(0, -1)} ${token}`;\n    } else {\n      tokens.push(token);\n    }\n  }\n\n  return tokens;\n}\n\ntype ExecCachedPromiseOptions<T, U> = Omit<\n  CachedPromiseOptions<\n    (_command: string, _args: string[], _options?: ExecOptions, input?: string | Buffer) => Promise<T>,\n    U\n  >,\n  \"abortable\"\n>;\n\n/**\n * Executes a command and returns the {@link AsyncState} corresponding to the execution of the command. The last value will be kept between command runs.\n *\n * @remark When specifying the arguments via the `command` string, if the file or an argument of the command contains spaces, they must be escaped with backslashes. This matters especially if `command` is not a constant but a variable, for example with `__dirname` or `process.cwd()`. Except for spaces, no escaping/quoting is needed.\n *\n * The `shell` option must be used if the command uses shell-specific features (for example, `&&` or `||`), as opposed to being a simple file followed by its arguments.\n *\n * @example\n * ```\n * import { useExec } from '@raycast/utils';\n *\n * export default function Command() {\n *   const { isLoading, data, revalidate } = useExec(\"brew\", [\"info\", \"--json=v2\", \"--installed\"]);\n *   const results = useMemo<{}[]>(() => JSON.parse(data || \"[]\"), [data]);\n *\n *   return (\n *     <List isLoading={isLoading}>\n *      {(data || []).map((item) => (\n *        <List.Item key={item.id} title={item.name} />\n *      ))}\n *    </List>\n *   );\n * };\n * ```\n */\nexport function useExec<T = Buffer, U = undefined>(\n  command: string,\n  options: {\n    parseOutput?: ParseExecOutputHandler<T, Buffer, ExecOptions>;\n  } & ExecOptions & {\n      encoding: \"buffer\";\n    } & ExecCachedPromiseOptions<T, U>,\n): UseCachedPromiseReturnType<T, U>;\nexport function useExec<T = string, U = undefined>(\n  command: string,\n  options?: {\n    parseOutput?: ParseExecOutputHandler<T, string, ExecOptions>;\n  } & ExecOptions & {\n      encoding?: BufferEncoding;\n    } & ExecCachedPromiseOptions<T, U>,\n): UseCachedPromiseReturnType<T, U>;\nexport function useExec<T = Buffer, U = undefined>(\n  file: string,\n  /**\n   * The arguments to pass to the file. No escaping/quoting is needed.\n   *\n   * If defined, the commands needs to be a file to execute. If undefined, the arguments will be parsed from the command.\n   */\n  args: string[],\n  options: {\n    parseOutput?: ParseExecOutputHandler<T, Buffer, ExecOptions>;\n  } & ExecOptions & {\n      encoding: \"buffer\";\n    } & ExecCachedPromiseOptions<T, U>,\n): UseCachedPromiseReturnType<T, U>;\nexport function useExec<T = string, U = undefined>(\n  file: string,\n  /**\n   * The arguments to pass to the file. No escaping/quoting is needed.\n   *\n   * If defined, the commands needs to be a file to execute. If undefined, the arguments will be parsed from the command.\n   */\n  args: string[],\n  options?: {\n    parseOutput?: ParseExecOutputHandler<T, string, ExecOptions>;\n  } & ExecOptions & {\n      encoding?: BufferEncoding;\n    } & ExecCachedPromiseOptions<T, U>,\n): UseCachedPromiseReturnType<T, U>;\nexport function useExec<T, U = undefined>(\n  command: string,\n  optionsOrArgs?:\n    | string[]\n    | ({\n        parseOutput?: ParseExecOutputHandler<T, Buffer, ExecOptions> | ParseExecOutputHandler<T, string, ExecOptions>;\n      } & ExecOptions &\n        ExecCachedPromiseOptions<T, U>),\n  options?: {\n    parseOutput?: ParseExecOutputHandler<T, Buffer, ExecOptions> | ParseExecOutputHandler<T, string, ExecOptions>;\n  } & ExecOptions &\n    ExecCachedPromiseOptions<T, U>,\n): UseCachedPromiseReturnType<T, U> {\n  const {\n    parseOutput,\n    input,\n    onData,\n    onWillExecute,\n    initialData,\n    execute,\n    keepPreviousData,\n    onError,\n    failureToastOptions,\n    ...execOptions\n  } = Array.isArray(optionsOrArgs) ? options || {} : optionsOrArgs || {};\n\n  const useCachedPromiseOptions: ExecCachedPromiseOptions<T, U> = {\n    initialData,\n    execute,\n    keepPreviousData,\n    onError,\n    onData,\n    onWillExecute,\n    failureToastOptions,\n  };\n\n  const abortable = useRef<AbortController>(null);\n  const parseOutputRef = useLatest(parseOutput || defaultParsing);\n\n  const fn = useCallback(\n    async (_command: string, _args: string[], _options?: ExecOptions, input?: string | Buffer) => {\n      const [file, ...args] = parseCommand(_command, _args);\n      const command = [file, ...args].join(\" \");\n\n      const options = {\n        stripFinalNewline: true,\n        ..._options,\n        timeout: _options?.timeout || 10000,\n        signal: abortable.current?.signal,\n        encoding: _options?.encoding === null ? \"buffer\" : _options?.encoding || \"utf8\",\n        env: { PATH: \"/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin\", ...process.env, ..._options?.env },\n      };\n\n      const spawned = childProcess.spawn(file, args, options);\n      const spawnedPromise = getSpawnedPromise(spawned, options);\n\n      if (input) {\n        spawned.stdin.end(input);\n      }\n\n      const [{ error, exitCode, signal, timedOut }, stdoutResult, stderrResult] = await getSpawnedResult(\n        spawned,\n        options,\n        spawnedPromise,\n      );\n      const stdout = handleOutput(options, stdoutResult);\n      const stderr = handleOutput(options, stderrResult);\n\n      return parseOutputRef.current({\n        // @ts-expect-error too many generics, I give up\n        stdout,\n        // @ts-expect-error too many generics, I give up\n        stderr,\n        error,\n        exitCode,\n        signal,\n        timedOut,\n        command,\n        options,\n        parentError: new Error(),\n      }) as T;\n    },\n    [parseOutputRef],\n  );\n\n  // @ts-expect-error T can't be a Promise so it's actually the same\n  return useCachedPromise(fn, [command, Array.isArray(optionsOrArgs) ? optionsOrArgs : [], execOptions, input], {\n    ...useCachedPromiseOptions,\n    abortable,\n  });\n}\n", "import childProcess from \"node:child_process\";\nimport { constants as BufferConstants } from \"node:buffer\";\nimport Stream from \"node:stream\";\nimport { promisify } from \"node:util\";\nimport { onExit } from \"./vendors/signal-exit\";\n\nexport type SpawnedPromise = Promise<{\n  exitCode: number | null;\n  error?: Error;\n  signal: NodeJS.Signals | null;\n  timedOut: boolean;\n}>;\n\nexport function getSpawnedPromise(\n  spawned: childProcess.ChildProcessWithoutNullStreams,\n  { timeout }: { timeout?: number } = {},\n): SpawnedPromise {\n  const spawnedPromise: SpawnedPromise = new Promise((resolve, reject) => {\n    spawned.on(\"exit\", (exitCode, signal) => {\n      resolve({ exitCode, signal, timedOut: false });\n    });\n\n    spawned.on(\"error\", (error) => {\n      reject(error);\n    });\n\n    if (spawned.stdin) {\n      spawned.stdin.on(\"error\", (error) => {\n        reject(error);\n      });\n    }\n  });\n\n  const removeExitHandler = onExit(() => {\n    spawned.kill();\n  });\n\n  if (timeout === 0 || timeout === undefined) {\n    return spawnedPromise.finally(() => removeExitHandler());\n  }\n\n  let timeoutId: NodeJS.Timeout;\n  const timeoutPromise: SpawnedPromise = new Promise((_resolve, reject) => {\n    timeoutId = setTimeout(() => {\n      spawned.kill(\"SIGTERM\");\n      reject(Object.assign(new Error(\"Timed out\"), { timedOut: true, signal: \"SIGTERM\" }));\n    }, timeout);\n  });\n\n  const safeSpawnedPromise = spawnedPromise.finally(() => {\n    clearTimeout(timeoutId);\n  });\n\n  return Promise.race([timeoutPromise, safeSpawnedPromise]).finally(() => removeExitHandler());\n}\n\nclass MaxBufferError extends Error {\n  constructor() {\n    super(\"The output is too big\");\n    this.name = \"MaxBufferError\";\n  }\n}\n\nfunction bufferStream<T extends string | Buffer>(options: { encoding: BufferEncoding | \"buffer\" }) {\n  const { encoding } = options;\n  const isBuffer = encoding === \"buffer\";\n\n  // @ts-expect-error missing the methods we are adding below\n  const stream: Stream.PassThrough & { getBufferedValue: () => T; getBufferedLength: () => number } =\n    new Stream.PassThrough({ objectMode: false });\n\n  if (encoding && encoding !== \"buffer\") {\n    stream.setEncoding(encoding);\n  }\n\n  let length = 0;\n  const chunks: any[] = [];\n\n  stream.on(\"data\", (chunk) => {\n    chunks.push(chunk);\n\n    length += chunk.length;\n  });\n\n  stream.getBufferedValue = () => {\n    return (isBuffer ? Buffer.concat(chunks, length) : chunks.join(\"\")) as T;\n  };\n\n  stream.getBufferedLength = () => length;\n\n  return stream;\n}\n\nasync function getStream<T extends string | Buffer>(\n  inputStream: Stream.Readable,\n  options: { encoding: BufferEncoding | \"buffer\" },\n) {\n  const stream = bufferStream<T>(options);\n\n  await new Promise<void>((resolve, reject) => {\n    const rejectPromise = (error: Error & { bufferedData?: T }) => {\n      // Don't retrieve an oversized buffer.\n      if (error && stream.getBufferedLength() <= BufferConstants.MAX_LENGTH) {\n        error.bufferedData = stream.getBufferedValue();\n      }\n\n      reject(error);\n    };\n\n    (async () => {\n      try {\n        await promisify(Stream.pipeline)(inputStream, stream);\n        resolve();\n      } catch (error) {\n        rejectPromise(error as any);\n      }\n    })();\n\n    stream.on(\"data\", () => {\n      // 80mb\n      if (stream.getBufferedLength() > 1000 * 1000 * 80) {\n        rejectPromise(new MaxBufferError());\n      }\n    });\n  });\n\n  return stream.getBufferedValue();\n}\n\n// On failure, `result.stdout|stderr` should contain the currently buffered stream\nasync function getBufferedData<T extends string | Buffer>(stream: Stream.Readable, streamPromise: Promise<T>) {\n  stream.destroy();\n\n  try {\n    return await streamPromise;\n  } catch (error) {\n    return (error as any as { bufferedData: T }).bufferedData;\n  }\n}\n\nexport async function getSpawnedResult<T extends string | Buffer>(\n  { stdout, stderr }: childProcess.ChildProcessWithoutNullStreams,\n  { encoding }: { encoding: BufferEncoding | \"buffer\" },\n  processDone: SpawnedPromise,\n) {\n  const stdoutPromise = getStream<T>(stdout, { encoding });\n  const stderrPromise = getStream<T>(stderr, { encoding });\n\n  try {\n    return await Promise.all([processDone, stdoutPromise, stderrPromise]);\n  } catch (error: any) {\n    return Promise.all([\n      {\n        error: error as Error,\n        exitCode: null,\n        signal: error.signal as NodeJS.Signals | null,\n        timedOut: (error.timedOut as boolean) || false,\n      },\n      getBufferedData(stdout, stdoutPromise),\n      getBufferedData(stderr, stderrPromise),\n    ]);\n  }\n}\n\nfunction stripFinalNewline<T extends string | Buffer>(input: T) {\n  const LF = typeof input === \"string\" ? \"\\n\" : \"\\n\".charCodeAt(0);\n  const CR = typeof input === \"string\" ? \"\\r\" : \"\\r\".charCodeAt(0);\n\n  if (input[input.length - 1] === LF) {\n    // @ts-expect-error we are doing some nasty stuff here\n    input = input.slice(0, -1);\n  }\n\n  if (input[input.length - 1] === CR) {\n    // @ts-expect-error we are doing some nasty stuff here\n    input = input.slice(0, -1);\n  }\n\n  return input;\n}\n\nexport function handleOutput<T extends string | Buffer>(options: { stripFinalNewline?: boolean }, value: T) {\n  if (options.stripFinalNewline) {\n    return stripFinalNewline(value);\n  }\n\n  return value;\n}\n\nfunction getErrorPrefix({\n  timedOut,\n  timeout,\n  signal,\n  exitCode,\n}: {\n  exitCode: number | null;\n  signal: NodeJS.Signals | null;\n  timedOut: boolean;\n  timeout?: number;\n}) {\n  if (timedOut) {\n    return `timed out after ${timeout} milliseconds`;\n  }\n\n  if (signal !== undefined && signal !== null) {\n    return `was killed with ${signal}`;\n  }\n\n  if (exitCode !== undefined && exitCode !== null) {\n    return `failed with exit code ${exitCode}`;\n  }\n\n  return \"failed\";\n}\n\nfunction makeError({\n  stdout,\n  stderr,\n  error,\n  signal,\n  exitCode,\n  command,\n  timedOut,\n  options,\n  parentError,\n}: {\n  stdout: string | Buffer;\n  stderr: string | Buffer;\n  error?: Error;\n  exitCode: number | null;\n  signal: NodeJS.Signals | null;\n  timedOut: boolean;\n  command: string;\n  options?: { timeout?: number };\n  parentError: Error;\n}) {\n  const prefix = getErrorPrefix({ timedOut, timeout: options?.timeout, signal, exitCode });\n  const execaMessage = `Command ${prefix}: ${command}`;\n  const shortMessage = error ? `${execaMessage}\\n${error.message}` : execaMessage;\n  const message = [shortMessage, stderr, stdout].filter(Boolean).join(\"\\n\");\n\n  if (error) {\n    // @ts-expect-error not on Error\n    error.originalMessage = error.message;\n  } else {\n    error = parentError;\n  }\n\n  error.message = message;\n\n  // @ts-expect-error not on Error\n  error.shortMessage = shortMessage;\n  // @ts-expect-error not on Error\n  error.command = command;\n  // @ts-expect-error not on Error\n  error.exitCode = exitCode;\n  // @ts-expect-error not on Error\n  error.signal = signal;\n  // @ts-expect-error not on Error\n  error.stdout = stdout;\n  // @ts-expect-error not on Error\n  error.stderr = stderr;\n\n  if (\"bufferedData\" in error) {\n    delete error[\"bufferedData\"];\n  }\n\n  return error;\n}\n\nexport type ParseExecOutputHandler<\n  T,\n  DecodedOutput extends string | Buffer = string | Buffer,\n  Options = unknown,\n> = (args: {\n  /** The output of the process on stdout. */\n  stdout: DecodedOutput;\n  /** The output of the process on stderr. */\n  stderr: DecodedOutput;\n  error?: Error;\n  /** The numeric exit code of the process that was run. */\n  exitCode: number | null;\n  /**\n   * The name of the signal that was used to terminate the process. For example, SIGFPE.\n   *\n   * If a signal terminated the process, this property is defined. Otherwise it is null.\n   */\n  signal: NodeJS.Signals | null;\n  /** Whether the process timed out. */\n  timedOut: boolean;\n  /** The command that was run, for logging purposes. */\n  command: string;\n  options?: Options;\n}) => T;\n\nexport function defaultParsing<T extends string | Buffer>({\n  stdout,\n  stderr,\n  error,\n  exitCode,\n  signal,\n  timedOut,\n  command,\n  options,\n  parentError,\n}: {\n  stdout: T;\n  stderr: T;\n  error?: Error;\n  exitCode: number | null;\n  signal: NodeJS.Signals | null;\n  timedOut: boolean;\n  command: string;\n  options?: { timeout?: number };\n  parentError: Error;\n}) {\n  if (error || exitCode !== 0 || signal !== null) {\n    const returnedError = makeError({\n      error,\n      exitCode,\n      signal,\n      stdout,\n      stderr,\n      command,\n      timedOut,\n      options,\n      parentError,\n    });\n\n    throw returnedError;\n  }\n\n  return stdout;\n}\n", "/* eslint-disable @typescript-eslint/ban-ts-comment */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n// Note: since nyc uses this module to output coverage, any lines\n// that are in the direct sync flow of nyc's outputCoverage are\n// ignored, since we can never get coverage for them.\n// grab a reference to node's real process object right away\n\nconst processOk = (process: any) =>\n  !!process &&\n  typeof process === \"object\" &&\n  typeof process.removeListener === \"function\" &&\n  typeof process.emit === \"function\" &&\n  typeof process.reallyExit === \"function\" &&\n  typeof process.listeners === \"function\" &&\n  typeof process.kill === \"function\" &&\n  typeof process.pid === \"number\" &&\n  typeof process.on === \"function\";\nconst kExitEmitter = /* #__PURE__ */ Symbol.for(\"signal-exit emitter\");\n// teeny special purpose ee\nclass Emitter {\n  emitted = {\n    afterExit: false,\n    exit: false,\n  };\n  listeners = {\n    afterExit: [],\n    exit: [],\n  };\n  count = 0;\n  id = Math.random();\n  constructor() {\n    // @ts-ignore\n    if (global[kExitEmitter]) {\n      // @ts-ignore\n      return global[kExitEmitter];\n    }\n    Object.defineProperty(global, kExitEmitter, {\n      value: this,\n      writable: false,\n      enumerable: false,\n      configurable: false,\n    });\n  }\n  on(ev: any, fn: any) {\n    // @ts-ignore\n    this.listeners[ev].push(fn);\n  }\n  removeListener(ev: any, fn: any) {\n    // @ts-ignore\n    const list = this.listeners[ev];\n    const i = list.indexOf(fn);\n    /* c8 ignore start */\n    if (i === -1) {\n      return;\n    }\n    /* c8 ignore stop */\n    if (i === 0 && list.length === 1) {\n      list.length = 0;\n    } else {\n      list.splice(i, 1);\n    }\n  }\n  emit(ev: any, code: any, signal: any): any {\n    // @ts-ignore\n    if (this.emitted[ev]) {\n      return false;\n    }\n    // @ts-ignore\n    this.emitted[ev] = true;\n    let ret = false;\n    // @ts-ignore\n    for (const fn of this.listeners[ev]) {\n      ret = fn(code, signal) === true || ret;\n    }\n    if (ev === \"exit\") {\n      ret = this.emit(\"afterExit\", code, signal) || ret;\n    }\n    return ret;\n  }\n}\n\nclass SignalExitFallback {\n  onExit() {\n    return () => {};\n  }\n  load() {}\n  unload() {}\n}\nclass SignalExit {\n  // \"SIGHUP\" throws an `ENOSYS` error on Windows,\n  // so use a supported signal instead\n  /* c8 ignore start */\n  // @ts-ignore\n  #hupSig = process.platform === \"win32\" ? \"SIGINT\" : \"SIGHUP\";\n  /* c8 ignore stop */\n  #emitter = new Emitter();\n  #process: any;\n  #originalProcessEmit: any;\n  #originalProcessReallyExit: any;\n  #sigListeners = {};\n  #loaded = false;\n  #signals: string[] = [];\n  constructor(process: any) {\n    /**\n     * This is not the set of all possible signals.\n     *\n     * It IS, however, the set of all signals that trigger\n     * an exit on either Linux or BSD systems.  Linux is a\n     * superset of the signal names supported on BSD, and\n     * the unknown signals just fail to register, so we can\n     * catch that easily enough.\n     *\n     * Windows signals are a different set, since there are\n     * signals that terminate Windows processes, but don't\n     * terminate (or don't even exist) on Posix systems.\n     *\n     * Don't bother with SIGKILL.  It's uncatchable, which\n     * means that we can't fire any callbacks anyway.\n     *\n     * If a user does happen to register a handler on a non-\n     * fatal signal like SIGWINCH or something, and then\n     * exit, it'll end up firing `process.emit('exit')`, so\n     * the handler will be fired anyway.\n     *\n     * SIGBUS, SIGFPE, SIGSEGV and SIGILL, when not raised\n     * artificially, inherently leave the process in a\n     * state from which it is not safe to try and enter JS\n     * listeners.\n     */\n    this.#signals.push(\"SIGHUP\", \"SIGINT\", \"SIGTERM\");\n    if (globalThis.process.platform !== \"win32\") {\n      this.#signals.push(\n        \"SIGALRM\",\n        \"SIGABRT\",\n        \"SIGVTALRM\",\n        \"SIGXCPU\",\n        \"SIGXFSZ\",\n        \"SIGUSR2\",\n        \"SIGTRAP\",\n        \"SIGSYS\",\n        \"SIGQUIT\",\n        \"SIGIOT\",\n        // should detect profiler and enable/disable accordingly.\n        // see #21\n        // 'SIGPROF'\n      );\n    }\n    if (globalThis.process.platform === \"linux\") {\n      this.#signals.push(\"SIGIO\", \"SIGPOLL\", \"SIGPWR\", \"SIGSTKFLT\");\n    }\n    this.#process = process;\n    // { <signal>: <listener fn>, ... }\n    this.#sigListeners = {};\n    for (const sig of this.#signals) {\n      // @ts-ignore\n      this.#sigListeners[sig] = () => {\n        // If there are no other listeners, an exit is coming!\n        // Simplest way: remove us and then re-send the signal.\n        // We know that this will kill the process, so we can\n        // safely emit now.\n        const listeners = this.#process.listeners(sig);\n        let { count } = this.#emitter;\n        // This is a workaround for the fact that signal-exit v3 and signal\n        // exit v4 are not aware of each other, and each will attempt to let\n        // the other handle it, so neither of them do. To correct this, we\n        // detect if we're the only handler *except* for previous versions\n        // of signal-exit, and increment by the count of listeners it has\n        // created.\n        /* c8 ignore start */\n        const p = process;\n        if (typeof p.__signal_exit_emitter__ === \"object\" && typeof p.__signal_exit_emitter__.count === \"number\") {\n          count += p.__signal_exit_emitter__.count;\n        }\n        /* c8 ignore stop */\n        if (listeners.length === count) {\n          this.unload();\n          const ret = this.#emitter.emit(\"exit\", null, sig);\n          /* c8 ignore start */\n          const s = sig === \"SIGHUP\" ? this.#hupSig : sig;\n          if (!ret) process.kill(process.pid, s);\n          /* c8 ignore stop */\n        }\n      };\n    }\n    this.#originalProcessReallyExit = process.reallyExit;\n    this.#originalProcessEmit = process.emit;\n  }\n  onExit(cb: any, opts: any) {\n    /* c8 ignore start */\n    if (!processOk(this.#process)) {\n      return () => {};\n    }\n    /* c8 ignore stop */\n    if (this.#loaded === false) {\n      this.load();\n    }\n    const ev = opts?.alwaysLast ? \"afterExit\" : \"exit\";\n    this.#emitter.on(ev, cb);\n    return () => {\n      this.#emitter.removeListener(ev, cb);\n      if (this.#emitter.listeners[\"exit\"].length === 0 && this.#emitter.listeners[\"afterExit\"].length === 0) {\n        this.unload();\n      }\n    };\n  }\n  load() {\n    if (this.#loaded) {\n      return;\n    }\n    this.#loaded = true;\n    // This is the number of onSignalExit's that are in play.\n    // It's important so that we can count the correct number of\n    // listeners on signals, and don't wait for the other one to\n    // handle it instead of us.\n    this.#emitter.count += 1;\n    for (const sig of this.#signals) {\n      try {\n        // @ts-ignore\n        const fn = this.#sigListeners[sig];\n        if (fn) this.#process.on(sig, fn);\n      } catch (_) {\n        // no-op\n      }\n    }\n    this.#process.emit = (ev: any, ...a: any) => {\n      return this.#processEmit(ev, ...a);\n    };\n    this.#process.reallyExit = (code: any) => {\n      return this.#processReallyExit(code);\n    };\n  }\n  unload() {\n    if (!this.#loaded) {\n      return;\n    }\n    this.#loaded = false;\n    this.#signals.forEach((sig) => {\n      // @ts-ignore\n      const listener = this.#sigListeners[sig];\n      /* c8 ignore start */\n      if (!listener) {\n        throw new Error(\"Listener not defined for signal: \" + sig);\n      }\n      /* c8 ignore stop */\n      try {\n        this.#process.removeListener(sig, listener);\n        /* c8 ignore start */\n      } catch (_) {\n        // no-op\n      }\n      /* c8 ignore stop */\n    });\n    this.#process.emit = this.#originalProcessEmit;\n    this.#process.reallyExit = this.#originalProcessReallyExit;\n    this.#emitter.count -= 1;\n  }\n  #processReallyExit(code: any) {\n    /* c8 ignore start */\n    if (!processOk(this.#process)) {\n      return 0;\n    }\n    this.#process.exitCode = code || 0;\n    /* c8 ignore stop */\n    this.#emitter.emit(\"exit\", this.#process.exitCode, null);\n    return this.#originalProcessReallyExit.call(this.#process, this.#process.exitCode);\n  }\n  #processEmit(ev: any, ...args: any) {\n    const og = this.#originalProcessEmit;\n    if (ev === \"exit\" && processOk(this.#process)) {\n      if (typeof args[0] === \"number\") {\n        this.#process.exitCode = args[0];\n        /* c8 ignore start */\n      }\n      /* c8 ignore start */\n      const ret = og.call(this.#process, ev, ...args);\n      /* c8 ignore start */\n      this.#emitter.emit(\"exit\", this.#process.exitCode, null);\n      /* c8 ignore stop */\n      return ret;\n    } else {\n      return og.call(this.#process, ev, ...args);\n    }\n  }\n}\n\nlet signalExit: SignalExit | SignalExitFallback | null = null;\n\nexport const onExit = (\n  cb: any,\n  opts?: {\n    alwaysLast?: boolean | undefined;\n  },\n) => {\n  if (!signalExit) {\n    signalExit = processOk(process) ? new SignalExit(process) : new SignalExitFallback();\n  }\n  return signalExit.onExit(cb, opts);\n};\n", "import { environment } from \"@raycast/api\";\nimport { createReadStream, createWriteStream, mkdirSync, Stats } from \"node:fs\";\nimport { stat } from \"node:fs/promises\";\nimport { join, normalize } from \"node:path\";\nimport { pipeline } from \"node:stream/promises\";\nimport { useRef } from \"react\";\nimport Chain from \"./vendors/stream-chain\";\nimport { parser, PickParser, StreamArray } from \"./vendors/stream-json\";\nimport { isJSON } from \"./fetch-utils\";\nimport { Flatten, FunctionReturningPaginatedPromise, UseCachedPromiseReturnType } from \"./types\";\nimport { CachedPromiseOptions, useCachedPromise } from \"./useCachedPromise\";\nimport { hash } from \"./helpers\";\n\ntype RequestInfo = string | URL | globalThis.Request;\n\nasync function cache(url: RequestInfo, destination: string, fetchOptions?: RequestInit) {\n  if (typeof url === \"object\" || url.startsWith(\"http://\") || url.startsWith(\"https://\")) {\n    return await cacheURL(url, destination, fetchOptions);\n  } else if (url.startsWith(\"file://\")) {\n    return await cacheFile(\n      normalize(decodeURIComponent(new URL(url).pathname)),\n      destination,\n      fetchOptions?.signal ? fetchOptions.signal : undefined,\n    );\n  } else {\n    throw new Error(\"Only HTTP(S) or file URLs are supported\");\n  }\n}\n\nasync function cacheURL(url: RequestInfo, destination: string, fetchOptions?: RequestInit) {\n  const response = await fetch(url, fetchOptions);\n\n  if (!response.ok) {\n    throw new Error(\"Failed to fetch URL\");\n  }\n\n  if (!isJSON(response.headers.get(\"content-type\"))) {\n    throw new Error(\"URL does not return JSON\");\n  }\n  if (!response.body) {\n    throw new Error(\"Failed to retrieve expected JSON content: Response body is missing or inaccessible.\");\n  }\n  await pipeline(\n    response.body as unknown as NodeJS.ReadableStream,\n    createWriteStream(destination),\n    fetchOptions?.signal ? { signal: fetchOptions.signal } : undefined,\n  );\n}\n\nasync function cacheFile(source: string, destination: string, abortSignal?: AbortSignal) {\n  await pipeline(\n    createReadStream(source),\n    createWriteStream(destination),\n    abortSignal ? { signal: abortSignal } : undefined,\n  );\n}\n\nasync function cacheURLIfNecessary(\n  url: RequestInfo,\n  folder: string,\n  fileName: string,\n  forceUpdate: boolean,\n  fetchOptions?: RequestInit,\n) {\n  const destination = join(folder, fileName);\n\n  try {\n    await stat(folder);\n  } catch (e) {\n    mkdirSync(folder, { recursive: true });\n    await cache(url, destination, fetchOptions);\n    return;\n  }\n  if (forceUpdate) {\n    await cache(url, destination, fetchOptions);\n    return;\n  }\n\n  let stats: Stats | undefined = undefined;\n  try {\n    stats = await stat(destination);\n  } catch (e) {\n    await cache(url, destination, fetchOptions);\n    return;\n  }\n\n  if (typeof url === \"object\" || url.startsWith(\"http://\") || url.startsWith(\"https://\")) {\n    const headResponse = await fetch(url, { ...fetchOptions, method: \"HEAD\" });\n    if (!headResponse.ok) {\n      throw new Error(\"Could not fetch URL\");\n    }\n\n    if (!isJSON(headResponse.headers.get(\"content-type\"))) {\n      throw new Error(\"URL does not return JSON\");\n    }\n\n    const lastModified = Date.parse(headResponse.headers.get(\"last-modified\") ?? \"\");\n    if (stats.size === 0 || Number.isNaN(lastModified) || lastModified > stats.mtimeMs) {\n      await cache(url, destination, fetchOptions);\n      return;\n    }\n  } else if (url.startsWith(\"file://\")) {\n    try {\n      const sourceStats = await stat(normalize(decodeURIComponent(new URL(url).pathname)));\n      if (sourceStats.mtimeMs > stats.mtimeMs) {\n        await cache(url, destination, fetchOptions);\n      }\n    } catch (e) {\n      throw new Error(\"Source file could not be read\");\n    }\n  } else {\n    throw new Error(\"Only HTTP(S) or file URLs are supported\");\n  }\n}\n\nasync function* streamJsonFile<T>(\n  filePath: string,\n  pageSize: number,\n  abortSignal?: AbortSignal,\n  dataPath?: string | RegExp,\n  filterFn?: (item: Flatten<T>) => boolean,\n  transformFn?: (item: any) => T,\n): AsyncGenerator<T extends unknown[] ? T : T[]> {\n  let page: T extends unknown[] ? T : T[] = [] as T extends unknown[] ? T : T[];\n\n  const pipeline = Chain([\n    createReadStream(filePath),\n    dataPath ? PickParser({ filter: dataPath }) : parser(),\n    StreamArray(),\n    (data: any) => transformFn?.(data.value) ?? data.value,\n  ]);\n\n  abortSignal?.addEventListener(\"abort\", () => {\n    pipeline.destroy();\n  });\n\n  try {\n    for await (const data of pipeline) {\n      if (abortSignal?.aborted) {\n        return [];\n      }\n      if (!filterFn || filterFn(data)) {\n        page.push(data);\n      }\n      if (page.length >= pageSize) {\n        yield page;\n        page = [] as T extends unknown[] ? T : T[];\n      }\n    }\n  } catch (e) {\n    pipeline.destroy();\n    throw e;\n  }\n\n  if (page.length > 0) {\n    yield page;\n  }\n\n  return [];\n}\n\ntype Options<T> = {\n  /**\n   * The hook expects to iterate through an array of data, so by default, it assumes the JSON it receives itself represents an array. However, sometimes the array of data is wrapped in an object,\n   * i.e. `{ \"success\": true, \"data\": [] }`, or even `{ \"success\": true, \"results\": { \"data\": [] } }`. In those cases, you can use `dataPath` to specify where the data array can be found.\n   *\n   * @remark If your JSON object has multiple arrays that you want to stream data from, you can pass a regular expression to stream through all of them.\n   *\n   * @example For `{ \"success\": true, \"data\": [] }`, dataPath would be `data`\n   * @example For `{ \"success\": true, \"results\": { \"data\": [] } }`, dataPath would be `results.data`\n   * @example For `{ \"success\": true, \"results\": { \"first_list\": [], \"second_list\": [], \"third_list\": [] } }`, dataPath would be `/^results\\.(first_list|second_list|third_list)$\n/`.\n   */\n  dataPath?: string | RegExp;\n  /**\n   * A function to decide whether a particular item should be kept or not.\n   * Defaults to `undefined`, keeping any encountered item.\n   *\n   * @remark The hook will revalidate every time the filter function changes, so you need to use [useCallback](https://react.dev/reference/react/useCallback) to make sure it only changes when it needs to.\n   */\n  filter?: (item: Flatten<T>) => boolean;\n  /**\n   * A function to apply to each item as it is encountered. Useful for a couple of things:\n   * 1. ensuring that all items have the expected properties, and, as on optimization, for getting rid of the properties that you don't care about.\n   * 2. when top-level objects actually represent nested data, which should be flattened. In this case, `transform` can return an array of items, and the hook will stream through each one of those items,\n   * passing them to `filter` etc.\n   *\n   * Defaults to a passthrough function if not provided.\n   *\n   * @remark The hook will revalidate every time the transform function changes, so it is important to use [useCallback](https://react.dev/reference/react/useCallback) to ensure it only changes when necessary to prevent unnecessary re-renders or computations.\n   *\n   * @example\n   * ```\n   * // For data: `{ \"data\": [ { \"type\": \"folder\", \"name\": \"item 1\", \"children\": [ { \"type\": \"item\", \"name\": \"item 2\" }, { \"type\": \"item\", \"name\": \"item 3\" } ] }, { \"type\": \"folder\", \"name\": \"item 4\", children: [] } ] }`\n   *\n   * type Item = {\n   *  type: \"item\";\n   *  name: string;\n   * };\n   *\n   * type Folder = {\n   *   type: \"folder\";\n   *   name: string;\n   *   children: (Item | Folder)[];\n   * };\n   *\n   * function flatten(item: Item | Folder): { name: string }[] {\n   *   const flattened: { name: string }[] = [];\n   *   if (item.type === \"folder\") {\n   *     flattened.push(...item.children.map(flatten).flat());\n   *   }\n   *   if (item.type === \"item\") {\n   *     flattened.push({ name: item.name });\n   *   }\n   *   return flattened;\n   * }\n   *\n   * const transform = useCallback(flatten, []);\n   * const filter = useCallback((item: { name: string }) => {\n   *   \n   * })\n   * ```\n   */\n  transform?: (item: any) => T;\n  /**\n   * The amount of items to return for each page.\n   * Defaults to `20`.\n   */\n  pageSize?: number;\n};\n\n/**\n * Takes a `http://`, `https://` or `file:///` URL pointing to a JSON resource, caches it to the command's support\n * folder, and streams through its content. Useful when dealing with large JSON arrays which would be too big to fit\n * in the command's memory.\n *\n * @remark The JSON resource needs to consist of an array of objects\n *\n * @example\n * ```\n * import { List } from \"@raycast/api\";\n * import { useStreamJSON } from \"@raycast/utils\";\n *\n * type Formula = { name: string; desc?: string };\n *\n * export default function Main(): React.JSX.Element {\n *   const { data, isLoading, pagination } = useStreamJSON<Formula>(\"https://formulae.brew.sh/api/formula.json\");\n *\n *   return (\n *     <List isLoading={isLoading} pagination={pagination}>\n *       <List.Section title=\"Formulae\">\n *         {data?.map((d) => <List.Item key={d.name} title={d.name} subtitle={d.desc} />)}\n *       </List.Section>\n *     </List>\n *   );\n * }\n * ```\n *\n * @example\n * ```\n * import { List } from \"@raycast/api\";\n * import { useStreamJSON } from \"@raycast/utils\";\n * import { homedir } from \"os\";\n * import { join } from \"path\";\n *\n * type Formula = { name: string; desc?: string };\n *\n * export default function Main(): React.JSX.Element {\n *   const { data, isLoading, pagination } = useStreamJSON<Formula>(`file:///${join(homedir(), \"Downloads\", \"formulae.json\")}`);\n *\n *   return (\n *     <List isLoading={isLoading} pagination={pagination}>\n *       <List.Section title=\"Formulae\">\n *         {data?.map((d) => <List.Item key={d.name} title={d.name} subtitle={d.desc} />)}\n *       </List.Section>\n *     </List>\n *   );\n * }\n * ```\n */\nexport function useStreamJSON<T, U = unknown>(url: RequestInfo): UseCachedPromiseReturnType<T, U>;\n\n/**\n * Takes a `http://`, `https://` or `file:///` URL pointing to a JSON resource, caches it to the command's support\n * folder, and streams through its content. Useful when dealing with large JSON arrays which would be too big to fit\n * in the command's memory.\n *\n * @remark The JSON resource needs to consist of an array of objects\n *\n * @example\n * ```\n * import { List, environment } from \"@raycast/api\";\n * import { useStreamJSON } from \"@raycast/utils\";\n * import { join } from 'path';\n * import { useCallback, useState } from \"react\";\n *\n * type Formula = { name: string; desc?: string };\n *\n * export default function Main(): React.JSX.Element {\n *   const [searchText, setSearchText] = useState(\"\");\n *\n *   const formulaFilter = useCallback(\n *     (item: Formula) => {\n *       if (!searchText) return true;\n *       return item.name.toLocaleLowerCase().includes(searchText);\n *     },\n *     [searchText],\n *   );\n *\n *   const formulaTransform = useCallback((item: any): Formula => {\n *     return { name: item.name, desc: item.desc };\n *   }, []);\n *\n *   const { data, isLoading, pagination } = useStreamJSON(\"https://formulae.brew.sh/api/formula.json\", {\n *     initialData: [] as Formula[],\n *     pageSize: 20,\n *     filter: formulaFilter,\n *     transform: formulaTransform,\n *   });\n *\n *   return (\n *     <List isLoading={isLoading} pagination={pagination} onSearchTextChange={setSearchText}>\n *       <List.Section title=\"Formulae\">\n *         {data.map((d) => (\n *           <List.Item key={d.name} title={d.name} subtitle={d.desc} />\n *         ))}\n *       </List.Section>\n *     </List>\n *   );\n * }\n * ``` support folder, and streams through its content.\n *\n * @example\n * ```\n * import { List, environment } from \"@raycast/api\";\n * import { useStreamJSON } from \"@raycast/utils\";\n * import { join } from \"path\";\n * import { homedir } from \"os\";\n * import { useCallback, useState } from \"react\";\n *\n * type Formula = { name: string; desc?: string };\n *\n * export default function Main(): React.JSX.Element {\n *   const [searchText, setSearchText] = useState(\"\");\n *\n *   const formulaFilter = useCallback(\n *     (item: Formula) => {\n *       if (!searchText) return true;\n *       return item.name.toLocaleLowerCase().includes(searchText);\n *     },\n *     [searchText],\n *   );\n *\n *   const formulaTransform = useCallback((item: any): Formula => {\n *     return { name: item.name, desc: item.desc };\n *   }, []);\n *\n *   const { data, isLoading, pagination } = useStreamJSON(`file:///${join(homedir(), \"Downloads\", \"formulae.json\")}`, {\n *     initialData: [] as Formula[],\n *     pageSize: 20,\n *     filter: formulaFilter,\n *     transform: formulaTransform,\n *   });\n *\n *   return (\n *     <List isLoading={isLoading} pagination={pagination} onSearchTextChange={setSearchText}>\n *       <List.Section title=\"Formulae\">\n *         {data.map((d) => (\n *           <List.Item key={d.name} title={d.name} subtitle={d.desc} />\n *         ))}\n *       </List.Section>\n *     </List>\n *   );\n * }\n * ```\n */\nexport function useStreamJSON<T, U extends any[] = any[]>(\n  url: RequestInfo,\n  options: Options<T> & RequestInit & Omit<CachedPromiseOptions<FunctionReturningPaginatedPromise, U>, \"abortable\">,\n): UseCachedPromiseReturnType<T extends unknown[] ? T : T[], U>;\n\nexport function useStreamJSON<T, U extends any[] = any[]>(\n  url: RequestInfo,\n  options?: Options<T> & RequestInit & Omit<CachedPromiseOptions<FunctionReturningPaginatedPromise, U>, \"abortable\">,\n): UseCachedPromiseReturnType<T extends unknown[] ? T : T[], U> {\n  const {\n    initialData,\n    execute,\n    keepPreviousData,\n    onError,\n    onData,\n    onWillExecute,\n    failureToastOptions,\n    dataPath,\n    filter,\n    transform,\n    pageSize = 20,\n    ...fetchOptions\n  } = options ?? {};\n  const previousUrl = useRef<RequestInfo>(null);\n  const previousDestination = useRef<string>(null);\n\n  const useCachedPromiseOptions: CachedPromiseOptions<FunctionReturningPaginatedPromise, U> = {\n    initialData,\n    execute,\n    keepPreviousData,\n    onError,\n    onData,\n    onWillExecute,\n    failureToastOptions,\n  };\n\n  const generatorRef = useRef<AsyncGenerator<T extends unknown[] ? T : T[]> | null>(null);\n  const controllerRef = useRef<AbortController | null>(null);\n  const hasMoreRef = useRef(false);\n\n  return useCachedPromise(\n    (\n      url: RequestInfo,\n      pageSize: number,\n      fetchOptions: RequestInit | undefined,\n      dataPath: string | RegExp | undefined,\n      filter: ((item: Flatten<T>) => boolean) | undefined,\n      transform: ((item: unknown) => T) | undefined,\n    ) =>\n      async ({ page }) => {\n        const fileName = hash(url) + \".json\";\n        const folder = environment.supportPath;\n        if (page === 0) {\n          controllerRef.current?.abort();\n          controllerRef.current = new AbortController();\n          const destination = join(folder, fileName);\n          /**\n           * Force update the cache when the URL changes but the cache destination does not.\n           */\n          const forceCacheUpdate = Boolean(\n            previousUrl.current &&\n              previousUrl.current !== url &&\n              previousDestination.current &&\n              previousDestination.current === destination,\n          );\n          previousUrl.current = url;\n          previousDestination.current = destination;\n          await cacheURLIfNecessary(url, folder, fileName, forceCacheUpdate, {\n            ...fetchOptions,\n            signal: controllerRef.current?.signal,\n          });\n          generatorRef.current = streamJsonFile(\n            destination,\n            pageSize,\n            controllerRef.current?.signal,\n            dataPath,\n            filter,\n            transform,\n          );\n        }\n        if (!generatorRef.current) {\n          return { hasMore: hasMoreRef.current, data: [] as T extends unknown[] ? T : T[] };\n        }\n        const { value: newData, done } = await generatorRef.current.next();\n        hasMoreRef.current = !done;\n        return { hasMore: hasMoreRef.current, data: (newData ?? []) as T extends unknown[] ? T : T[] };\n      },\n    [url, pageSize, fetchOptions, dataPath, filter, transform],\n    useCachedPromiseOptions,\n  );\n}\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/ban-ts-comment */\nimport { Readable, Writable, Duplex } from \"node:stream\";\n\nexport const none = /* #__PURE__ */ Symbol.for(\"object-stream.none\");\nconst stop = /* #__PURE__ */ Symbol.for(\"object-stream.stop\");\n\nconst finalSymbol = /* #__PURE__ */ Symbol.for(\"object-stream.final\");\nconst manySymbol = /* #__PURE__ */ Symbol.for(\"object-stream.many\");\nconst flushSymbol = /* #__PURE__ */ Symbol.for(\"object-stream.flush\");\nconst fListSymbol = /* #__PURE__ */ Symbol.for(\"object-stream.fList\");\n\nconst finalValue = (value: any) => ({ [finalSymbol]: 1, value });\nexport const many = (values: any) => ({ [manySymbol]: 1, values });\n\nconst isFinalValue = (o: any) => o && o[finalSymbol] === 1;\nconst isMany = (o: any) => o && o[manySymbol] === 1;\nconst isFlushable = (o: any) => o && o[flushSymbol] === 1;\nconst isFunctionList = (o: any) => o && o[fListSymbol] === 1;\n\nconst getFinalValue = (o: any) => o.value;\nconst getManyValues = (o: any) => o.values;\nconst getFunctionList = (o: any) => o.fList;\n\nexport const combineManyMut = (a: any, b: any) => {\n  const values = a === none ? [] : a?.[manySymbol] === 1 ? a.values : [a];\n  if (b === none) {\n    // do nothing\n  } else if (b?.[manySymbol] === 1) {\n    values.push(...b.values);\n  } else {\n    values.push(b);\n  }\n  return many(values);\n};\n\nexport const flushable = (write: (value: any) => any, final = null) => {\n  const fn = final ? (value: any) => (value === none ? finalValue(undefined) : write(value)) : write;\n  // @ts-ignore\n  fn[flushSymbol] = 1;\n  return fn;\n};\n\nconst setFunctionList = (o: any, fns: any) => {\n  o.fList = fns;\n  o[fListSymbol] = 1;\n  return o;\n};\n\n// is*NodeStream functions taken from https://github.com/nodejs/node/blob/master/lib/internal/streams/utils.js\nconst isReadableNodeStream = (obj: any) =>\n  obj &&\n  typeof obj.pipe === \"function\" &&\n  typeof obj.on === \"function\" &&\n  (!obj._writableState || (typeof obj._readableState === \"object\" ? obj._readableState.readable : null) !== false) && // Duplex\n  (!obj._writableState || obj._readableState); // Writable has .pipe.\n\nconst isWritableNodeStream = (obj: any) =>\n  obj &&\n  typeof obj.write === \"function\" &&\n  typeof obj.on === \"function\" &&\n  (!obj._readableState || (typeof obj._writableState === \"object\" ? obj._writableState.writable : null) !== false); // Duplex\n\nconst isDuplexNodeStream = (obj: any) =>\n  obj &&\n  typeof obj.pipe === \"function\" &&\n  obj._readableState &&\n  typeof obj.on === \"function\" &&\n  typeof obj.write === \"function\";\n\nconst isReadableWebStream = (obj: any) => obj && globalThis.ReadableStream && obj instanceof globalThis.ReadableStream;\n\nconst isWritableWebStream = (obj: any) => obj && globalThis.WritableStream && obj instanceof globalThis.WritableStream;\n\nconst isDuplexWebStream = (obj: any) =>\n  obj &&\n  globalThis.ReadableStream &&\n  obj.readable instanceof globalThis.ReadableStream &&\n  globalThis.WritableStream &&\n  obj.writable instanceof globalThis.WritableStream;\n\nconst groupFunctions = (output: any, fn: any, index: any, fns: any) => {\n  if (\n    isDuplexNodeStream(fn) ||\n    (!index && isReadableNodeStream(fn)) ||\n    (index === fns.length - 1 && isWritableNodeStream(fn))\n  ) {\n    output.push(fn);\n    return output;\n  }\n  if (isDuplexWebStream(fn)) {\n    output.push(Duplex.fromWeb(fn, { objectMode: true }));\n    return output;\n  }\n  if (!index && isReadableWebStream(fn)) {\n    output.push(Readable.fromWeb(fn, { objectMode: true }));\n    return output;\n  }\n  if (index === fns.length - 1 && isWritableWebStream(fn)) {\n    output.push(Writable.fromWeb(fn, { objectMode: true }));\n    return output;\n  }\n  if (typeof fn != \"function\") throw TypeError(\"Item #\" + index + \" is not a proper stream, nor a function.\");\n  if (!output.length) output.push([]);\n  const last = output[output.length - 1];\n  if (Array.isArray(last)) {\n    last.push(fn);\n  } else {\n    output.push([fn]);\n  }\n  return output;\n};\n\nclass Stop extends Error {}\n\nexport const asStream = (fn: any) => {\n  if (typeof fn != \"function\") throw TypeError(\"Only a function is accepted as the first argument\");\n\n  // pump variables\n  let paused = Promise.resolve();\n  let resolvePaused: ((value: void | PromiseLike<void>) => void) | null = null;\n  const queue: any[] = [];\n\n  // pause/resume\n  const resume: any = () => {\n    if (!resolvePaused) return;\n    resolvePaused();\n    resolvePaused = null;\n    paused = Promise.resolve();\n  };\n  const pause: any = () => {\n    if (resolvePaused) return;\n    paused = new Promise((resolve) => (resolvePaused = resolve));\n  };\n\n  // eslint-disable-next-line prefer-const\n  let stream: Duplex; // will be assigned later\n\n  // data processing\n  const pushResults: any = (values: any) => {\n    if (values && typeof values.next == \"function\") {\n      // generator\n      queue.push(values);\n      return;\n    }\n    // array\n    queue.push(values[Symbol.iterator]());\n  };\n  const pump: any = async () => {\n    while (queue.length) {\n      await paused;\n      const gen = queue[queue.length - 1];\n      let result = gen.next();\n      if (result && typeof result.then == \"function\") {\n        result = await result;\n      }\n      if (result.done) {\n        queue.pop();\n        continue;\n      }\n      let value = result.value;\n      if (value && typeof value.then == \"function\") {\n        value = await value;\n      }\n      await sanitize(value);\n    }\n  };\n  const sanitize: any = async (value: any) => {\n    if (value === undefined || value === null || value === none) return;\n    if (value === stop) throw new Stop();\n\n    if (isMany(value)) {\n      pushResults(getManyValues(value));\n      return pump();\n    }\n\n    if (isFinalValue(value)) {\n      // a final value is not supported, it is treated as a regular value\n      value = getFinalValue(value);\n      return processValue(value);\n    }\n\n    if (!stream.push(value)) {\n      pause();\n    }\n  };\n  const processChunk: any = async (chunk: any, encoding: any) => {\n    try {\n      const value = fn(chunk, encoding);\n      await processValue(value);\n    } catch (error) {\n      if (error instanceof Stop) {\n        stream.push(null);\n        stream.destroy();\n        return;\n      }\n      throw error;\n    }\n  };\n  const processValue: any = async (value: any) => {\n    if (value && typeof value.then == \"function\") {\n      // thenable\n      return value.then((value: any) => processValue(value));\n    }\n    if (value && typeof value.next == \"function\") {\n      // generator\n      pushResults(value);\n      return pump();\n    }\n    return sanitize(value);\n  };\n\n  stream = new Duplex(\n    Object.assign({ writableObjectMode: true, readableObjectMode: true }, undefined, {\n      write(chunk: any, encoding: any, callback: any) {\n        processChunk(chunk, encoding).then(\n          () => callback(null),\n          (error: any) => callback(error),\n        );\n      },\n      final(callback: any) {\n        if (!isFlushable(fn)) {\n          stream.push(null);\n          callback(null);\n          return;\n        }\n        processChunk(none, null).then(\n          () => (stream.push(null), callback(null)),\n          (error: any) => callback(error),\n        );\n      },\n      read() {\n        resume();\n      },\n    }),\n  );\n\n  return stream;\n};\n\nconst produceStreams = (item: any) => {\n  if (Array.isArray(item)) {\n    if (!item.length) return null;\n    if (item.length == 1) return item[0] && asStream(item[0]);\n    return asStream(gen(...item));\n  }\n  return item;\n};\n\nconst next: any = async function* (value: any, fns: any, index: any) {\n  for (let i = index; i <= fns.length; ++i) {\n    if (value && typeof value.then == \"function\") {\n      // thenable\n      value = await value;\n    }\n    if (value === none) break;\n    if (value === stop) throw new Stop();\n    if (isFinalValue(value)) {\n      yield getFinalValue(value);\n      break;\n    }\n    if (isMany(value)) {\n      const values = getManyValues(value);\n      if (i == fns.length) {\n        yield* values;\n      } else {\n        for (let j = 0; j < values.length; ++j) {\n          yield* next(values[j], fns, i);\n        }\n      }\n      break;\n    }\n    if (value && typeof value.next == \"function\") {\n      // generator\n      for (;;) {\n        let data = value.next();\n        if (data && typeof data.then == \"function\") {\n          data = await data;\n        }\n        if (data.done) break;\n        if (i == fns.length) {\n          yield data.value;\n        } else {\n          yield* next(data.value, fns, i);\n        }\n      }\n      break;\n    }\n    if (i == fns.length) {\n      yield value;\n      break;\n    }\n    const f = fns[i];\n    value = f(value);\n  }\n};\n\nexport const gen = (...fns: any) => {\n  fns = fns\n    .filter((fn: any) => fn)\n    .flat(Infinity)\n    .map((fn: any) => (isFunctionList(fn) ? getFunctionList(fn) : fn))\n    .flat(Infinity);\n  if (!fns.length) {\n    fns = [(x: any) => x];\n  }\n  let flushed = false;\n  let g = async function* (value: any) {\n    if (flushed) throw Error(\"Call to a flushed pipe.\");\n    if (value !== none) {\n      yield* next(value, fns, 0);\n    } else {\n      flushed = true;\n      for (let i = 0; i < fns.length; ++i) {\n        const f = fns[i];\n        if (isFlushable(f)) {\n          yield* next(f(none), fns, i + 1);\n        }\n      }\n    }\n  };\n  const needToFlush = fns.some((fn: any) => isFlushable(fn));\n  if (needToFlush) g = flushable(g);\n  return setFunctionList(g, fns);\n};\n\nconst write = (input: any, chunk: any, encoding: any, callback: any) => {\n  let error: any = null;\n  try {\n    input.write(chunk, encoding, (e: any) => callback(e || error));\n  } catch (e) {\n    error = e;\n  }\n};\n\nconst final = (input: any, callback: any) => {\n  let error: any = null;\n  try {\n    input.end(null, null, (e: any) => callback(e || error));\n  } catch (e) {\n    error = e;\n  }\n};\n\nconst read = (output: any) => {\n  output.resume();\n};\n\nexport default function chain(fns: any) {\n  fns = fns.flat(Infinity).filter((fn: any) => fn);\n\n  const streams = fns\n      .map((fn: any) => (isFunctionList(fn) ? getFunctionList(fn) : fn))\n      .flat(Infinity)\n      .reduce(groupFunctions, [])\n      .map(produceStreams)\n      .filter((s: any) => s),\n    input = streams[0],\n    output = streams.reduce((output: any, item: any) => (output && output.pipe(item)) || item);\n\n  // eslint-disable-next-line prefer-const\n  let stream: Duplex; // will be assigned later\n\n  let writeMethod = (chunk: any, encoding: any, callback: any) => write(input, chunk, encoding, callback),\n    finalMethod = (callback: any) => final(input, callback),\n    readMethod = () => read(output);\n\n  if (!isWritableNodeStream(input)) {\n    writeMethod = (_1, _2, callback) => callback(null);\n    finalMethod = (callback) => callback(null);\n    input.on(\"end\", () => stream.end());\n  }\n\n  if (isReadableNodeStream(output)) {\n    output.on(\"data\", (chunk: any) => !stream.push(chunk) && output.pause());\n    output.on(\"end\", () => stream.push(null));\n  } else {\n    readMethod = () => {}; // nop\n    output.on(\"finish\", () => stream.push(null));\n  }\n\n  stream = new Duplex(\n    Object.assign(\n      { writableObjectMode: true, readableObjectMode: true },\n      {\n        readable: isReadableNodeStream(output),\n        writable: isWritableNodeStream(input),\n        write: writeMethod,\n        final: finalMethod,\n        read: readMethod,\n      },\n    ),\n  );\n  // @ts-ignore\n  stream.streams = streams;\n  // @ts-ignore\n  stream.input = input;\n  // @ts-ignore\n  stream.output = output;\n\n  if (!isReadableNodeStream(output)) {\n    stream.resume();\n  }\n\n  // connect events\n  streams.forEach((item: any) => item.on(\"error\", (error: any) => stream.emit(\"error\", error)));\n\n  return stream;\n}\n", "/* eslint-disable @typescript-eslint/ban-ts-comment */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable no-control-regex */\n/* eslint-disable no-useless-escape */\nimport { flushable, gen, many, none, combineManyMut } from \"./stream-chain\";\nimport { StringDecoder } from \"node:string_decoder\";\nimport EventEmitter from \"node:events\";\n\nconst fixUtf8Stream = () => {\n  const stringDecoder = new StringDecoder();\n  let input = \"\";\n  return flushable((chunk: any) => {\n    if (chunk === none) {\n      const result = input + stringDecoder.end();\n      input = \"\";\n      return result;\n    }\n    if (typeof chunk == \"string\") {\n      if (!input) return chunk;\n      const result = input + chunk;\n      input = \"\";\n      return result;\n    }\n    if (chunk instanceof Buffer) {\n      const result = input + stringDecoder.write(chunk);\n      input = \"\";\n      return result;\n    }\n    throw new TypeError(\"Expected a string or a Buffer\");\n  });\n};\n\nconst patterns = {\n  value1: /[\\\"\\{\\[\\]\\-\\d]|true\\b|false\\b|null\\b|\\s{1,256}/y,\n  string: /[^\\x00-\\x1f\\\"\\\\]{1,256}|\\\\[bfnrt\\\"\\\\\\/]|\\\\u[\\da-fA-F]{4}|\\\"/y,\n  key1: /[\\\"\\}]|\\s{1,256}/y,\n  colon: /\\:|\\s{1,256}/y,\n  comma: /[\\,\\]\\}]|\\s{1,256}/y,\n  ws: /\\s{1,256}/y,\n  numberStart: /\\d/y,\n  numberDigit: /\\d{0,256}/y,\n  numberFraction: /[\\.eE]/y,\n  numberExponent: /[eE]/y,\n  numberExpSign: /[-+]/y,\n};\nconst MAX_PATTERN_SIZE = 16;\n\nconst values: { [key: string]: any } = { true: true, false: false, null: null },\n  expected: { [key: string]: string } = { object: \"objectStop\", array: \"arrayStop\", \"\": \"done\" };\n\n// long hexadecimal codes: \\uXXXX\nconst fromHex = (s: string) => String.fromCharCode(parseInt(s.slice(2), 16));\n\n// short codes: \\b \\f \\n \\r \\t \\\" \\\\ \\/\nconst codes: { [key: string]: string } = {\n  b: \"\\b\",\n  f: \"\\f\",\n  n: \"\\n\",\n  r: \"\\r\",\n  t: \"\\t\",\n  '\"': '\"',\n  \"\\\\\": \"\\\\\",\n  \"/\": \"/\",\n};\n\nconst jsonParser = (options?: any) => {\n  let packKeys = true,\n    packStrings = true,\n    packNumbers = true,\n    streamKeys = true,\n    streamStrings = true,\n    streamNumbers = true,\n    jsonStreaming = false;\n\n  if (options) {\n    \"packValues\" in options && (packKeys = packStrings = packNumbers = options.packValues);\n    \"packKeys\" in options && (packKeys = options.packKeys);\n    \"packStrings\" in options && (packStrings = options.packStrings);\n    \"packNumbers\" in options && (packNumbers = options.packNumbers);\n    \"streamValues\" in options && (streamKeys = streamStrings = streamNumbers = options.streamValues);\n    \"streamKeys\" in options && (streamKeys = options.streamKeys);\n    \"streamStrings\" in options && (streamStrings = options.streamStrings);\n    \"streamNumbers\" in options && (streamNumbers = options.streamNumbers);\n    jsonStreaming = options.jsonStreaming;\n  }\n\n  !packKeys && (streamKeys = true);\n  !packStrings && (streamStrings = true);\n  !packNumbers && (streamNumbers = true);\n\n  let done = false,\n    expect = jsonStreaming ? \"done\" : \"value\",\n    parent = \"\",\n    openNumber = false,\n    accumulator = \"\",\n    buffer = \"\";\n\n  const stack: any[] = [];\n\n  return flushable((buf: any) => {\n    const tokens: any[] = [];\n\n    if (buf === none) {\n      done = true;\n    } else {\n      buffer += buf;\n    }\n\n    let match: any;\n    let value: any;\n    let index = 0;\n\n    main: for (;;) {\n      switch (expect) {\n        case \"value1\":\n        case \"value\":\n          patterns.value1.lastIndex = index;\n          match = patterns.value1.exec(buffer);\n          if (!match) {\n            if (done || index + MAX_PATTERN_SIZE < buffer.length) {\n              if (index < buffer.length) throw new Error(\"Parser cannot parse input: expected a value\");\n              throw new Error(\"Parser has expected a value\");\n            }\n            break main; // wait for more input\n          }\n          value = match[0];\n          switch (value) {\n            case '\"':\n              if (streamStrings) tokens.push({ name: \"startString\" });\n              expect = \"string\";\n              break;\n            case \"{\":\n              tokens.push({ name: \"startObject\" });\n              stack.push(parent);\n              parent = \"object\";\n              expect = \"key1\";\n              break;\n            case \"[\":\n              tokens.push({ name: \"startArray\" });\n              stack.push(parent);\n              parent = \"array\";\n              expect = \"value1\";\n              break;\n            case \"]\":\n              if (expect !== \"value1\") throw new Error(\"Parser cannot parse input: unexpected token ']'\");\n              if (openNumber) {\n                if (streamNumbers) tokens.push({ name: \"endNumber\" });\n                openNumber = false;\n                if (packNumbers) {\n                  tokens.push({ name: \"numberValue\", value: accumulator });\n                  accumulator = \"\";\n                }\n              }\n              tokens.push({ name: \"endArray\" });\n              parent = stack.pop();\n              expect = expected[parent];\n              break;\n            case \"-\":\n              openNumber = true;\n              if (streamNumbers) {\n                tokens.push({ name: \"startNumber\" }, { name: \"numberChunk\", value: \"-\" });\n              }\n              packNumbers && (accumulator = \"-\");\n              expect = \"numberStart\";\n              break;\n            case \"0\":\n              openNumber = true;\n              if (streamNumbers) {\n                tokens.push({ name: \"startNumber\" }, { name: \"numberChunk\", value: \"0\" });\n              }\n              packNumbers && (accumulator = \"0\");\n              expect = \"numberFraction\";\n              break;\n            case \"1\":\n            case \"2\":\n            case \"3\":\n            case \"4\":\n            case \"5\":\n            case \"6\":\n            case \"7\":\n            case \"8\":\n            case \"9\":\n              openNumber = true;\n              if (streamNumbers) {\n                tokens.push({ name: \"startNumber\" }, { name: \"numberChunk\", value: value });\n              }\n              packNumbers && (accumulator = value);\n              expect = \"numberDigit\";\n              break;\n            case \"true\":\n            case \"false\":\n            case \"null\":\n              if (buffer.length - index === value.length && !done) break main; // wait for more input\n              tokens.push({ name: value + \"Value\", value: values[value] });\n              expect = expected[parent];\n              break;\n            // default: // ws\n          }\n          index += value.length;\n          break;\n        case \"keyVal\":\n        case \"string\":\n          patterns.string.lastIndex = index;\n          match = patterns.string.exec(buffer);\n          if (!match) {\n            if (index < buffer.length && (done || buffer.length - index >= 6))\n              throw new Error(\"Parser cannot parse input: escaped characters\");\n            if (done) throw new Error(\"Parser has expected a string value\");\n            break main; // wait for more input\n          }\n          value = match[0];\n          if (value === '\"') {\n            if (expect === \"keyVal\") {\n              if (streamKeys) tokens.push({ name: \"endKey\" });\n              if (packKeys) {\n                tokens.push({ name: \"keyValue\", value: accumulator });\n                accumulator = \"\";\n              }\n              expect = \"colon\";\n            } else {\n              if (streamStrings) tokens.push({ name: \"endString\" });\n              if (packStrings) {\n                tokens.push({ name: \"stringValue\", value: accumulator });\n                accumulator = \"\";\n              }\n              expect = expected[parent];\n            }\n          } else if (value.length > 1 && value.charAt(0) === \"\\\\\") {\n            const t = value.length == 2 ? codes[value.charAt(1)] : fromHex(value);\n            if (expect === \"keyVal\" ? streamKeys : streamStrings) {\n              tokens.push({ name: \"stringChunk\", value: t });\n            }\n            if (expect === \"keyVal\" ? packKeys : packStrings) {\n              accumulator += t;\n            }\n          } else {\n            if (expect === \"keyVal\" ? streamKeys : streamStrings) {\n              tokens.push({ name: \"stringChunk\", value: value });\n            }\n            if (expect === \"keyVal\" ? packKeys : packStrings) {\n              accumulator += value;\n            }\n          }\n          index += value.length;\n          break;\n        case \"key1\":\n        case \"key\":\n          patterns.key1.lastIndex = index;\n          match = patterns.key1.exec(buffer);\n          if (!match) {\n            if (index < buffer.length || done) throw new Error(\"Parser cannot parse input: expected an object key\");\n            break main; // wait for more input\n          }\n          value = match[0];\n          if (value === '\"') {\n            if (streamKeys) tokens.push({ name: \"startKey\" });\n            expect = \"keyVal\";\n          } else if (value === \"}\") {\n            if (expect !== \"key1\") throw new Error(\"Parser cannot parse input: unexpected token '}'\");\n            tokens.push({ name: \"endObject\" });\n            parent = stack.pop();\n            expect = expected[parent];\n          }\n          index += value.length;\n          break;\n        case \"colon\":\n          patterns.colon.lastIndex = index;\n          match = patterns.colon.exec(buffer);\n          if (!match) {\n            if (index < buffer.length || done) throw new Error(\"Parser cannot parse input: expected ':'\");\n            break main; // wait for more input\n          }\n          value = match[0];\n          value === \":\" && (expect = \"value\");\n          index += value.length;\n          break;\n        case \"arrayStop\":\n        case \"objectStop\":\n          patterns.comma.lastIndex = index;\n          match = patterns.comma.exec(buffer);\n          if (!match) {\n            if (index < buffer.length || done) throw new Error(\"Parser cannot parse input: expected ','\");\n            break main; // wait for more input\n          }\n          if (openNumber) {\n            if (streamNumbers) tokens.push({ name: \"endNumber\" });\n            openNumber = false;\n            if (packNumbers) {\n              tokens.push({ name: \"numberValue\", value: accumulator });\n              accumulator = \"\";\n            }\n          }\n          value = match[0];\n          if (value === \",\") {\n            expect = expect === \"arrayStop\" ? \"value\" : \"key\";\n          } else if (value === \"}\" || value === \"]\") {\n            if (value === \"}\" ? expect === \"arrayStop\" : expect !== \"arrayStop\") {\n              throw new Error(\"Parser cannot parse input: expected '\" + (expect === \"arrayStop\" ? \"]\" : \"}\") + \"'\");\n            }\n            tokens.push({ name: value === \"}\" ? \"endObject\" : \"endArray\" });\n            parent = stack.pop();\n            expect = expected[parent];\n          }\n          index += value.length;\n          break;\n        // number chunks\n        case \"numberStart\": // [0-9]\n          patterns.numberStart.lastIndex = index;\n          match = patterns.numberStart.exec(buffer);\n          if (!match) {\n            if (index < buffer.length || done) throw new Error(\"Parser cannot parse input: expected a starting digit\");\n            break main; // wait for more input\n          }\n          value = match[0];\n          if (streamNumbers) tokens.push({ name: \"numberChunk\", value: value });\n          packNumbers && (accumulator += value);\n          expect = value === \"0\" ? \"numberFraction\" : \"numberDigit\";\n          index += value.length;\n          break;\n        case \"numberDigit\": // [0-9]*\n          patterns.numberDigit.lastIndex = index;\n          match = patterns.numberDigit.exec(buffer);\n          if (!match) {\n            if (index < buffer.length || done) throw new Error(\"Parser cannot parse input: expected a digit\");\n            break main; // wait for more input\n          }\n          value = match[0];\n          if (value) {\n            if (streamNumbers) tokens.push({ name: \"numberChunk\", value: value });\n            packNumbers && (accumulator += value);\n            index += value.length;\n          } else {\n            if (index < buffer.length) {\n              expect = \"numberFraction\";\n              break;\n            }\n            if (done) {\n              expect = expected[parent];\n              break;\n            }\n            break main; // wait for more input\n          }\n          break;\n        case \"numberFraction\": // [\\.eE]?\n          patterns.numberFraction.lastIndex = index;\n          match = patterns.numberFraction.exec(buffer);\n          if (!match) {\n            if (index < buffer.length || done) {\n              expect = expected[parent];\n              break;\n            }\n            break main; // wait for more input\n          }\n          value = match[0];\n          if (streamNumbers) tokens.push({ name: \"numberChunk\", value: value });\n          packNumbers && (accumulator += value);\n          expect = value === \".\" ? \"numberFracStart\" : \"numberExpSign\";\n          index += value.length;\n          break;\n        case \"numberFracStart\": // [0-9]\n          patterns.numberStart.lastIndex = index;\n          match = patterns.numberStart.exec(buffer);\n          if (!match) {\n            if (index < buffer.length || done)\n              throw new Error(\"Parser cannot parse input: expected a fractional part of a number\");\n            break main; // wait for more input\n          }\n          value = match[0];\n          if (streamNumbers) tokens.push({ name: \"numberChunk\", value: value });\n          packNumbers && (accumulator += value);\n          expect = \"numberFracDigit\";\n          index += value.length;\n          break;\n        case \"numberFracDigit\": // [0-9]*\n          patterns.numberDigit.lastIndex = index;\n          match = patterns.numberDigit.exec(buffer);\n          value = match[0];\n          if (value) {\n            if (streamNumbers) tokens.push({ name: \"numberChunk\", value: value });\n            packNumbers && (accumulator += value);\n            index += value.length;\n          } else {\n            if (index < buffer.length) {\n              expect = \"numberExponent\";\n              break;\n            }\n            if (done) {\n              expect = expected[parent];\n              break;\n            }\n            break main; // wait for more input\n          }\n          break;\n        case \"numberExponent\": // [eE]?\n          patterns.numberExponent.lastIndex = index;\n          match = patterns.numberExponent.exec(buffer);\n          if (!match) {\n            if (index < buffer.length) {\n              expect = expected[parent];\n              break;\n            }\n            if (done) {\n              expect = \"done\";\n              break;\n            }\n            break main; // wait for more input\n          }\n          value = match[0];\n          if (streamNumbers) tokens.push({ name: \"numberChunk\", value: value });\n          packNumbers && (accumulator += value);\n          expect = \"numberExpSign\";\n          index += value.length;\n          break;\n        case \"numberExpSign\": // [-+]?\n          patterns.numberExpSign.lastIndex = index;\n          match = patterns.numberExpSign.exec(buffer);\n          if (!match) {\n            if (index < buffer.length) {\n              expect = \"numberExpStart\";\n              break;\n            }\n            if (done) throw new Error(\"Parser has expected an exponent value of a number\");\n            break main; // wait for more input\n          }\n          value = match[0];\n          if (streamNumbers) tokens.push({ name: \"numberChunk\", value: value });\n          packNumbers && (accumulator += value);\n          expect = \"numberExpStart\";\n          index += value.length;\n          break;\n        case \"numberExpStart\": // [0-9]\n          patterns.numberStart.lastIndex = index;\n          match = patterns.numberStart.exec(buffer);\n          if (!match) {\n            if (index < buffer.length || done)\n              throw new Error(\"Parser cannot parse input: expected an exponent part of a number\");\n            break main; // wait for more input\n          }\n          value = match[0];\n          if (streamNumbers) tokens.push({ name: \"numberChunk\", value: value });\n          packNumbers && (accumulator += value);\n          expect = \"numberExpDigit\";\n          index += value.length;\n          break;\n        case \"numberExpDigit\": // [0-9]*\n          patterns.numberDigit.lastIndex = index;\n          match = patterns.numberDigit.exec(buffer);\n          value = match[0];\n          if (value) {\n            if (streamNumbers) tokens.push({ name: \"numberChunk\", value: value });\n            packNumbers && (accumulator += value);\n            index += value.length;\n          } else {\n            if (index < buffer.length || done) {\n              expect = expected[parent];\n              break;\n            }\n            break main; // wait for more input\n          }\n          break;\n        case \"done\":\n          patterns.ws.lastIndex = index;\n          match = patterns.ws.exec(buffer);\n          if (!match) {\n            if (index < buffer.length) {\n              if (jsonStreaming) {\n                expect = \"value\";\n                break;\n              }\n              throw new Error(\"Parser cannot parse input: unexpected characters\");\n            }\n            break main; // wait for more input\n          }\n          value = match[0];\n          if (openNumber) {\n            if (streamNumbers) tokens.push({ name: \"endNumber\" });\n            openNumber = false;\n            if (packNumbers) {\n              tokens.push({ name: \"numberValue\", value: accumulator });\n              accumulator = \"\";\n            }\n          }\n          index += value.length;\n          break;\n      }\n    }\n    if (done && openNumber) {\n      if (streamNumbers) tokens.push({ name: \"endNumber\" });\n      openNumber = false;\n      if (packNumbers) {\n        tokens.push({ name: \"numberValue\", value: accumulator });\n        accumulator = \"\";\n      }\n    }\n    buffer = buffer.slice(index);\n    return tokens.length ? many(tokens) : none;\n  });\n};\n\nexport const parser = (options?: any) => gen(fixUtf8Stream(), jsonParser(options));\n\nconst withParser = (fn: any, options?: any) => gen(parser(options), fn(options));\n\nconst checkableTokens = {\n    startObject: 1,\n    startArray: 1,\n    startString: 1,\n    startNumber: 1,\n    nullValue: 1,\n    trueValue: 1,\n    falseValue: 1,\n    stringValue: 1,\n    numberValue: 1,\n  },\n  stopTokens = {\n    startObject: \"endObject\",\n    startArray: \"endArray\",\n    startString: \"endString\",\n    startNumber: \"endNumber\",\n  },\n  optionalTokens = { endString: \"stringValue\", endNumber: \"numberValue\" };\n\nconst defaultFilter = (_stack: string[], _a: any) => true;\n\nconst stringFilter = (string: string, separator: string) => {\n  const stringWithSeparator = string + separator;\n  return (stack: string[], _a: any) => {\n    const path = stack.join(separator);\n    return path === string || path.startsWith(stringWithSeparator);\n  };\n};\n\nconst regExpFilter = (regExp: RegExp, separator: string) => {\n  return (stack: string[], _a: any) => regExp.test(stack.join(separator));\n};\n\nconst filterBase =\n  ({\n    specialAction = \"accept\",\n    defaultAction = \"ignore\",\n    nonCheckableAction = \"process-key\",\n    transition = undefined as any,\n  } = {}) =>\n  (options: any) => {\n    const once = options?.once,\n      separator = options?.pathSeparator || \".\";\n    let filter = defaultFilter,\n      streamKeys = true;\n    if (options) {\n      if (typeof options.filter == \"function\") {\n        filter = options.filter;\n      } else if (typeof options.filter == \"string\") {\n        filter = stringFilter(options.filter, separator);\n      } else if (options.filter instanceof RegExp) {\n        filter = regExpFilter(options.filter, separator);\n      }\n      if (\"streamValues\" in options) streamKeys = options.streamValues;\n      if (\"streamKeys\" in options) streamKeys = options.streamKeys;\n    }\n    const sanitizedOptions = Object.assign({}, options, { filter, streamKeys, separator });\n    let state = \"check\";\n    const stack: any[] = [];\n    let depth = 0,\n      previousToken = \"\",\n      endToken = \"\",\n      optionalToken = \"\",\n      startTransition = false;\n    return flushable((chunk) => {\n      // the flush\n      if (chunk === none) return transition ? transition([], null, \"flush\", sanitizedOptions) : none;\n\n      // process the optional value token (unfinished)\n      if (optionalToken) {\n        if (optionalToken === chunk.name) {\n          let returnToken = none;\n          switch (state) {\n            case \"process-key\":\n              stack[stack.length - 1] = chunk.value;\n              state = \"check\";\n              break;\n            case \"accept-value\":\n              returnToken = chunk;\n              state = once ? \"pass\" : \"check\";\n              break;\n            default:\n              state = once ? \"all\" : \"check\";\n              break;\n          }\n          optionalToken = \"\";\n          return returnToken;\n        }\n        optionalToken = \"\";\n        state = once && state !== \"process-key\" ? \"pass\" : \"check\";\n      }\n\n      let returnToken: any = none;\n\n      recheck: for (;;) {\n        // accept/reject tokens\n        switch (state) {\n          case \"process-key\":\n            if (chunk.name === \"endKey\") optionalToken = \"keyValue\";\n            return none;\n          case \"pass\":\n            return none;\n          case \"all\":\n            return chunk;\n          case \"accept\":\n          case \"reject\":\n            if (startTransition) {\n              startTransition = false;\n              returnToken = transition(stack, chunk, state, sanitizedOptions) || none;\n            }\n            switch (chunk.name) {\n              case \"startObject\":\n              case \"startArray\":\n                ++depth;\n                break;\n              case \"endObject\":\n              case \"endArray\":\n                --depth;\n                break;\n            }\n            if (state === \"accept\") {\n              returnToken = combineManyMut(returnToken, chunk);\n            }\n            if (!depth) {\n              if (once) {\n                state = state === \"accept\" ? \"pass\" : \"all\";\n              } else {\n                state = \"check\";\n              }\n            }\n            return returnToken;\n          case \"accept-value\":\n          case \"reject-value\":\n            if (startTransition) {\n              startTransition = false;\n              returnToken = transition(stack, chunk, state, sanitizedOptions) || none;\n            }\n            if (state === \"accept-value\") {\n              returnToken = combineManyMut(returnToken, chunk);\n            }\n            if (chunk.name === endToken) {\n              // @ts-ignore\n              optionalToken = optionalTokens[endToken] || \"\";\n              endToken = \"\";\n              if (!optionalToken) {\n                if (once) {\n                  state = state === \"accept-value\" ? \"pass\" : \"all\";\n                } else {\n                  state = \"check\";\n                }\n              }\n            }\n            return returnToken;\n        }\n\n        // update the last index in the stack\n        if (typeof stack[stack.length - 1] == \"number\") {\n          // array\n          switch (chunk.name) {\n            case \"startObject\":\n            case \"startArray\":\n            case \"startString\":\n            case \"startNumber\":\n            case \"nullValue\":\n            case \"trueValue\":\n            case \"falseValue\":\n              ++stack[stack.length - 1];\n              break;\n            case \"numberValue\":\n              if (previousToken !== \"endNumber\") ++stack[stack.length - 1];\n              break;\n            case \"stringValue\":\n              if (previousToken !== \"endString\") ++stack[stack.length - 1];\n              break;\n          }\n        } else {\n          if (chunk.name === \"keyValue\") stack[stack.length - 1] = chunk.value;\n        }\n        previousToken = chunk.name;\n\n        // check the token\n        const action =\n          // @ts-ignore\n          checkableTokens[chunk.name] !== 1 ? nonCheckableAction : filter(stack, chunk) ? specialAction : defaultAction;\n\n        // @ts-ignore\n        endToken = stopTokens[chunk.name] || \"\";\n        switch (action) {\n          case \"process-key\":\n            if (chunk.name === \"startKey\") {\n              state = \"process-key\";\n              continue recheck;\n            }\n            break;\n          case \"accept-token\":\n            // @ts-ignore\n            if (endToken && optionalTokens[endToken]) {\n              state = \"accept-value\";\n              startTransition = !!transition;\n              continue recheck;\n            }\n            if (transition) returnToken = transition(stack, chunk, action, sanitizedOptions);\n            returnToken = combineManyMut(returnToken, chunk);\n            break;\n          case \"accept\":\n            if (endToken) {\n              // @ts-ignore\n              state = optionalTokens[endToken] ? \"accept-value\" : \"accept\";\n              startTransition = !!transition;\n              continue recheck;\n            }\n            if (transition) returnToken = transition(stack, chunk, action, sanitizedOptions);\n            returnToken = combineManyMut(returnToken, chunk);\n            break;\n          case \"reject\":\n            if (endToken) {\n              // @ts-ignore\n              state = optionalTokens[endToken] ? \"reject-value\" : \"reject\";\n              startTransition = !!transition;\n              continue recheck;\n            }\n            if (transition) returnToken = transition(stack, chunk, action, sanitizedOptions);\n            break;\n          case \"pass\":\n            state = \"pass\";\n            continue recheck;\n        }\n\n        break;\n      }\n\n      // update the stack\n      switch (chunk.name) {\n        case \"startObject\":\n          stack.push(null);\n          break;\n        case \"startArray\":\n          stack.push(-1);\n          break;\n        case \"endObject\":\n        case \"endArray\":\n          stack.pop();\n          break;\n      }\n\n      return returnToken;\n    });\n  };\n\nexport const PickParser = (options?: any) => withParser(filterBase(), Object.assign({ packKeys: true }, options));\n\nclass Counter {\n  depth: number;\n  constructor(initialDepth: number) {\n    this.depth = initialDepth;\n  }\n  startObject() {\n    ++this.depth;\n  }\n  endObject() {\n    --this.depth;\n  }\n  startArray() {\n    ++this.depth;\n  }\n  endArray() {\n    --this.depth;\n  }\n}\n\nclass Assembler extends EventEmitter {\n  static connectTo(stream: any, options: any) {\n    return new Assembler(options).connectTo(stream);\n  }\n\n  stack: any;\n  current: any;\n  key: any;\n  done: boolean;\n  reviver: any;\n  // @ts-ignore\n  stringValue: (value: string) => void;\n  tapChain: (chunk: any) => any;\n\n  constructor(options: any) {\n    super();\n    this.stack = [];\n    this.current = this.key = null;\n    this.done = true;\n    if (options) {\n      this.reviver = typeof options.reviver == \"function\" && options.reviver;\n      if (this.reviver) {\n        this.stringValue = this._saveValue = this._saveValueWithReviver;\n      }\n      if (options.numberAsString) {\n        // @ts-ignore\n        this.numberValue = this.stringValue;\n      }\n    }\n\n    this.tapChain = (chunk) => {\n      // @ts-ignore\n      if (this[chunk.name]) {\n        // @ts-ignore\n        this[chunk.name](chunk.value);\n        if (this.done) return this.current;\n      }\n      return none;\n    };\n\n    this.stringValue = this._saveValue;\n  }\n\n  connectTo(stream: any) {\n    stream.on(\"data\", (chunk: any) => {\n      // @ts-ignore\n      if (this[chunk.name]) {\n        // @ts-ignore\n        this[chunk.name](chunk.value);\n        // @ts-ignore\n        if (this.done) this.emit(\"done\", this);\n      }\n    });\n    return this;\n  }\n\n  get depth() {\n    return (this.stack.length >> 1) + (this.done ? 0 : 1);\n  }\n\n  get path() {\n    const path: any[] = [];\n    for (let i = 0; i < this.stack.length; i += 2) {\n      const key = this.stack[i + 1];\n      path.push(key === null ? this.stack[i].length : key);\n    }\n    return path;\n  }\n\n  dropToLevel(level: any) {\n    if (level < this.depth) {\n      if (level > 0) {\n        const index = (level - 1) << 1;\n        this.current = this.stack[index];\n        this.key = this.stack[index + 1];\n        this.stack.splice(index);\n      } else {\n        this.stack = [];\n        this.current = this.key = null;\n        this.done = true;\n      }\n    }\n    return this;\n  }\n\n  consume(chunk: any) {\n    // @ts-ignore\n    this[chunk.name] && this[chunk.name](chunk.value);\n    return this;\n  }\n\n  keyValue(value: any) {\n    this.key = value;\n  }\n\n  //stringValue() - aliased below to _saveValue()\n\n  numberValue(value: any) {\n    this._saveValue(parseFloat(value));\n  }\n  nullValue() {\n    this._saveValue(null);\n  }\n  trueValue() {\n    this._saveValue(true);\n  }\n  falseValue() {\n    this._saveValue(false);\n  }\n\n  startObject() {\n    if (this.done) {\n      this.done = false;\n    } else {\n      this.stack.push(this.current, this.key);\n    }\n    this.current = new Object();\n    this.key = null;\n  }\n\n  endObject() {\n    if (this.stack.length) {\n      const value = this.current;\n      this.key = this.stack.pop();\n      this.current = this.stack.pop();\n      this._saveValue(value);\n    } else {\n      this.done = true;\n    }\n  }\n\n  startArray() {\n    if (this.done) {\n      this.done = false;\n    } else {\n      this.stack.push(this.current, this.key);\n    }\n    this.current = [];\n    this.key = null;\n  }\n\n  endArray() {\n    if (this.stack.length) {\n      const value = this.current;\n      this.key = this.stack.pop();\n      this.current = this.stack.pop();\n      this._saveValue(value);\n    } else {\n      this.done = true;\n    }\n  }\n\n  _saveValue(value: any) {\n    if (this.done) {\n      this.current = value;\n    } else {\n      if (this.current instanceof Array) {\n        this.current.push(value);\n      } else {\n        this.current[this.key] = value;\n        this.key = null;\n      }\n    }\n  }\n  _saveValueWithReviver(value: any) {\n    if (this.done) {\n      this.current = this.reviver(\"\", value);\n    } else {\n      if (this.current instanceof Array) {\n        value = this.reviver(\"\" + this.current.length, value);\n        this.current.push(value);\n        if (value === undefined) {\n          delete this.current[this.current.length - 1];\n        }\n      } else {\n        value = this.reviver(this.key, value);\n        if (value !== undefined) {\n          this.current[this.key] = value;\n        }\n        this.key = null;\n      }\n    }\n  }\n}\n\nconst streamBase =\n  ({ push, first, level }: any) =>\n  (options = {} as any) => {\n    const { objectFilter, includeUndecided } = options;\n    let asm = new Assembler(options) as any,\n      state = first ? \"first\" : \"check\",\n      savedAsm = null as any;\n\n    if (typeof objectFilter != \"function\") {\n      // no object filter + no first check\n      if (state === \"check\")\n        return (chunk: any) => {\n          if (asm[chunk.name]) {\n            asm[chunk.name](chunk.value);\n            if (asm.depth === level) {\n              return push(asm);\n            }\n          }\n          return none;\n        };\n      // no object filter\n      return (chunk: any) => {\n        switch (state) {\n          case \"first\":\n            first(chunk);\n            state = \"accept\";\n          // fall through\n          case \"accept\":\n            if (asm[chunk.name]) {\n              asm[chunk.name](chunk.value);\n              if (asm.depth === level) {\n                return push(asm);\n              }\n            }\n            break;\n        }\n        return none;\n      };\n    }\n\n    // object filter + a possible first check\n    return (chunk: any) => {\n      switch (state) {\n        case \"first\":\n          first(chunk);\n          state = \"check\";\n        // fall through\n        case \"check\":\n          if (asm[chunk.name]) {\n            asm[chunk.name](chunk.value);\n            const result = objectFilter(asm);\n            if (result) {\n              state = \"accept\";\n              if (asm.depth === level) return push(asm);\n            } else if (result === false) {\n              if (asm.depth === level) return push(asm, true);\n              state = \"reject\";\n              savedAsm = asm;\n              asm = new Counter(savedAsm.depth);\n              savedAsm.dropToLevel(level);\n            } else {\n              if (asm.depth === level) return push(asm, !includeUndecided);\n            }\n          }\n          break;\n        case \"accept\":\n          if (asm[chunk.name]) {\n            asm[chunk.name](chunk.value);\n            if (asm.depth === level) {\n              state = \"check\";\n              return push(asm);\n            }\n          }\n          break;\n        case \"reject\":\n          if (asm[chunk.name]) {\n            asm[chunk.name](chunk.value);\n            if (asm.depth === level) {\n              state = \"check\";\n              asm = savedAsm;\n              savedAsm = null;\n              return push(asm, true);\n            }\n          }\n          break;\n      }\n      return none;\n    };\n  };\n\nexport const StreamArray = (options?: any) => {\n  let key = 0;\n  return streamBase({\n    level: 1,\n\n    first(chunk: any) {\n      if (chunk.name !== \"startArray\") throw new Error(\"Top-level object should be an array.\");\n    },\n\n    push(asm: any, discard: any) {\n      if (asm.current.length) {\n        if (discard) {\n          ++key;\n          asm.current.pop();\n        } else {\n          return { key: key++, value: asm.current.pop() };\n        }\n      }\n      return none;\n    },\n  })(options);\n};\n", "import { List, MenuBarExtra, Icon, open, LaunchType, environment, ActionPanel, Action } from \"@raycast/api\";\nimport { existsSync } from \"node:fs\";\nimport os from \"node:os\";\nimport { useRef, useState, useCallback, useMemo } from \"react\";\nimport { usePromise, PromiseOptions } from \"./usePromise\";\nimport { useLatest } from \"./useLatest\";\nimport { showFailureToast } from \"./showFailureToast\";\nimport { baseExecuteSQL, PermissionError, isPermissionError } from \"./sql-utils\";\n\n/**\n * Executes a query on a local SQL database and returns the {@link AsyncState} corresponding to the query of the command. The last value will be kept between command runs.\n *\n * @example\n * ```\n * import { useSQL } from \"@raycast/utils\";\n * import { resolve } from \"path\";\n * import { homedir } from \"os\";\n *\n * const NOTES_DB = resolve(homedir(), \"Library/Group Containers/group.com.apple.notes/NoteStore.sqlite\");\n * const notesQuery = `SELECT id, title FROM ...`;\n * type NoteItem = {\n *   id: string;\n *   title: string;\n * };\n *\n * export default function Command() {\n *   const { isLoading, data, permissionView } = useSQL<NoteItem>(NOTES_DB, notesQuery);\n *\n *   if (permissionView) {\n *     return permissionView;\n *   }\n *\n *   return (\n *     <List isLoading={isLoading}>\n *       {(data || []).map((item) => (\n *         <List.Item key={item.id} title={item.title} />\n *       ))}\n *     </List>\n *  );\n * };\n * ```\n */\nexport function useSQL<T = unknown>(\n  databasePath: string,\n  query: string,\n  options?: {\n    /** A string explaining why the extension needs full disk access. For example, the Apple Notes extension uses `\"This is required to search your Apple Notes.\"`. While it is optional, we recommend setting it to help users understand. */\n    permissionPriming?: string;\n  } & Omit<PromiseOptions<(database: string, query: string) => Promise<T[]>>, \"abortable\">,\n) {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const { permissionPriming, ...usePromiseOptions } = options || {};\n\n  const [permissionView, setPermissionView] = useState<React.JSX.Element | null>(null);\n  const latestOptions = useLatest(options || {});\n  const abortable = useRef<AbortController>(null);\n\n  const handleError = useCallback(\n    (_error: Error) => {\n      console.error(_error);\n      const error =\n        _error instanceof Error && _error.message.includes(\"authorization denied\")\n          ? new PermissionError(\"You do not have permission to access the database.\")\n          : (_error as Error);\n\n      if (isPermissionError(error)) {\n        setPermissionView(<PermissionErrorScreen priming={latestOptions.current.permissionPriming} />);\n      } else {\n        if (latestOptions.current.onError) {\n          latestOptions.current.onError(error);\n        } else {\n          if (environment.launchType !== LaunchType.Background) {\n            showFailureToast(error, {\n              title: \"Cannot query the data\",\n            });\n          }\n        }\n      }\n    },\n    [latestOptions],\n  );\n\n  const fn = useMemo(() => {\n    if (!existsSync(databasePath)) {\n      throw new Error(\"The database does not exist\");\n    }\n\n    return async (databasePath: string, query: string) => {\n      const abortSignal = abortable.current?.signal;\n      return baseExecuteSQL<T>(databasePath, query, { signal: abortSignal });\n    };\n  }, [databasePath]);\n\n  return {\n    ...usePromise(fn, [databasePath, query], { ...usePromiseOptions, onError: handleError }),\n    permissionView,\n  };\n}\n\nfunction PermissionErrorScreen(props: { priming?: string }) {\n  const macosVenturaAndLater = parseInt(os.release().split(\".\")[0]) >= 22;\n  const preferencesString = macosVenturaAndLater ? \"Settings\" : \"Preferences\";\n\n  const action = macosVenturaAndLater\n    ? {\n        title: \"Open System Settings -> Privacy\",\n        target: \"x-apple.systempreferences:com.apple.preference.security?Privacy_AllFiles\",\n      }\n    : {\n        title: \"Open System Preferences -> Security\",\n        target: \"x-apple.systempreferences:com.apple.preference.security?Privacy_AllFiles\",\n      };\n\n  if (environment.commandMode === \"menu-bar\") {\n    return (\n      <MenuBarExtra icon={Icon.Warning} title={environment.commandName}>\n        <MenuBarExtra.Item\n          title=\"Raycast needs full disk access\"\n          tooltip={`You can revert this access in ${preferencesString} whenever you want`}\n        />\n        {props.priming ? (\n          <MenuBarExtra.Item\n            title={props.priming}\n            tooltip={`You can revert this access in ${preferencesString} whenever you want`}\n          />\n        ) : null}\n        <MenuBarExtra.Separator />\n        <MenuBarExtra.Item title={action.title} onAction={() => open(action.target)} />\n      </MenuBarExtra>\n    );\n  }\n\n  return (\n    <List>\n      <List.EmptyView\n        icon={{\n          source: {\n            light: \"https://raycast.com/uploads/extensions-utils-security-permissions-light.png\",\n            dark: \"https://raycast.com/uploads/extensions-utils-security-permissions-dark.png\",\n          },\n        }}\n        title=\"Raycast needs full disk access.\"\n        description={`${\n          props.priming ? props.priming + \"\\n\" : \"\"\n        }You can revert this access in ${preferencesString} whenever you want.`}\n        actions={\n          <ActionPanel>\n            <Action.Open {...action} />\n          </ActionPanel>\n        }\n      />\n    </List>\n  );\n}\n", "import { existsSync } from \"node:fs\";\nimport { copyFile, mkdir, writeFile } from \"node:fs/promises\";\nimport os from \"node:os\";\nimport childProcess from \"node:child_process\";\nimport path from \"node:path\";\nimport { getSpawnedPromise, getSpawnedResult } from \"./exec-utils\";\nimport { hash } from \"./helpers\";\n\nexport class PermissionError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"PermissionError\";\n  }\n}\n\nexport function isPermissionError(error: unknown): error is PermissionError {\n  return error instanceof Error && error.name === \"PermissionError\";\n}\n\nexport async function baseExecuteSQL<T = unknown>(\n  databasePath: string,\n  query: string,\n  options?: {\n    signal?: AbortSignal;\n  },\n): Promise<T[]> {\n  if (!existsSync(databasePath)) {\n    throw new Error(\"The database does not exist\");\n  }\n\n  let sqlite3: typeof import(\"node:sqlite\");\n  try {\n    // this is a bit ugly but we can't directly import \"node:sqlite\" here because parcel will hoist it anyway and it will break when it's not available\n    const dynamicImport = (module: string) => import(module);\n    sqlite3 = await dynamicImport(\"node:sqlite\");\n  } catch (error) {\n    // If sqlite3 is not available, we fallback to using the sqlite3 CLI (available on macOS and Linux by default).\n    return sqliteFallback<T>(databasePath, query, options);\n  }\n\n  let db = new sqlite3.DatabaseSync(databasePath, { open: false, readOnly: true });\n\n  const abortSignal = options?.signal;\n\n  try {\n    db.open();\n  } catch (error: any) {\n    console.log(error);\n    if (error.message.match(\"(5)\") || error.message.match(\"(14)\")) {\n      // That means that the DB is busy because of another app is locking it\n      // This happens when Chrome or Arc is opened: they lock the History db.\n      // As an ugly workaround, we duplicate the file and read that instead\n      // (with vfs unix - none to just not care about locks)\n      let workaroundCopiedDb: string | undefined;\n      if (!workaroundCopiedDb) {\n        const tempFolder = path.join(os.tmpdir(), \"useSQL\", hash(databasePath));\n        await mkdir(tempFolder, { recursive: true });\n        checkAborted(abortSignal);\n\n        workaroundCopiedDb = path.join(tempFolder, \"db.db\");\n        await copyFile(databasePath, workaroundCopiedDb);\n\n        await writeFile(workaroundCopiedDb + \"-shm\", \"\");\n        await writeFile(workaroundCopiedDb + \"-wal\", \"\");\n\n        checkAborted(abortSignal);\n      }\n\n      db = new sqlite3.DatabaseSync(workaroundCopiedDb, { open: false, readOnly: true });\n      db.open();\n      checkAborted(abortSignal);\n    }\n  }\n\n  const statement = db.prepare(query);\n  checkAborted(abortSignal);\n\n  const result = statement.all();\n\n  db.close();\n\n  return result as T[];\n}\n\nasync function sqliteFallback<T = unknown>(\n  databasePath: string,\n  query: string,\n  options?: {\n    signal?: AbortSignal;\n  },\n): Promise<T[]> {\n  const abortSignal = options?.signal;\n\n  let spawned = childProcess.spawn(\"sqlite3\", [\"--json\", \"--readonly\", databasePath, query], { signal: abortSignal });\n  let spawnedPromise = getSpawnedPromise(spawned);\n  let [{ error, exitCode, signal }, stdoutResult, stderrResult] = await getSpawnedResult<string>(\n    spawned,\n    { encoding: \"utf-8\" },\n    spawnedPromise,\n  );\n  checkAborted(abortSignal);\n\n  if (stderrResult.match(\"(5)\") || stderrResult.match(\"(14)\")) {\n    // That means that the DB is busy because of another app is locking it\n    // This happens when Chrome or Arc is opened: they lock the History db.\n    // As an ugly workaround, we duplicate the file and read that instead\n    // (with vfs unix - none to just not care about locks)\n    let workaroundCopiedDb: string | undefined;\n    if (!workaroundCopiedDb) {\n      const tempFolder = path.join(os.tmpdir(), \"useSQL\", hash(databasePath));\n      await mkdir(tempFolder, { recursive: true });\n      checkAborted(abortSignal);\n\n      workaroundCopiedDb = path.join(tempFolder, \"db.db\");\n      await copyFile(databasePath, workaroundCopiedDb);\n\n      await writeFile(workaroundCopiedDb + \"-shm\", \"\");\n      await writeFile(workaroundCopiedDb + \"-wal\", \"\");\n\n      checkAborted(abortSignal);\n    }\n\n    spawned = childProcess.spawn(\"sqlite3\", [\"--json\", \"--readonly\", \"--vfs\", \"unix-none\", workaroundCopiedDb, query], {\n      signal: abortSignal,\n    });\n    spawnedPromise = getSpawnedPromise(spawned);\n    [{ error, exitCode, signal }, stdoutResult, stderrResult] = await getSpawnedResult<string>(\n      spawned,\n      { encoding: \"utf-8\" },\n      spawnedPromise,\n    );\n    checkAborted(abortSignal);\n  }\n\n  if (error || exitCode !== 0 || signal !== null) {\n    if (stderrResult.includes(\"authorization denied\")) {\n      throw new PermissionError(\"You do not have permission to access the database.\");\n    } else {\n      throw new Error(stderrResult || \"Unknown error\");\n    }\n  }\n\n  return JSON.parse(stdoutResult.trim() || \"[]\") as T[];\n}\n\nfunction checkAborted(signal?: AbortSignal) {\n  if (signal?.aborted) {\n    const error = new Error(\"aborted\");\n    error.name = \"AbortError\";\n    throw error;\n  }\n}\n", "import { Form } from \"@raycast/api\";\nimport { useState, useCallback, useMemo, useRef, SetStateAction } from \"react\";\nimport { useLatest } from \"./useLatest\";\n\n/**\n * Shorthands for common validation cases\n */\nexport enum FormValidation {\n  /** Show an error when the value of the item is empty */\n  Required = \"required\",\n}\n\ntype ValidationError = string | undefined | null;\ntype Validator<ValueType> = ((value: ValueType | undefined) => ValidationError) | FormValidation;\n\nfunction validationError<ValueType>(\n  validation: Validator<ValueType> | undefined,\n  value: ValueType | undefined,\n): ValidationError {\n  if (validation) {\n    if (typeof validation === \"function\") {\n      return validation(value);\n    } else if (validation === FormValidation.Required) {\n      let valueIsValid = typeof value !== \"undefined\" && value !== null;\n      if (valueIsValid) {\n        switch (typeof value) {\n          case \"string\":\n            valueIsValid = value.length > 0;\n            break;\n          case \"object\":\n            if (Array.isArray(value)) {\n              valueIsValid = value.length > 0;\n            } else if (value instanceof Date) {\n              valueIsValid = value.getTime() > 0;\n            }\n            break;\n          default:\n            break;\n        }\n      }\n      if (!valueIsValid) {\n        return \"The item is required\";\n      }\n    }\n  }\n}\n\ntype Validation<T extends Form.Values> = { [id in keyof T]?: Validator<T[id]> };\n\ninterface FormProps<T extends Form.Values> {\n  /** Function to pass to the `onSubmit` prop of the `<Action.SubmitForm>` element. It wraps the initial `onSubmit` argument with some goodies related to the validation. */\n  handleSubmit: (values: T) => void | boolean | Promise<void | boolean>;\n  /** The props that must be passed to the `<Form.Item>` elements to handle the validations. */\n  itemProps: {\n    [id in keyof Required<T>]: Partial<Form.ItemProps<T[id]>> & {\n      id: string;\n    };\n  };\n  /** Function that can be used to programmatically set the validation of a specific field. */\n  setValidationError: (id: keyof T, error: ValidationError) => void;\n  /** Function that can be used to programmatically set the value of a specific field. */\n  setValue: <K extends keyof T>(id: K, value: SetStateAction<T[K]>) => void;\n  /** The current values of the form. */\n  values: T;\n  /** Function that can be used to programmatically focus a specific field. */\n  focus: (id: keyof T) => void;\n  /** Function that can be used to reset the values of the Form. */\n  reset: (initialValues?: Partial<T>) => void;\n}\n\n/**\n * Hook that provides a high-level interface to work with Forms, and more particularly, with Form validations. It incorporates all the good practices to provide a great User Experience for your Forms.\n *\n * @returns an object which contains the necessary methods and props to provide a good User Experience in your Form.\n *\n * @example\n * ```\n * import { Action, ActionPanel, Form, showToast, Toast } from \"@raycast/api\";\n * import { useForm, FormValidation } from \"@raycast/utils\";\n *\n * interface SignUpFormValues {\n *   nickname: string;\n *   password: string;\n * }\n *\n * export default function Command() {\n *   const { handleSubmit, itemProps } = useForm<SignUpFormValues>({\n *     onSubmit(values) {\n *       showToast(Toast.Style.Success, \"Yay!\", `${values.nickname} account created`);\n *     },\n *     validation: {\n *       nickname: FormValidation.Required,\n *       password: (value) => {\n *         if (value && value.length < 8) {\n *           return \"Password must be at least 8 symbols\";\n *         } else if (!value) {\n *           return \"The item is required\";\n *         }\n *       },\n *     },\n *   });\n *\n *   return (\n *     <Form\n *       actions={\n *         <ActionPanel>\n *           <Action.SubmitForm title=\"Submit\" onSubmit={handleSubmit} />\n *         </ActionPanel>\n *       }\n *     >\n *       <Form.TextField title=\"Nickname\" placeholder=\"Enter your nickname\" {...itemProps.nickname} />\n *       <Form.PasswordField\n *         title=\"Password\"\n *         placeholder=\"Enter password at least 8 characters long\"\n *         {...itemProps.password}\n *       />\n *     </Form>\n *   );\n * }\n * ```\n */\nexport function useForm<T extends Form.Values>(props: {\n  /** Callback that will be called when the form is submitted and all validations pass. */\n  onSubmit: (values: T) => void | boolean | Promise<void | boolean>;\n  /** The initial values to set when the Form is first rendered. */\n  initialValues?: Partial<T>;\n  /** The validation rules for the Form. A validation for a Form item is a function that takes the current value of the item as an argument and must return a string when the validation is failing.\n   *\n   * There are also some shorthands for common cases, see {@link FormValidation}.\n   * */\n  validation?: Validation<T>;\n}): FormProps<T> {\n  const { onSubmit: _onSubmit, validation, initialValues = {} } = props;\n\n  // @ts-expect-error it's fine if we don't specify all the values\n  const [values, setValues] = useState<T>(initialValues);\n  const [errors, setErrors] = useState<{ [id in keyof T]?: ValidationError }>({});\n  const refs = useRef<{ [id in keyof T]?: Form.ItemReference }>({});\n\n  const latestValidation = useLatest<Validation<T>>(validation || {});\n  const latestOnSubmit = useLatest(_onSubmit);\n\n  const focus = useCallback(\n    (id: keyof T) => {\n      refs.current[id]?.focus();\n    },\n    [refs],\n  );\n\n  const handleSubmit = useCallback(\n    async (values: T): Promise<boolean> => {\n      let validationErrors: false | { [key in keyof T]?: ValidationError } = false;\n      for (const [id, validation] of Object.entries(latestValidation.current)) {\n        const error = validationError(validation, values[id]);\n        if (error) {\n          if (!validationErrors) {\n            validationErrors = {};\n            // we focus the first item that has an error\n            focus(id);\n          }\n          validationErrors[id as keyof T] = error;\n        }\n      }\n      if (validationErrors) {\n        setErrors(validationErrors);\n        return false;\n      }\n      const result = await latestOnSubmit.current(values);\n      return typeof result === \"boolean\" ? result : true;\n    },\n    [latestValidation, latestOnSubmit, focus],\n  );\n\n  const setValidationError = useCallback(\n    (id: keyof T, error: ValidationError) => {\n      setErrors((errors) => ({ ...errors, [id]: error }));\n    },\n    [setErrors],\n  );\n\n  const setValue = useCallback(\n    function <K extends keyof T>(id: K, value: SetStateAction<T[K]>) {\n      // @ts-expect-error TS is always confused about SetStateAction, but it's fine here\n      setValues((values) => ({ ...values, [id]: typeof value === \"function\" ? value(values[id]) : value }));\n    },\n    [setValues],\n  );\n\n  const itemProps = useMemo<{ [id in keyof Required<T>]: Partial<Form.ItemProps<T[id]>> & { id: string } }>(() => {\n    // we have to use a proxy because we don't actually have any object to iterate through\n    // so instead we dynamically create the props when required\n    return new Proxy<{ [id in keyof Required<T>]: Partial<Form.ItemProps<T[id]>> & { id: string } }>(\n      // @ts-expect-error the whole point of a proxy...\n      {},\n      {\n        get(target, id: keyof T) {\n          const validation = latestValidation.current[id];\n          const value = values[id];\n          return {\n            onChange(value) {\n              if (errors[id]) {\n                const error = validationError(validation, value);\n                if (!error) {\n                  setValidationError(id, undefined);\n                }\n              }\n              setValue(id, value);\n            },\n            onBlur(event) {\n              const error = validationError(validation, event.target.value);\n              if (error) {\n                setValidationError(id, error);\n              }\n            },\n            error: errors[id],\n            id,\n            // we shouldn't return `undefined` otherwise it will be an uncontrolled component\n            value: typeof value === \"undefined\" ? null : value,\n            ref: (instance: Form.ItemReference) => {\n              refs.current[id] = instance;\n            },\n          } as Partial<Form.ItemProps<T[keyof T]>> & { id: string };\n        },\n      },\n    );\n  }, [errors, latestValidation, setValidationError, values, refs, setValue]);\n\n  const reset = useCallback(\n    (values?: Partial<T>) => {\n      setErrors({});\n      Object.entries(refs.current).forEach(([id, ref]) => {\n        if (!values?.[id]) {\n          ref?.reset();\n        }\n      });\n      if (values) {\n        // @ts-expect-error it's fine if we don't specify all the values\n        setValues(values);\n      }\n    },\n    [setValues, setErrors, refs],\n  );\n\n  return { handleSubmit, setValidationError, setValue, values, itemProps, focus, reset };\n}\n", "import { useRef, useState } from \"react\";\nimport { AI } from \"@raycast/api\";\nimport { PromiseOptions, usePromise } from \"./usePromise\";\nimport { FunctionReturningPromise } from \"./types\";\n\n/**\n * Stream a prompt completion.\n *\n * @example\n * ```typescript\n * import { Detail, LaunchProps } from \"@raycast/api\";\n * import { use AI } from \"@raycast/utils\";\n *\n * export default function Command(props: LaunchProps<{ arguments: { prompt: string } }>) {\n *   const { isLoading, data } = useAI(props.arguments.prompt);\n *\n *   return <Detail isLoading={isLoading} markdown={data} />;\n * }\n * ```\n */\nexport function useAI(\n  prompt: string,\n  options: {\n    /**\n     * Concrete tasks, such as fixing grammar, require less creativity while open-ended questions, such as generating ideas, require more.\n     * If a number is passed, it needs to be in the range 0-2. For larger values, 2 will be used. For lower values, 0 will be used.\n     */\n    creativity?: AI.Creativity;\n    /**\n     * The AI model to use to answer to the prompt.\n     */\n    model?: AI.Model;\n    /**\n     * Whether to stream the answer or only update the data when the entire answer has been received.\n     */\n    stream?: boolean;\n  } & Omit<PromiseOptions<FunctionReturningPromise>, \"abortable\"> = {},\n) {\n  const { creativity, stream, model, ...usePromiseOptions } = options;\n  const [data, setData] = useState(\"\");\n  const abortable = useRef<AbortController>(null);\n  const { isLoading, error, revalidate } = usePromise(\n    async (prompt: string, creativity?: AI.Creativity, shouldStream?: boolean) => {\n      setData(\"\");\n      const stream = AI.ask(prompt, { creativity, model, signal: abortable.current?.signal });\n      if (shouldStream === false) {\n        setData(await stream);\n      } else {\n        stream.on(\"data\", (data) => {\n          setData((x) => x + data);\n        });\n        await stream;\n      }\n    },\n    [prompt, creativity, stream],\n    { ...usePromiseOptions, abortable },\n  );\n\n  return { isLoading, data, error, revalidate };\n}\n", "import { useMemo, useCallback } from \"react\";\nimport { useLatest } from \"./useLatest\";\nimport { useCachedState } from \"./useCachedState\";\n\n// The algorithm below is inspired by the one used by Firefox:\n// https://wiki.mozilla.org/User:Jesse/NewFrecency\n\ntype Frecency = {\n  lastVisited: number;\n  frecency: number;\n};\n\nconst HALF_LIFE_DAYS = 10;\n\nconst MS_PER_DAY = 24 * 60 * 60 * 1000;\n\nconst VISIT_TYPE_POINTS = {\n  Default: 100,\n  Embed: 0,\n  Bookmark: 140,\n};\n\nfunction getNewFrecency(item?: Frecency): Frecency {\n  const now = Date.now();\n  const lastVisited = item ? item.lastVisited : 0;\n  const frecency = item ? item.frecency : 0;\n\n  const visitAgeInDays = (now - lastVisited) / MS_PER_DAY;\n  const DECAY_RATE_CONSTANT = Math.log(2) / (HALF_LIFE_DAYS * MS_PER_DAY);\n  const currentVisitValue = VISIT_TYPE_POINTS.Default * Math.exp(-DECAY_RATE_CONSTANT * visitAgeInDays);\n  const totalVisitValue = frecency + currentVisitValue;\n\n  return {\n    lastVisited: now,\n    frecency: totalVisitValue,\n  };\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst defaultKey = (item: any): string => {\n  if (\n    process.env.NODE_ENV !== \"production\" &&\n    (typeof item !== \"object\" || !item || !(\"id\" in item) || typeof item.id != \"string\")\n  ) {\n    throw new Error(\"Specify a key function or make sure your items have an 'id' property\");\n  }\n  return item.id;\n};\n\n/**\n * Sort an array by its frecency and provide methods to update the frecency of its items.\n * Frecency is a measure that combines frequency and recency. The more often an item is visited/used, and the more recently an item is visited/used, the higher it will rank.\n *\n * @example\n * ```\n * import { List, ActionPanel, Action, Icon } from \"@raycast/api\";\n * import { useFetch, useFrecencySorting } from \"@raycast/utils\";\n *\n * export default function Command() {\n *   const { isLoading, data } = useFetch(\"https://api.example\");\n *   const { data: sortedData, visitItem, resetRanking } = useFrecencySorting(data);\n *\n *   return (\n *     <List isLoading={isLoading}>\n *       {sortedData.map((item) => (\n *         <List.Item\n *           key={item.id}\n *           title={item.title}\n *           actions={\n *             <ActionPanel>\n *               <Action.OpenInBrowser url={item.url} onOpen={() => visitItem(item)} />\n *               <Action.CopyToClipboard title=\"Copy Link\" content={item.url} onCopy={() => visitItem(item)} />\n *               <Action title=\"Reset Ranking\" icon={Icon.ArrowCounterClockwise} onAction={() => resetRanking(item)} />\n *             </ActionPanel>\n *           }\n *         />\n *       ))}\n *     </List>\n *   );\n * };\n * ```\n */\nexport function useFrecencySorting<T extends { id: string }>(\n  data?: T[],\n  options?: { namespace?: string; key?: (item: T) => string; sortUnvisited?: (a: T, b: T) => number },\n): {\n  data: T[];\n  visitItem: (item: T) => Promise<void>;\n  resetRanking: (item: T) => Promise<void>;\n};\nexport function useFrecencySorting<T>(\n  data: T[] | undefined,\n  options: { namespace?: string; key: (item: T) => string; sortUnvisited?: (a: T, b: T) => number },\n): {\n  data: T[];\n  visitItem: (item: T) => Promise<void>;\n  resetRanking: (item: T) => Promise<void>;\n};\nexport function useFrecencySorting<T>(\n  data?: T[],\n  options?: { namespace?: string; key?: (item: T) => string; sortUnvisited?: (a: T, b: T) => number },\n): {\n  data: T[];\n  visitItem: (item: T) => Promise<void>;\n  resetRanking: (item: T) => Promise<void>;\n} {\n  const keyRef = useLatest(options?.key || defaultKey);\n  const sortUnvisitedRef = useLatest(options?.sortUnvisited);\n\n  const [storedFrecencies, setStoredFrecencies] = useCachedState<Record<string, Frecency | undefined>>(\n    `raycast_frecency_${options?.namespace}`,\n    {},\n  );\n\n  const visitItem = useCallback(\n    async function updateFrecency(item: T) {\n      const itemKey = keyRef.current(item);\n\n      setStoredFrecencies((storedFrecencies) => {\n        const frecency = storedFrecencies[itemKey];\n        const newFrecency = getNewFrecency(frecency);\n\n        return {\n          ...storedFrecencies,\n          [itemKey]: newFrecency,\n        };\n      });\n    },\n    [keyRef, setStoredFrecencies],\n  );\n\n  const resetRanking = useCallback(\n    async function removeFrecency(item: T) {\n      const itemKey = keyRef.current(item);\n\n      setStoredFrecencies((storedFrecencies) => {\n        const newFrencencies = { ...storedFrecencies };\n        delete newFrencencies[itemKey];\n\n        return newFrencencies;\n      });\n    },\n    [keyRef, setStoredFrecencies],\n  );\n\n  const sortedData = useMemo(() => {\n    if (!data) {\n      return [];\n    }\n\n    return data.sort((a, b) => {\n      const frecencyA = storedFrecencies[keyRef.current(a)];\n      const frecencyB = storedFrecencies[keyRef.current(b)];\n\n      // If a has a frecency, but b doesn't, a should come first\n      if (frecencyA && !frecencyB) {\n        return -1;\n      }\n\n      // If b has a frecency, but a doesn't, b should come first\n      if (!frecencyA && frecencyB) {\n        return 1;\n      }\n\n      // If both frecencies are defined,put the one with the higher frecency first\n      if (frecencyA && frecencyB) {\n        return frecencyB.frecency - frecencyA.frecency;\n      }\n\n      // If both frecencies are undefined, keep the original order\n      return sortUnvisitedRef.current ? sortUnvisitedRef.current(a, b) : 0;\n    });\n  }, [storedFrecencies, data, keyRef, sortUnvisitedRef]);\n\n  return { data: sortedData, visitItem, resetRanking };\n}\n", "import { LocalStorage } from \"@raycast/api\";\nimport { showFailureToast } from \"./showFailureToast\";\nimport { replacer, reviver } from \"./helpers\";\nimport { usePromise } from \"./usePromise\";\n\n/**\n * A hook to manage a value in the local storage.\n *\n * @remark The value is stored as a JSON string in the local storage.\n *\n * @param key - The key to use for the value in the local storage.\n * @param initialValue - The initial value to use if the key doesn't exist in the local storage.\n * @returns An object with the following properties:\n * - `value`: The value from the local storage or the initial value if the key doesn't exist.\n * - `setValue`: A function to update the value in the local storage.\n * - `removeValue`: A function to remove the value from the local storage.\n * - `isLoading`: A boolean indicating if the value is loading.\n *\n * @example\n * ```\n * const { value, setValue } = useLocalStorage<string>(\"my-key\");\n * const { value, setValue } = useLocalStorage<string>(\"my-key\", \"default value\");\n * ```\n */\nexport function useLocalStorage<T>(key: string, initialValue?: T) {\n  const {\n    data: value,\n    isLoading,\n    mutate,\n  } = usePromise(\n    async (storageKey: string) => {\n      const item = await LocalStorage.getItem<string>(storageKey);\n\n      return typeof item !== \"undefined\" ? (JSON.parse(item, reviver) as T) : initialValue;\n    },\n    [key],\n  );\n\n  async function setValue(value: T) {\n    try {\n      await mutate(LocalStorage.setItem(key, JSON.stringify(value, replacer)), {\n        optimisticUpdate(value) {\n          return value;\n        },\n      });\n    } catch (error) {\n      await showFailureToast(error, { title: \"Failed to set value in local storage\" });\n    }\n  }\n\n  async function removeValue() {\n    try {\n      await mutate(LocalStorage.removeItem(key), {\n        optimisticUpdate() {\n          return undefined;\n        },\n      });\n    } catch (error) {\n      await showFailureToast(error, { title: \"Failed to remove value from local storage\" });\n    }\n  }\n\n  return { value, setValue, removeValue, isLoading };\n}\n", "export { getAvatarIcon } from \"./avatar\";\nexport { getFavicon } from \"./favicon\";\nexport { getProgressIcon } from \"./progress\";\n", "import type { Image } from \"@raycast/api\";\nimport { slightlyLighterColor, slightlyDarkerColor } from \"./color\";\n\nfunction getWholeCharAndI(str: string, i: number): [string, number] {\n  const code = str.charCodeAt(i);\n\n  if (Number.isNaN(code)) {\n    return [\"\", i];\n  }\n  if (code < 0xd800 || code > 0xdfff) {\n    return [str.charAt(i), i]; // Normal character, keeping 'i' the same\n  }\n\n  // High surrogate (could change last hex to 0xDB7F to treat high private\n  // surrogates as single characters)\n  if (0xd800 <= code && code <= 0xdbff) {\n    if (str.length <= i + 1) {\n      throw new Error(\"High surrogate without following low surrogate\");\n    }\n    const next = str.charCodeAt(i + 1);\n    if (0xdc00 > next || next > 0xdfff) {\n      throw new Error(\"High surrogate without following low surrogate\");\n    }\n    return [str.charAt(i) + str.charAt(i + 1), i + 1];\n  }\n\n  // Low surrogate (0xDC00 <= code && code <= 0xDFFF)\n  if (i === 0) {\n    throw new Error(\"Low surrogate without preceding high surrogate\");\n  }\n\n  const prev = str.charCodeAt(i - 1);\n\n  // (could change last hex to 0xDB7F to treat high private surrogates\n  // as single characters)\n  if (0xd800 > prev || prev > 0xdbff) {\n    throw new Error(\"Low surrogate without preceding high surrogate\");\n  }\n\n  // Return the next character instead (and increment)\n  return [str.charAt(i + 1), i + 1];\n}\n\nconst avatarColorSet = [\n  \"#DC829A\", // Pink\n  \"#D64854\", // Red\n  \"#D47600\", // YellowOrange\n  \"#D36CDD\", // Magenta\n  \"#52A9E4\", // Aqua\n  \"#7871E8\", // Indigo\n  \"#70920F\", // YellowGreen\n  \"#43B93A\", // Green\n  \"#EB6B3E\", // Orange\n  \"#26B795\", // BlueGreen\n  \"#D85A9B\", // HotPink\n  \"#A067DC\", // Purple\n  \"#BD9500\", // Yellow\n  \"#5385D9\", // Blue\n];\n\n/**\n * Icon to represent an avatar when you don't have one. The generated avatar\n * will be generated from the initials of the name and have a colorful but consistent background.\n *\n * @returns an Image that can be used where Raycast expects them.\n *\n * @example\n * ```\n * <List.Item icon={getAvatarIcon('Mathieu Dutour')} title=\"Project\" />\n * ```\n */\nexport function getAvatarIcon(\n  name: string,\n  options?: {\n    /**\n     * Custom background color\n     */\n    background?: string;\n    /**\n     * Whether to use a gradient for the background or not.\n     * @default true\n     */\n    gradient?: boolean;\n  },\n): Image.Asset {\n  const words = name.trim().split(\" \");\n  let initials: string;\n  if (words.length == 1 && getWholeCharAndI(words[0], 0)[0]) {\n    initials = getWholeCharAndI(words[0], 0)[0];\n  } else if (words.length > 1) {\n    const firstWordFirstLetter = getWholeCharAndI(words[0], 0)[0] || \"\";\n    const lastWordFirstLetter = getWholeCharAndI(words[words.length - 1], 0)[0] ?? \"\";\n    initials = firstWordFirstLetter + lastWordFirstLetter;\n  } else {\n    initials = \"\";\n  }\n\n  let backgroundColor: string;\n\n  if (options?.background) {\n    backgroundColor = options?.background;\n  } else {\n    let initialsCharIndex = 0;\n    let [char, i] = getWholeCharAndI(initials, 0);\n    while (char) {\n      initialsCharIndex += char.charCodeAt(0);\n      [char, i] = getWholeCharAndI(initials, i + 1);\n    }\n\n    const colorIndex = initialsCharIndex % avatarColorSet.length;\n    backgroundColor = avatarColorSet[colorIndex];\n  }\n\n  const padding = 0;\n  const radius = 50 - padding;\n\n  const svg = `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100px\" height=\"100px\">\n  ${\n    options?.gradient !== false\n      ? `<defs>\n      <linearGradient id=\"Gradient\" x1=\"0.25\" x2=\"0.75\" y1=\"0\" y2=\"1\">\n        <stop offset=\"0%\" stop-color=\"${slightlyLighterColor(backgroundColor)}\"/>\n        <stop offset=\"50%\" stop-color=\"${backgroundColor}\"/>\n        <stop offset=\"100%\" stop-color=\"${slightlyDarkerColor(backgroundColor)}\"/>\n      </linearGradient>\n  </defs>`\n      : \"\"\n  }\n      <circle cx=\"50\" cy=\"50\" r=\"${radius}\" fill=\"${\n        options?.gradient !== false ? \"url(#Gradient)\" : backgroundColor\n      }\" />\n      ${\n        initials\n          ? `<text x=\"50\" y=\"80\" font-size=\"${\n              radius - 1\n            }\" font-family=\"Inter, sans-serif\" text-anchor=\"middle\" fill=\"white\">${initials.toUpperCase()}</text>`\n          : \"\"\n      }\n    </svg>\n  `.replaceAll(\"\\n\", \"\");\n  return `data:image/svg+xml,${encodeURIComponent(svg)}`;\n}\n", "function hexToRGB(hex: string) {\n  let r = 0;\n  let g = 0;\n  let b = 0;\n\n  // 3 digits\n  if (hex.length === 4) {\n    r = parseInt(`${hex[1]}${hex[1]}`, 16);\n    g = parseInt(`${hex[2]}${hex[2]}`, 16);\n    b = parseInt(`${hex[3]}${hex[3]}`, 16);\n\n    // 6 digits\n  } else if (hex.length === 7) {\n    r = parseInt(`${hex[1]}${hex[2]}`, 16);\n    g = parseInt(`${hex[3]}${hex[4]}`, 16);\n    b = parseInt(`${hex[5]}${hex[6]}`, 16);\n  } else {\n    throw new Error(`Malformed hex color: ${hex}`);\n  }\n\n  return { r, g, b };\n}\n\nfunction rgbToHex({ r, g, b }: { r: number; g: number; b: number }) {\n  let rString = r.toString(16);\n  let gString = g.toString(16);\n  let bString = b.toString(16);\n\n  if (rString.length === 1) {\n    rString = `0${rString}`;\n  }\n  if (gString.length === 1) {\n    gString = `0${gString}`;\n  }\n  if (bString.length === 1) {\n    bString = `0${bString}`;\n  }\n\n  return `#${rString}${gString}${bString}`;\n}\n\nfunction rgbToHSL({ r, g, b }: { r: number; g: number; b: number }) {\n  // Make r, g, and b fractions of 1\n  r /= 255;\n  g /= 255;\n  b /= 255;\n\n  // Find greatest and smallest channel values\n  const cmin = Math.min(r, g, b);\n  const cmax = Math.max(r, g, b);\n  const delta = cmax - cmin;\n  let h = 0;\n  let s = 0;\n  let l = 0;\n\n  // Calculate hue\n  // No difference\n  if (delta === 0) {\n    h = 0;\n  }\n  // Red is max\n  else if (cmax === r) {\n    h = ((g - b) / delta) % 6;\n  }\n  // Green is max\n  else if (cmax === g) {\n    h = (b - r) / delta + 2;\n  }\n  // Blue is max\n  else {\n    h = (r - g) / delta + 4;\n  }\n\n  h = Math.round(h * 60);\n\n  // Make negative hues positive behind 360\n  if (h < 0) {\n    h += 360;\n  }\n\n  // Calculate lightness\n  l = (cmax + cmin) / 2;\n\n  // Calculate saturation\n  s = delta === 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));\n\n  // Multiply l and s by 100\n  s = +(s * 100).toFixed(1);\n  l = +(l * 100).toFixed(1);\n\n  return { h, s, l };\n}\n\nfunction hslToRGB({ h, s, l }: { h: number; s: number; l: number }) {\n  // Must be fractions of 1\n  s /= 100;\n  l /= 100;\n\n  const c = (1 - Math.abs(2 * l - 1)) * s;\n  const x = c * (1 - Math.abs(((h / 60) % 2) - 1));\n  const m = l - c / 2;\n  let r = 0;\n  let g = 0;\n  let b = 0;\n\n  if (h >= 0 && h < 60) {\n    r = c;\n    g = x;\n    b = 0;\n  } else if (h >= 60 && h < 120) {\n    r = x;\n    g = c;\n    b = 0;\n  } else if (h >= 120 && h < 180) {\n    r = 0;\n    g = c;\n    b = x;\n  } else if (h >= 180 && h < 240) {\n    r = 0;\n    g = x;\n    b = c;\n  } else if (h >= 240 && h < 300) {\n    r = x;\n    g = 0;\n    b = c;\n  } else if (h >= 300 && h < 360) {\n    r = c;\n    g = 0;\n    b = x;\n  }\n  r = Math.round((r + m) * 255);\n  g = Math.round((g + m) * 255);\n  b = Math.round((b + m) * 255);\n\n  return { r, g, b };\n}\n\nfunction hexToHSL(hex: string) {\n  return rgbToHSL(hexToRGB(hex));\n}\n\nfunction hslToHex(hsl: { h: number; s: number; l: number }) {\n  return rgbToHex(hslToRGB(hsl));\n}\n\nfunction clamp(value: number, min: number, max: number) {\n  return min < max ? (value < min ? min : value > max ? max : value) : value < max ? max : value > min ? min : value;\n}\n\nconst offset = 12;\n\nexport function slightlyDarkerColor(hex: string) {\n  const hsl = hexToHSL(hex);\n\n  return hslToHex({\n    h: hsl.h,\n    s: hsl.s,\n    l: clamp(hsl.l - offset, 0, 100),\n  });\n}\n\nexport function slightlyLighterColor(hex: string) {\n  const hsl = hexToHSL(hex);\n\n  return hslToHex({\n    h: hsl.h,\n    s: hsl.s,\n    l: clamp(hsl.l + offset, 0, 100),\n  });\n}\n", "import { Icon, Image } from \"@raycast/api\";\nimport { URL } from \"node:url\";\n\n/**\n * Icon showing the favicon of a website.\n *\n * A favicon (favorite icon) is a tiny icon included along with a website, which is displayed in places like the browser's address bar, page tabs, and bookmarks menu.\n *\n * @param url The URL of the website to represent.\n *\n * @returns an Image that can be used where Raycast expects them.\n *\n * @example\n * ```\n * <List.Item icon={getFavicon(\"https://raycast.com\")} title=\"Raycast Website\" />\n * ```\n */\nexport function getFavicon(\n  url: string | URL,\n  options?: {\n    /**\n     * Size of the Favicon\n     * @default 64\n     */\n    size?: number;\n    /**\n     * Fallback icon in case the Favicon is not found.\n     * @default Icon.Link\n     */\n    fallback?: Image.Fallback;\n    /**\n     * A {@link Image.Mask} to apply to the Favicon.\n     */\n    mask?: Image.Mask;\n  },\n): Image.ImageLike {\n  try {\n    // a func adding https:// to the URL\n    // for cases where the URL is not a full URL\n    // e.g. \"raycast.com\"\n    const sanitize = (url: string) => {\n      if (!url.startsWith(\"http\")) {\n        return `https://${url}`;\n      }\n      return url;\n    };\n\n    const urlObj = typeof url === \"string\" ? new URL(sanitize(url)) : url;\n    const hostname = urlObj.hostname;\n\n    const faviconProvider: \"none\" | \"raycast\" | \"apple\" | \"google\" | \"duckDuckGo\" | \"duckduckgo\" | \"legacy\" =\n      (process.env.FAVICON_PROVIDER as any) ?? \"raycast\";\n\n    switch (faviconProvider) {\n      case \"none\":\n        return {\n          source: options?.fallback ?? Icon.Link,\n          mask: options?.mask,\n        };\n      case \"apple\":\n        // we can't support apple favicons as it's a native API\n        return {\n          source: options?.fallback ?? Icon.Link,\n          mask: options?.mask,\n        };\n      case \"duckduckgo\":\n      case \"duckDuckGo\":\n        return {\n          source: `https://icons.duckduckgo.com/ip3/${hostname}.ico`,\n          fallback: options?.fallback ?? Icon.Link,\n          mask: options?.mask,\n        };\n      case \"google\":\n        return {\n          source: `https://www.google.com/s2/favicons?sz=${options?.size ?? 64}&domain=${hostname}`,\n          fallback: options?.fallback ?? Icon.Link,\n          mask: options?.mask,\n        };\n      case \"legacy\":\n      case \"raycast\":\n      default:\n        return {\n          source: `https://api.ray.so/favicon?url=${hostname}&size=${options?.size ?? 64}`,\n          fallback: options?.fallback ?? Icon.Link,\n          mask: options?.mask,\n        };\n    }\n  } catch (e) {\n    console.error(e);\n    return Icon.Link;\n  }\n}\n", "import { environment, Color } from \"@raycast/api\";\nimport type { Image } from \"@raycast/api\";\n\nfunction polarToCartesian(centerX: number, centerY: number, radius: number, angleInDegrees: number) {\n  const angleInRadians = ((angleInDegrees - 90) * Math.PI) / 180.0;\n\n  return {\n    x: centerX + radius * Math.cos(angleInRadians),\n    y: centerY + radius * Math.sin(angleInRadians),\n  };\n}\n\nfunction describeArc(x: number, y: number, radius: number, startAngle: number, endAngle: number) {\n  const start = polarToCartesian(x, y, radius, endAngle);\n  const end = polarToCartesian(x, y, radius, startAngle);\n\n  const largeArcFlag = endAngle - startAngle <= 180 ? \"0\" : \"1\";\n\n  const d = [\"M\", start.x, start.y, \"A\", radius, radius, 0, largeArcFlag, 0, end.x, end.y].join(\" \");\n\n  return d;\n}\n\n/**\n * Icon to represent the progress of _something_.\n *\n * @param progress Number between 0 and 1.\n * @param color Hex color (default `\"#FF6363\"`) or Color.\n *\n * @returns an Image that can be used where Raycast expects them.\n *\n * @example\n * ```\n * <List.Item icon={getProgressIcon(0.1)} title=\"Project\" />\n * ```\n */\nexport function getProgressIcon(\n  progress: number,\n  color: Color | string = Color.Red,\n  options?: { background?: Color | string; backgroundOpacity?: number },\n): Image.Asset {\n  const background = options?.background || (environment.appearance === \"light\" ? \"black\" : \"white\");\n  const backgroundOpacity = options?.backgroundOpacity || 0.1;\n\n  const stroke = 10;\n  const padding = 5;\n  const radius = 50 - padding - stroke / 2;\n\n  const svg = `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100px\" height=\"100px\">\n      <circle cx=\"50\" cy=\"50\" r=\"${radius}\" stroke-width=\"${stroke}\" stroke=\"${\n        progress < 1 ? background : color\n      }\" opacity=\"${progress < 1 ? backgroundOpacity : \"1\"}\" fill=\"none\" />\n      ${\n        progress > 0 && progress < 1\n          ? `<path d=\"${describeArc(\n              50,\n              50,\n              radius,\n              0,\n              progress * 360,\n            )}\" stroke=\"${color}\" stroke-width=\"${stroke}\" fill=\"none\" />`\n          : \"\"\n      }\n    </svg>\n  `.replaceAll(\"\\n\", \"\");\n  return `data:image/svg+xml,${encodeURIComponent(svg)}`;\n}\n", "export { OAuthService } from \"./OAuthService\";\nexport { withAccessToken, getAccessToken } from \"./withAccessToken\";\n\nexport type { WithAccessTokenComponentOrFn } from \"./withAccessToken\";\nexport type {\n  OnAuthorizeParams,\n  OAuthServiceOptions,\n  ProviderWithDefaultClientOptions,\n  ProviderOptions,\n} from \"./types\";\n", "import { Color, OAuth } from \"@raycast/api\";\nimport { PROVIDER_CLIENT_IDS } from \"./providers\";\nimport type {\n  OAuthServiceOptions,\n  OnAuthorizeParams,\n  ProviderOptions,\n  ProviderWithDefaultClientOptions,\n} from \"./types\";\n\n/**\n * Class allowing to create an OAuth service using the the PKCE (Proof Key for Code Exchange) flow.\n *\n * This service is capable of starting the authorization process, fetching and refreshing tokens,\n * as well as managing the authentication state.\n *\n * @example\n * ```typescript\n * const oauthClient = new OAuth.PKCEClient({ ... });\n * const oauthService = new OAuthService({\n *   client: oauthClient,\n *   clientId: 'your-client-id',\n *   scope: 'required scopes',\n *   authorizeUrl: 'https://provider.com/oauth/authorize',\n *   tokenUrl: 'https://provider.com/oauth/token',\n *   refreshTokenUrl: 'https://provider.com/oauth/token',\n *   extraParameters: { 'additional_param': 'value' }\n * });\n * ```\n */\nexport class OAuthService implements OAuthServiceOptions {\n  public clientId: string;\n  public scope: string;\n  public client: OAuth.PKCEClient;\n  public extraParameters?: Record<string, string>;\n  public authorizeUrl: string;\n  public tokenUrl: string;\n  public refreshTokenUrl?: string;\n  public bodyEncoding?: \"json\" | \"url-encoded\";\n  public personalAccessToken?: string;\n  onAuthorize?: (params: OnAuthorizeParams) => void;\n  tokenResponseParser: (response: unknown) => OAuth.TokenResponse;\n  tokenRefreshResponseParser: (response: unknown) => OAuth.TokenResponse;\n\n  constructor(options: OAuthServiceOptions) {\n    this.clientId = options.clientId;\n    this.scope = Array.isArray(options.scope) ? options.scope.join(\" \") : options.scope;\n    this.personalAccessToken = options.personalAccessToken;\n    this.bodyEncoding = options.bodyEncoding;\n    this.client = options.client;\n    this.extraParameters = options.extraParameters;\n    this.authorizeUrl = options.authorizeUrl;\n    this.tokenUrl = options.tokenUrl;\n    this.refreshTokenUrl = options.refreshTokenUrl;\n    this.onAuthorize = options.onAuthorize;\n    this.tokenResponseParser = options.tokenResponseParser ?? ((x) => x as OAuth.TokenResponse);\n    this.tokenRefreshResponseParser = options.tokenRefreshResponseParser ?? ((x) => x as OAuth.TokenResponse);\n    this.authorize = this.authorize.bind(this);\n  }\n\n  /**\n   * Asana OAuth service provided out of the box.\n   *\n   * @example\n   * ```typescript\n   * const asana = OAuthService.asana({ scope: 'default' })\n   * ```\n   */\n  public static asana(options: ProviderWithDefaultClientOptions) {\n    return new OAuthService({\n      client: new OAuth.PKCEClient({\n        redirectMethod: OAuth.RedirectMethod.Web,\n        providerName: \"Asana\",\n        providerIcon: `data:image/svg+xml,${encodeURIComponent(\n          `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"251\" height=\"232\" fill=\"none\"><path fill=\"#F06A6A\" d=\"M179.383 54.373c0 30.017-24.337 54.374-54.354 54.374-30.035 0-54.373-24.338-54.373-54.374C70.656 24.338 94.993 0 125.029 0c30.017 0 54.354 24.338 54.354 54.373ZM54.393 122.33C24.376 122.33.02 146.668.02 176.685c0 30.017 24.337 54.373 54.373 54.373 30.035 0 54.373-24.338 54.373-54.373 0-30.017-24.338-54.355-54.373-54.355Zm141.253 0c-30.035 0-54.373 24.338-54.373 54.374 0 30.035 24.338 54.373 54.373 54.373 30.017 0 54.374-24.338 54.374-54.373 0-30.036-24.338-54.374-54.374-54.374Z\"/></svg>`,\n        )}`,\n        providerId: \"asana\",\n        description: \"Connect your Asana account\",\n      }),\n      clientId: options.clientId ?? PROVIDER_CLIENT_IDS.asana,\n      authorizeUrl: options.authorizeUrl ?? \"https://asana.oauth.raycast.com/authorize\",\n      tokenUrl: options.tokenUrl ?? \"https://asana.oauth.raycast.com/token\",\n      refreshTokenUrl: options.refreshTokenUrl ?? \"https://asana.oauth.raycast.com/refresh-token\",\n      scope: options.scope,\n      personalAccessToken: options.personalAccessToken,\n      onAuthorize: options.onAuthorize,\n      bodyEncoding: options.bodyEncoding,\n      tokenRefreshResponseParser: options.tokenRefreshResponseParser,\n      tokenResponseParser: options.tokenResponseParser,\n    });\n  }\n\n  /**\n   * GitHub OAuth service provided out of the box.\n   *\n   * @example\n   * ```typescript\n   * const github = OAuthService.github({ scope: 'repo user' })\n   * ```\n   */\n  public static github(options: ProviderWithDefaultClientOptions) {\n    return new OAuthService({\n      client: new OAuth.PKCEClient({\n        redirectMethod: OAuth.RedirectMethod.Web,\n        providerName: \"GitHub\",\n        providerIcon: {\n          source: `data:image/svg+xml,${encodeURIComponent(\n            `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"64\" height=\"64\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z\"/></svg>`,\n          )}`,\n\n          tintColor: Color.PrimaryText,\n        },\n        providerId: \"github\",\n        description: \"Connect your GitHub account\",\n      }),\n      clientId: options.clientId ?? PROVIDER_CLIENT_IDS.github,\n      authorizeUrl: options.authorizeUrl ?? \"https://github.oauth.raycast.com/authorize\",\n      tokenUrl: options.tokenUrl ?? \"https://github.oauth.raycast.com/token\",\n      refreshTokenUrl: options.refreshTokenUrl ?? \"https://github.oauth.raycast.com/refresh-token\",\n      scope: options.scope,\n      personalAccessToken: options.personalAccessToken,\n      onAuthorize: options.onAuthorize,\n      bodyEncoding: options.bodyEncoding,\n      tokenRefreshResponseParser: options.tokenRefreshResponseParser,\n      tokenResponseParser: options.tokenResponseParser,\n    });\n  }\n\n  /**\n   * Google OAuth service provided out of the box.\n   *\n   * @example\n   * ```typescript\n   * const google = OAuthService.google({\n   *   clientId: 'custom-client-id',\n   *   authorizeUrl: 'https://accounts.google.com/o/oauth2/v2/auth',\n   *   tokenUrl: 'https://oauth2.googleapis.com/token',\n   *   scope: 'https://www.googleapis.com/auth/drive.readonly',\n   * });\n   * ```\n   */\n  public static google(options: ProviderOptions) {\n    return new OAuthService({\n      client: new OAuth.PKCEClient({\n        redirectMethod: OAuth.RedirectMethod.AppURI,\n        providerName: \"Google\",\n        providerIcon: `data:image/svg+xml,${encodeURIComponent(\n          `<svg xmlns=\"http://www.w3.org/2000/svg\" style=\"display:block\" viewBox=\"0 0 48 48\"><path fill=\"#EA4335\" d=\"M24 9.5c3.54 0 6.71 1.22 9.21 3.6l6.85-6.85C35.9 2.38 30.47 0 24 0 14.62 0 6.51 5.38 2.56 13.22l7.98 6.19C12.43 13.72 17.74 9.5 24 9.5z\"/><path fill=\"#4285F4\" d=\"M46.98 24.55c0-1.57-.15-3.09-.38-4.55H24v9.02h12.94c-.58 2.96-2.26 5.48-4.78 7.18l7.73 6c4.51-4.18 7.09-10.36 7.09-17.65z\"/><path fill=\"#FBBC05\" d=\"M10.53 28.59c-.48-1.45-.76-2.99-.76-4.59s.27-3.14.76-4.59l-7.98-6.19C.92 16.46 0 20.12 0 24c0 3.88.92 7.54 2.56 10.78l7.97-6.19z\"/><path fill=\"#34A853\" d=\"M24 48c6.48 0 11.93-2.13 15.89-5.81l-7.73-6c-2.15 1.45-4.92 2.3-8.16 2.3-6.26 0-11.57-4.22-13.47-9.91l-7.98 6.19C6.51 42.62 14.62 48 24 48z\"/><path fill=\"none\" d=\"M0 0h48v48H0z\"/></svg>`,\n        )}`,\n        providerId: \"google\",\n        description: \"Connect your Google account\",\n      }),\n      clientId: options.clientId,\n      authorizeUrl: options.authorizeUrl ?? \"https://accounts.google.com/o/oauth2/v2/auth\",\n      tokenUrl: options.tokenUrl ?? \"https://oauth2.googleapis.com/token\",\n      refreshTokenUrl: options.tokenUrl,\n      scope: options.scope,\n      personalAccessToken: options.personalAccessToken,\n      bodyEncoding: options.bodyEncoding ?? \"url-encoded\",\n      onAuthorize: options.onAuthorize,\n      tokenRefreshResponseParser: options.tokenRefreshResponseParser,\n      tokenResponseParser: options.tokenResponseParser,\n    });\n  }\n\n  /**\n   * Jira OAuth service provided out of the box.\n   *\n   * @example\n   * ```typescript\n   * const jira = OAuthService.jira({\n   *   clientId: 'custom-client-id',\n   *   authorizeUrl: 'https://auth.atlassian.com/authorize',\n   *   tokenUrl: 'https://api.atlassian.com/oauth/token',\n   *   scope: 'read:jira-user read:jira-work offline_access'\n   * });\n   * ```\n   */\n  public static jira(options: ProviderOptions) {\n    return new OAuthService({\n      client: new OAuth.PKCEClient({\n        redirectMethod: OAuth.RedirectMethod.Web,\n        providerName: \"Jira\",\n        providerIcon: `data:image/svg+xml,${encodeURIComponent(\n          `<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"2361\" height=\"2500\" viewBox=\"2.59 0 214.091 224\"><linearGradient id=\"a\" x1=\"102.4\" x2=\"56.15\" y1=\"218.63\" y2=\"172.39\" gradientTransform=\"matrix(1 0 0 -1 0 264)\" gradientUnits=\"userSpaceOnUse\"><stop offset=\".18\" stop-color=\"#0052cc\"/><stop offset=\"1\" stop-color=\"#2684ff\"/></linearGradient><linearGradient xlink:href=\"#a\" id=\"b\" x1=\"114.65\" x2=\"160.81\" y1=\"85.77\" y2=\"131.92\"/><path fill=\"#2684ff\" d=\"M214.06 105.73 117.67 9.34 108.33 0 35.77 72.56 2.59 105.73a8.89 8.89 0 0 0 0 12.54l66.29 66.29L108.33 224l72.55-72.56 1.13-1.12 32.05-32a8.87 8.87 0 0 0 0-12.59zm-105.73 39.39L75.21 112l33.12-33.12L141.44 112z\"/><path fill=\"url(#a)\" d=\"M108.33 78.88a55.75 55.75 0 0 1-.24-78.61L35.62 72.71l39.44 39.44z\"/><path fill=\"url(#b)\" d=\"m141.53 111.91-33.2 33.21a55.77 55.77 0 0 1 0 78.86L181 151.35z\"/></svg>`,\n        )}`,\n        providerId: \"jira\",\n        description: \"Connect your Jira account\",\n      }),\n      clientId: options.clientId,\n      authorizeUrl: options.authorizeUrl ?? \"https://auth.atlassian.com/authorize\",\n      tokenUrl: options.tokenUrl ?? \"https://auth.atlassian.com/oauth/token\",\n      refreshTokenUrl: options.refreshTokenUrl,\n      scope: options.scope,\n      personalAccessToken: options.personalAccessToken,\n      onAuthorize: options.onAuthorize,\n      bodyEncoding: options.bodyEncoding,\n      tokenRefreshResponseParser: options.tokenRefreshResponseParser,\n      tokenResponseParser: options.tokenResponseParser,\n    });\n  }\n\n  /**\n   * Linear OAuth service provided out of the box.\n   *\n   * @example\n   * ```typescript\n   * const linear = OAuthService.linear({ scope: 'read write' })\n   * ```\n   */\n  public static linear(options: ProviderWithDefaultClientOptions) {\n    return new OAuthService({\n      client: new OAuth.PKCEClient({\n        redirectMethod: OAuth.RedirectMethod.Web,\n        providerName: \"Linear\",\n        providerIcon: {\n          source: {\n            light: `data:image/svg+xml,${encodeURIComponent(\n              `<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"#222326\" width=\"200\" height=\"200\" viewBox=\"0 0 100 100\"><path d=\"M1.22541 61.5228c-.2225-.9485.90748-1.5459 1.59638-.857L39.3342 97.1782c.6889.6889.0915 1.8189-.857 1.5964C20.0515 94.4522 5.54779 79.9485 1.22541 61.5228ZM.00189135 46.8891c-.01764375.2833.08887215.5599.28957165.7606L52.3503 99.7085c.2007.2007.4773.3075.7606.2896 2.3692-.1476 4.6938-.46 6.9624-.9259.7645-.157 1.0301-1.0963.4782-1.6481L2.57595 39.4485c-.55186-.5519-1.49117-.2863-1.648174.4782-.465915 2.2686-.77832 4.5932-.92588465 6.9624ZM4.21093 29.7054c-.16649.3738-.08169.8106.20765 1.1l64.77602 64.776c.2894.2894.7262.3742 1.1.2077 1.7861-.7956 3.5171-1.6927 5.1855-2.684.5521-.328.6373-1.0867.1832-1.5407L8.43566 24.3367c-.45409-.4541-1.21271-.3689-1.54074.1832-.99132 1.6684-1.88843 3.3994-2.68399 5.1855ZM12.6587 18.074c-.3701-.3701-.393-.9637-.0443-1.3541C21.7795 6.45931 35.1114 0 49.9519 0 77.5927 0 100 22.4073 100 50.0481c0 14.8405-6.4593 28.1724-16.7199 37.3375-.3903.3487-.984.3258-1.3542-.0443L12.6587 18.074Z\"/></svg>`,\n            )}`,\n            dark: `data:image/svg+xml,${encodeURIComponent(\n              `<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"#fff\" width=\"200\" height=\"200\" viewBox=\"0 0 100 100\"><path d=\"M1.22541 61.5228c-.2225-.9485.90748-1.5459 1.59638-.857L39.3342 97.1782c.6889.6889.0915 1.8189-.857 1.5964C20.0515 94.4522 5.54779 79.9485 1.22541 61.5228ZM.00189135 46.8891c-.01764375.2833.08887215.5599.28957165.7606L52.3503 99.7085c.2007.2007.4773.3075.7606.2896 2.3692-.1476 4.6938-.46 6.9624-.9259.7645-.157 1.0301-1.0963.4782-1.6481L2.57595 39.4485c-.55186-.5519-1.49117-.2863-1.648174.4782-.465915 2.2686-.77832 4.5932-.92588465 6.9624ZM4.21093 29.7054c-.16649.3738-.08169.8106.20765 1.1l64.77602 64.776c.2894.2894.7262.3742 1.1.2077 1.7861-.7956 3.5171-1.6927 5.1855-2.684.5521-.328.6373-1.0867.1832-1.5407L8.43566 24.3367c-.45409-.4541-1.21271-.3689-1.54074.1832-.99132 1.6684-1.88843 3.3994-2.68399 5.1855ZM12.6587 18.074c-.3701-.3701-.393-.9637-.0443-1.3541C21.7795 6.45931 35.1114 0 49.9519 0 77.5927 0 100 22.4073 100 50.0481c0 14.8405-6.4593 28.1724-16.7199 37.3375-.3903.3487-.984.3258-1.3542-.0443L12.6587 18.074Z\" /></svg>`,\n            )}`,\n          },\n        },\n        providerId: \"linear\",\n        description: \"Connect your Linear account\",\n      }),\n      clientId: options.clientId ?? PROVIDER_CLIENT_IDS.linear,\n      authorizeUrl: options.authorizeUrl ?? \"https://linear.oauth.raycast.com/authorize\",\n      tokenUrl: options.tokenUrl ?? \"https://linear.oauth.raycast.com/token\",\n      refreshTokenUrl: options.refreshTokenUrl ?? \"https://linear.oauth.raycast.com/refresh-token\",\n      scope: options.scope,\n      extraParameters: {\n        actor: \"user\",\n      },\n      onAuthorize: options.onAuthorize,\n      bodyEncoding: options.bodyEncoding,\n      tokenRefreshResponseParser: options.tokenRefreshResponseParser,\n      tokenResponseParser: options.tokenResponseParser,\n    });\n  }\n\n  /**\n   * Slack OAuth service provided out of the box.\n   *\n   * @example\n   * ```typescript\n   * const slack = OAuthService.slack({ scope: 'emoji:read' })\n   * ```\n   */\n  public static slack(options: ProviderWithDefaultClientOptions) {\n    return new OAuthService({\n      client: new OAuth.PKCEClient({\n        redirectMethod: OAuth.RedirectMethod.Web,\n        providerName: \"Slack\",\n        providerIcon: `data:image/svg+xml,${encodeURIComponent(\n          `<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"73 73 124 124\"><style>.st0{fill:#e01e5a}.st1{fill:#36c5f0}.st2{fill:#2eb67d}.st3{fill:#ecb22e}</style><path d=\"M99.4 151.2c0 7.1-5.8 12.9-12.9 12.9-7.1 0-12.9-5.8-12.9-12.9 0-7.1 5.8-12.9 12.9-12.9h12.9v12.9zM105.9 151.2c0-7.1 5.8-12.9 12.9-12.9s12.9 5.8 12.9 12.9v32.3c0 7.1-5.8 12.9-12.9 12.9s-12.9-5.8-12.9-12.9v-32.3z\" class=\"st0\"/><path d=\"M118.8 99.4c-7.1 0-12.9-5.8-12.9-12.9 0-7.1 5.8-12.9 12.9-12.9s12.9 5.8 12.9 12.9v12.9h-12.9zM118.8 105.9c7.1 0 12.9 5.8 12.9 12.9s-5.8 12.9-12.9 12.9H86.5c-7.1 0-12.9-5.8-12.9-12.9s5.8-12.9 12.9-12.9h32.3z\" class=\"st1\"/><path d=\"M170.6 118.8c0-7.1 5.8-12.9 12.9-12.9 7.1 0 12.9 5.8 12.9 12.9s-5.8 12.9-12.9 12.9h-12.9v-12.9zM164.1 118.8c0 7.1-5.8 12.9-12.9 12.9-7.1 0-12.9-5.8-12.9-12.9V86.5c0-7.1 5.8-12.9 12.9-12.9 7.1 0 12.9 5.8 12.9 12.9v32.3z\" class=\"st2\"/><path d=\"M151.2 170.6c7.1 0 12.9 5.8 12.9 12.9 0 7.1-5.8 12.9-12.9 12.9-7.1 0-12.9-5.8-12.9-12.9v-12.9h12.9zM151.2 164.1c-7.1 0-12.9-5.8-12.9-12.9 0-7.1 5.8-12.9 12.9-12.9h32.3c7.1 0 12.9 5.8 12.9 12.9 0 7.1-5.8 12.9-12.9 12.9h-32.3z\" class=\"st3\"/></svg>`,\n        )}`,\n        providerId: \"slack\",\n        description: \"Connect your Slack account\",\n      }),\n      clientId: options.clientId ?? PROVIDER_CLIENT_IDS.slack,\n      authorizeUrl: options.authorizeUrl ?? \"https://slack.oauth.raycast.com/authorize\",\n      tokenUrl: options.tokenUrl ?? \"https://slack.oauth.raycast.com/token\",\n      refreshTokenUrl: options.tokenUrl ?? \"https://slack.oauth.raycast.com/refresh-token\",\n      scope: \"\",\n      extraParameters: {\n        user_scope: options.scope,\n      },\n      personalAccessToken: options.personalAccessToken,\n      bodyEncoding: options.tokenUrl ? options.bodyEncoding ?? \"url-encoded\" : \"json\",\n      onAuthorize: options.onAuthorize,\n      tokenRefreshResponseParser: options.tokenRefreshResponseParser,\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      tokenResponseParser:\n        options.tokenResponseParser ??\n        ((response: any) => {\n          return {\n            access_token: response.authed_user.access_token,\n            scope: response.authed_user.scope,\n          };\n        }),\n    });\n  }\n\n  /**\n   * Zoom OAuth service provided out of the box.\n   *\n   * @example\n   * ```typescript\n   * const zoom = OAuthService.zoom({\n   *   clientId: 'custom-client-id',\n   *   authorizeUrl: 'https://zoom.us/oauth/authorize',\n   *   tokenUrl: 'https://zoom.us/oauth/token',\n   *   scope: 'meeting:write',\n   *   personalAccessToken: 'personal-access-token',\n   * });\n   * ```\n   */\n  public static zoom(options: ProviderOptions) {\n    return new OAuthService({\n      client: new OAuth.PKCEClient({\n        redirectMethod: OAuth.RedirectMethod.Web,\n        providerName: \"Zoom\",\n        providerIcon: `data:image/svg+xml,${encodeURIComponent(\n          `<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 351.845 80\"><path d=\"M73.786 78.835H10.88A10.842 10.842 0 0 1 .833 72.122a10.841 10.841 0 0 1 2.357-11.85L46.764 16.7h-31.23C6.954 16.699 0 9.744 0 1.165h58.014c4.414 0 8.357 2.634 10.046 6.712a10.843 10.843 0 0 1-2.356 11.85L22.13 63.302h36.122c8.58 0 15.534 6.955 15.534 15.534Zm278.059-48.544C351.845 13.588 338.256 0 321.553 0c-8.934 0-16.975 3.89-22.524 10.063C293.48 3.89 285.44 0 276.505 0c-16.703 0-30.291 13.588-30.291 30.291v48.544c8.579 0 15.534-6.955 15.534-15.534v-33.01c0-8.137 6.62-14.757 14.757-14.757s14.757 6.62 14.757 14.757v33.01c0 8.58 6.955 15.534 15.534 15.534V30.291c0-8.137 6.62-14.757 14.757-14.757s14.758 6.62 14.758 14.757v33.01c0 8.58 6.954 15.534 15.534 15.534V30.291ZM238.447 40c0 22.091-17.909 40-40 40s-40-17.909-40-40 17.908-40 40-40 40 17.909 40 40Zm-15.534 0c0-13.512-10.954-24.466-24.466-24.466S173.98 26.488 173.98 40s10.953 24.466 24.466 24.466S222.913 53.512 222.913 40Zm-70.68 0c0 22.091-17.909 40-40 40s-40-17.909-40-40 17.909-40 40-40 40 17.909 40 40Zm-15.534 0c0-13.512-10.954-24.466-24.466-24.466S87.767 26.488 87.767 40s10.954 24.466 24.466 24.466S136.699 53.512 136.699 40Z\" style=\"fill:#0b5cff\"/></svg>`,\n        )}`,\n        providerId: \"zoom\",\n        description: \"Connect your Zoom account\",\n      }),\n      clientId: options.clientId,\n      authorizeUrl: options.authorizeUrl ?? \"https://zoom.us/oauth/authorize\",\n      tokenUrl: options.tokenUrl ?? \"https://zoom.us/oauth/token\",\n      refreshTokenUrl: options.refreshTokenUrl,\n      scope: options.scope,\n      personalAccessToken: options.personalAccessToken,\n      bodyEncoding: options.bodyEncoding ?? \"url-encoded\",\n      onAuthorize: options.onAuthorize,\n      tokenRefreshResponseParser: options.tokenRefreshResponseParser,\n      tokenResponseParser: options.tokenResponseParser,\n    });\n  }\n\n  /**\n   * Initiates the OAuth authorization process or refreshes existing tokens if necessary.\n   * If the current token set has a refresh token and it is expired, then the function will refresh the tokens.\n   * If no tokens exist, it will initiate the OAuth authorization process and fetch the tokens.\n   *\n   * @returns {Promise<string>} A promise that resolves with the access token obtained from the authorization flow, or null if the token could not be obtained.\n   */\n  async authorize() {\n    const currentTokenSet = await this.client.getTokens();\n    if (currentTokenSet?.accessToken) {\n      if (currentTokenSet.refreshToken && currentTokenSet.isExpired()) {\n        const tokens = await this.refreshTokens({\n          token: currentTokenSet.refreshToken,\n        });\n\n        // In the case where the refresh token flows fails, nothing is returned and the authorize function is called again.\n        if (tokens) {\n          await this.client.setTokens(tokens);\n          return tokens.access_token;\n        }\n      }\n      return currentTokenSet.accessToken;\n    }\n\n    const authRequest = await this.client.authorizationRequest({\n      endpoint: this.authorizeUrl,\n      clientId: this.clientId,\n      scope: this.scope,\n      extraParameters: this.extraParameters,\n    });\n\n    const { authorizationCode } = await this.client.authorize(authRequest);\n    const tokens = await this.fetchTokens({\n      authRequest,\n      authorizationCode,\n    });\n\n    await this.client.setTokens(tokens);\n\n    return tokens.access_token;\n  }\n\n  private async fetchTokens({\n    authRequest,\n    authorizationCode,\n  }: {\n    authRequest: OAuth.AuthorizationRequest;\n    authorizationCode: string;\n  }) {\n    let options;\n    if (this.bodyEncoding === \"url-encoded\") {\n      const params = new URLSearchParams();\n      params.append(\"client_id\", this.clientId);\n      params.append(\"code\", authorizationCode);\n      params.append(\"code_verifier\", authRequest.codeVerifier);\n      params.append(\"grant_type\", \"authorization_code\");\n      params.append(\"redirect_uri\", authRequest.redirectURI);\n\n      options = { body: params };\n    } else {\n      options = {\n        body: JSON.stringify({\n          client_id: this.clientId,\n          code: authorizationCode,\n          code_verifier: authRequest.codeVerifier,\n          grant_type: \"authorization_code\",\n          redirect_uri: authRequest.redirectURI,\n        }),\n        headers: { \"Content-Type\": \"application/json\" },\n      };\n    }\n\n    const response = await fetch(this.tokenUrl, { method: \"POST\", ...options });\n    if (!response.ok) {\n      const responseText = await response.text();\n      console.error(\"fetch tokens error:\", responseText);\n      throw new Error(`Error while fetching tokens: ${response.status} (${response.statusText})\\n${responseText}`);\n    }\n    const tokens = this.tokenResponseParser(await response.json());\n\n    // Some clients such as Linear can return a scope array instead of a string\n    return Array.isArray(tokens.scope) ? { ...tokens, scope: tokens.scope.join(\" \") } : tokens;\n  }\n\n  private async refreshTokens({ token }: { token: string }) {\n    let options;\n    if (this.bodyEncoding === \"url-encoded\") {\n      const params = new URLSearchParams();\n      params.append(\"client_id\", this.clientId);\n      params.append(\"refresh_token\", token);\n      params.append(\"grant_type\", \"refresh_token\");\n\n      options = { body: params };\n    } else {\n      options = {\n        body: JSON.stringify({\n          client_id: this.clientId,\n          refresh_token: token,\n          grant_type: \"refresh_token\",\n        }),\n        headers: { \"Content-Type\": \"application/json\" },\n      };\n    }\n\n    const response = await fetch(this.refreshTokenUrl ?? this.tokenUrl, { method: \"POST\", ...options });\n    if (!response.ok) {\n      const responseText = await response.text();\n      console.error(\"refresh tokens error:\", responseText);\n      // If the refresh token is invalid, stop the flow here, log out the user and prompt them to re-authorize.\n      this.client.description = `${this.client.providerName} needs you to sign-in again. Press  or click the button below to continue.`;\n      await this.client.removeTokens();\n      await this.authorize();\n    } else {\n      const tokenResponse = this.tokenRefreshResponseParser(await response.json());\n      tokenResponse.refresh_token = tokenResponse.refresh_token ?? token;\n      return tokenResponse;\n    }\n  }\n}\n", "export const PROVIDER_CLIENT_IDS = {\n  asana: \"1191201745684312\",\n  github: \"7235fe8d42157f1f38c0\",\n  linear: \"c8ff37b9225c3c9aefd7d66ea0e5b6f1\",\n  slack: \"851756884692.5546927290212\",\n};\n", "import React from \"react\";\nimport { environment, OAuth } from \"@raycast/api\";\nimport type { OAuthType, OnAuthorizeParams } from \"./types\";\n\nlet token: string | null = null;\nlet type: OAuthType | null = null;\nlet authorize: Promise<string> | null = null;\nlet getIdToken: Promise<string | undefined> | null = null;\nlet onAuthorize: Promise<void> | null = null;\n\ntype WithAccessTokenParameters = {\n  /**\n   * An optional instance of a PKCE Client that you can create using Raycast API.\n   * This client is used to return the `idToken` as part of the `onAuthorize` callback.\n   */\n  client?: OAuth.PKCEClient;\n  /**\n   * A function that initiates the OAuth token retrieval process\n   * @returns a promise that resolves to an access token.\n   */\n  authorize: () => Promise<string>;\n  /**\n   * An optional string that represents an already obtained personal access token\n   */\n  personalAccessToken?: string;\n  /**\n   * An optional callback function that is called once the user has been properly logged in through OAuth.\n   * @param {object} params - Parameters of the callback\n   * @param {string} options.token - The retrieved access token\n   * @param {string} options.type - The access token's type (either `oauth` or `personal`)\n   * @param {string} options.idToken - The optional id token. The `idToken` is returned if `options.client` is provided and if it's returned in the initial token set.\n   */\n  onAuthorize?: (params: OnAuthorizeParams) => void;\n};\n\n/**\n * The component (for a view/menu-bar commands) or function (for a no-view command) that is passed to withAccessToken.\n */\nexport type WithAccessTokenComponentOrFn<T = any, U = any> = ((params: T) => Promise<U> | U) | React.ComponentType<T>;\n\n/**\n * Higher-order component to wrap a given component or function and set an access token in a shared global variable.\n *\n * The function intercepts the component rendering process to either fetch an OAuth token asynchronously\n * or use a provided personal access token. A global variable will be then set with the received token\n * that you can get with the `getAccessToken` function.\n *\n * @example\n * ```typescript\n * import { Detail } from \"@raycast/api\";\n * import { OAuthService, getAccessToken, withAccessToken } from \"@raycast/utils\";\n *\n * const github = OAuthService.github({ scope: \"notifications repo read:org read:user read:project\" });\n *\n * function AuthorizedComponent() {\n *  const { token } = getAccessToken();\n *  ...\n * }\n *\n * export default withAccessToken(github)(AuthorizedComponent);\n * ```\n *\n * @returns {React.ComponentType<T>} The wrapped component.\n */\nexport function withAccessToken<T = any, U = any>(\n  options: WithAccessTokenParameters,\n): <V extends WithAccessTokenComponentOrFn<T, U>>(\n  fnOrComponent: V,\n) => V extends React.ComponentType<T> ? React.FunctionComponent<T> : (props: T) => Promise<U>;\nexport function withAccessToken<T>(options: WithAccessTokenParameters) {\n  if (environment.commandMode === \"no-view\") {\n    return (fn: (props: T) => Promise<void> | (() => void)) => {\n      const noViewFn = async (props: T) => {\n        if (!token) {\n          token = options.personalAccessToken ?? (await options.authorize());\n          type = options.personalAccessToken ? \"personal\" : \"oauth\";\n          const idToken = (await options.client?.getTokens())?.idToken;\n\n          if (options.onAuthorize) {\n            await Promise.resolve(options.onAuthorize({ token, type, idToken }));\n          }\n        }\n\n        return fn(props);\n      };\n\n      return noViewFn;\n    };\n  }\n\n  return (Component: React.ComponentType<T>) => {\n    const WrappedComponent: React.ComponentType<T> = (props) => {\n      if (options.personalAccessToken) {\n        token = options.personalAccessToken;\n        type = \"personal\";\n      } else {\n        if (!authorize) {\n          authorize = options.authorize();\n        }\n        token = React.use(authorize);\n        type = \"oauth\";\n      }\n\n      let idToken: string | undefined;\n      if (options.client) {\n        if (!getIdToken) {\n          getIdToken = options.client?.getTokens().then((tokens) => tokens?.idToken);\n        }\n        idToken = React.use(getIdToken);\n      }\n\n      if (options.onAuthorize) {\n        if (!onAuthorize) {\n          onAuthorize = Promise.resolve(options.onAuthorize({ token: token!, type, idToken }));\n        }\n        React.use(onAuthorize);\n      }\n\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore too complicated for TS\n      return <Component {...props} />;\n    };\n\n    WrappedComponent.displayName = `withAccessToken(${Component.displayName || Component.name})`;\n\n    return WrappedComponent;\n  };\n}\n\n/**\n * Returns the access token and its type. Note that this function must be called in a component wrapped with `withAccessToken`.\n *\n * Will throw an Error if called outside of a function or component wrapped with `withAccessToken`\n *\n * @returns {{ token: string, type: \"oauth\" | \"personal\" }} An object containing the `token`\n * and its `type`, where type can be either 'oauth' for OAuth tokens or 'personal' for a\n * personal access token.\n */\nexport function getAccessToken(): {\n  token: string;\n  /** `oauth` for OAuth tokens or `personal` for personal access token */\n  type: \"oauth\" | \"personal\";\n} {\n  if (!token || !type) {\n    throw new Error(\"getAccessToken must be used when authenticated (eg. used inside `withAccessToken`)\");\n  }\n\n  return { token, type };\n}\n", "import { environment, LaunchProps, LaunchType } from \"@raycast/api\";\nimport fs from \"node:fs\";\nimport path from \"node:path\";\n\nexport enum DeeplinkType {\n  /** A script command */\n  ScriptCommand = \"script-command\",\n  /** An extension command */\n  Extension = \"extension\",\n}\n\n/**\n * Options for creating a deeplink to a script command.\n */\nexport type CreateScriptCommandDeeplinkOptions = {\n  /**\n   * The type of deeplink, which should be \"script-command\".\n   */\n  type: DeeplinkType.ScriptCommand;\n  /**\n   * The name of the command.\n   */\n  command: string;\n  /**\n   * If the command accepts arguments, they can be passed using this query parameter.\n   */\n  arguments?: string[];\n};\n\n/**\n * Base options for creating a deeplink to an extension.\n */\nexport type CreateExtensionDeeplinkBaseOptions = {\n  /**\n   * The type of deeplink, which should be \"extension\".\n   */\n  type?: DeeplinkType.Extension;\n  /**\n   * The command associated with the extension.\n   */\n  command: string;\n  /**\n   * Either \"userInitiated\", which runs the command in the foreground, or \"background\", which skips bringing Raycast to the front.\n   */\n  launchType?: LaunchType;\n  /**\n   * If the command accepts arguments, they can be passed using this query parameter.\n   */\n  arguments?: LaunchProps[\"arguments\"];\n  /**\n   * If the command make use of LaunchContext, it can be passed using this query parameter.\n   */\n  context?: LaunchProps[\"launchContext\"];\n  /**\n   * Some text to prefill the search bar or first text input of the command\n   */\n  fallbackText?: string;\n};\n\n/**\n * Options for creating a deeplink to an extension from another extension.\n * Requires both the ownerOrAuthorName and extensionName.\n */\nexport type CreateInterExtensionDeeplinkOptions = CreateExtensionDeeplinkBaseOptions & {\n  /**\n   * The name of the owner or author of the extension.\n   */\n  ownerOrAuthorName: string;\n  /**\n   * The name of the extension.\n   */\n  extensionName: string;\n};\n\n/**\n * Options for creating a deeplink to an extension.\n */\nexport type CreateExtensionDeeplinkOptions = CreateInterExtensionDeeplinkOptions | CreateExtensionDeeplinkBaseOptions;\n\n/**\n * Options for creating a deeplink.\n */\nexport type CreateDeeplinkOptions = CreateScriptCommandDeeplinkOptions | CreateExtensionDeeplinkOptions;\n\nfunction getProtocol() {\n  return environment.raycastVersion.includes(\"alpha\") ? \"raycastinternal://\" : \"raycast://\";\n}\n\nfunction getOwnerOrAuthorName() {\n  const packageJSON = JSON.parse(fs.readFileSync(path.join(environment.assetsPath, \"..\", \"package.json\"), \"utf8\"));\n  return packageJSON.owner || packageJSON.author;\n}\n\nexport function createScriptCommandDeeplink(options: CreateScriptCommandDeeplinkOptions): string {\n  let url = `${getProtocol()}script-commands/${options.command}`;\n\n  if (options.arguments) {\n    let params = \"\";\n    for (const arg of options.arguments) {\n      params += \"&arguments=\" + encodeURIComponent(arg);\n    }\n    url += \"?\" + params.substring(1);\n  }\n\n  return url;\n}\n\nexport function createExtensionDeeplink(options: CreateExtensionDeeplinkOptions): string {\n  let ownerOrAuthorName = getOwnerOrAuthorName();\n  let extensionName = environment.extensionName;\n\n  if (\"ownerOrAuthorName\" in options && \"extensionName\" in options) {\n    ownerOrAuthorName = options.ownerOrAuthorName;\n    extensionName = options.extensionName;\n  }\n\n  let url = `${getProtocol()}extensions/${ownerOrAuthorName}/${extensionName}/${options.command}`;\n\n  let params = \"\";\n  if (options.launchType) {\n    params += \"&launchType=\" + encodeURIComponent(options.launchType);\n  }\n\n  if (options.arguments) {\n    params += \"&arguments=\" + encodeURIComponent(JSON.stringify(options.arguments));\n  }\n\n  if (options.context) {\n    params += \"&context=\" + encodeURIComponent(JSON.stringify(options.context));\n  }\n\n  if (options.fallbackText) {\n    params += \"&fallbackText=\" + encodeURIComponent(options.fallbackText);\n  }\n\n  if (params) {\n    url += \"?\" + params.substring(1);\n  }\n\n  return url;\n}\n\n/**\n * Creates a deeplink to a script command or extension.\n */\nexport function createDeeplink(options: CreateDeeplinkOptions): string {\n  if (options.type === DeeplinkType.ScriptCommand) {\n    return createScriptCommandDeeplink(options);\n  } else {\n    return createExtensionDeeplink(options);\n  }\n}\n", "import { baseExecuteSQL } from \"./sql-utils\";\n\n/**\n * Executes a SQL query on a local SQLite database and returns the query result in JSON format.\n *\n * @param databasePath - The path to the SQLite database file.\n * @param query - The SQL query to execute.\n * @returns A Promise that resolves to an array of objects representing the query results.\n *\n * @example\n * ```typescript\n * import { closeMainWindow, Clipboard } from \"@raycast/api\";\n * import { executeSQL } from \"@raycast/utils\";\n *\n * type Message = { body: string; code: string };\n *\n * const DB_PATH = \"/path/to/chat.db\";\n *\n * export default async function Command() {\n *   const query = `SELECT body, code FROM ...`\n *\n *   const messages = await executeSQL<Message>(DB_PATH, query);\n *\n *   if (messages.length > 0) {\n *     const latestCode = messages[0].code;\n *     await Clipboard.paste(latestCode);\n *     await closeMainWindow();\n *   }\n * }\n * ```\n */\nexport function executeSQL<T = unknown>(databasePath: string, query: string) {\n  return baseExecuteSQL<T>(databasePath, query);\n}\n", "import childProcess from \"node:child_process\";\nimport {\n  defaultParsing,\n  getSpawnedPromise,\n  getSpawnedResult,\n  handleOutput,\n  ParseExecOutputHandler,\n} from \"./exec-utils\";\n\ntype AppleScriptOptions = {\n  /**\n   * By default, `runAppleScript` returns its results in human-readable form: strings do not have quotes around them, characters are not escaped, braces for lists and records are omitted, etc. This is generally more useful, but can introduce ambiguities. For example, the lists `{\"foo\", \"bar\"}` and `{{\"foo\", {\"bar\"}}}` would both be displayed as foo, bar. To see the results in an unambiguous form that could be recompiled into the same value, set `humanReadableOutput` to `false`.\n   *\n   * @default true\n   */\n  humanReadableOutput?: boolean;\n  /**\n   * Whether the script is using [`AppleScript`](https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/introduction/ASLR_intro.html#//apple_ref/doc/uid/TP40000983) or [`JavaScript`](https://developer.apple.com/library/archive/releasenotes/InterapplicationCommunication/RN-JavaScriptForAutomation/Articles/Introduction.html#//apple_ref/doc/uid/TP40014508-CH111-SW1).\n   *\n   * @default \"AppleScript\"\n   */\n  language?: \"AppleScript\" | \"JavaScript\";\n  /**\n   * A Signal object that allows you to abort the request if required via an AbortController object.\n   */\n  signal?: AbortSignal;\n  /** If timeout is greater than `0`, the parent will send the signal `SIGTERM` if the child runs longer than timeout milliseconds.\n   *\n   * @default 10000\n   */\n  timeout?: number;\n};\n\n/**\n * Executes an AppleScript script.\n *\n * @example\n * ```typescript\n * import { showHUD } from \"@raycast/api\";\n * import { runAppleScript, showFailureToast } from \"@raycast/utils\";\n *\n * export default async function () {\n *   try {\n *     const res = await runAppleScript(\n *       `\n *       on run argv\n *         return \"hello, \" & item 1 of argv & \".\"\n *       end run\n *       `,\n *       [\"world\"]\n *     );\n *     await showHUD(res);\n *   } catch (error) {\n *     showFailureToast(error, { title: \"Could not run AppleScript\" });\n *   }\n * }\n * ```\n */\nexport async function runAppleScript<T = string>(\n  script: string,\n  options?: AppleScriptOptions & {\n    parseOutput?: ParseExecOutputHandler<T, string, AppleScriptOptions>;\n  },\n): Promise<string>;\nexport async function runAppleScript<T = string>(\n  script: string,\n  /**\n   * The arguments to pass to the script.\n   */\n  args: string[],\n  options?: AppleScriptOptions & {\n    parseOutput?: ParseExecOutputHandler<T, string, AppleScriptOptions>;\n  },\n): Promise<string>;\nexport async function runAppleScript<T = string>(\n  script: string,\n  optionsOrArgs?:\n    | string[]\n    | (AppleScriptOptions & {\n        parseOutput?: ParseExecOutputHandler<T, string, AppleScriptOptions>;\n      }),\n  options?: AppleScriptOptions & {\n    parseOutput?: ParseExecOutputHandler<T, string, AppleScriptOptions>;\n  },\n): Promise<string> {\n  if (process.platform !== \"darwin\") {\n    throw new Error(\"AppleScript is only supported on macOS\");\n  }\n\n  const { humanReadableOutput, language, timeout, ...execOptions } = Array.isArray(optionsOrArgs)\n    ? options || {}\n    : optionsOrArgs || {};\n\n  const outputArguments = humanReadableOutput !== false ? [] : [\"-ss\"];\n  if (language === \"JavaScript\") {\n    outputArguments.push(\"-l\", \"JavaScript\");\n  }\n  if (Array.isArray(optionsOrArgs)) {\n    outputArguments.push(\"-\", ...optionsOrArgs);\n  }\n\n  const spawned = childProcess.spawn(\"osascript\", outputArguments, {\n    ...execOptions,\n    env: { PATH: \"/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin\" },\n  });\n  const spawnedPromise = getSpawnedPromise(spawned, { timeout: timeout ?? 10000 });\n\n  spawned.stdin.end(script);\n\n  const [{ error, exitCode, signal, timedOut }, stdoutResult, stderrResult] = await getSpawnedResult<string>(\n    spawned,\n    { encoding: \"utf8\" },\n    spawnedPromise,\n  );\n  const stdout = handleOutput({ stripFinalNewline: true }, stdoutResult);\n  const stderr = handleOutput({ stripFinalNewline: true }, stderrResult);\n\n  return defaultParsing({\n    stdout,\n    stderr,\n    error,\n    exitCode,\n    signal,\n    timedOut,\n    command: \"osascript\",\n    options,\n    parentError: new Error(),\n  });\n}\n", "import childProcess from \"node:child_process\";\nimport {\n  defaultParsing,\n  getSpawnedPromise,\n  getSpawnedResult,\n  handleOutput,\n  ParseExecOutputHandler,\n} from \"./exec-utils\";\n\ntype PowerShellScriptOptions = {\n  /**\n   * A Signal object that allows you to abort the request if required via an AbortController object.\n   */\n  signal?: AbortSignal;\n  /** If timeout is greater than `0`, the parent will send the signal `SIGTERM` if the child runs longer than timeout milliseconds.\n   *\n   * @default 10000\n   */\n  timeout?: number;\n};\n\n/**\n * Executes a PowerShell script.\n *\n * @example\n * ```typescript\n * import { showHUD } from \"@raycast/api\";\n * import { runPowerShellScript, showFailureToast } from \"@raycast/utils\";\n *\n * export default async function () {\n *   try {\n *     const res = await runPowerShellScript(\n *       `\n *       Write-Host \"hello, world.\"\n *       `,\n *     );\n *     await showHUD(res);\n *   } catch (error) {\n *     showFailureToast(error, { title: \"Could not run PowerShell\" });\n *   }\n * }\n * ```\n */\nexport async function runPowerShellScript<T = string>(\n  script: string,\n  options?: PowerShellScriptOptions & {\n    parseOutput?: ParseExecOutputHandler<T, string, PowerShellScriptOptions>;\n  },\n): Promise<string> {\n  if (process.platform !== \"win32\") {\n    throw new Error(\"PowerShell is only supported on Windows\");\n  }\n\n  const { timeout, ...execOptions } = options || {};\n\n  const outputArguments = [\"-NoLogo\", \"-NoProfile\", \"-NonInteractive\", \"-Command\", \"-\"];\n\n  const spawned = childProcess.spawn(\"powershell.exe\", outputArguments, {\n    ...execOptions,\n  });\n  const spawnedPromise = getSpawnedPromise(spawned, { timeout: timeout ?? 10000 });\n\n  spawned.stdin.end(script);\n\n  const [{ error, exitCode, signal, timedOut }, stdoutResult, stderrResult] = await getSpawnedResult<string>(\n    spawned,\n    { encoding: \"utf8\" },\n    spawnedPromise,\n  );\n  const stdout = handleOutput({ stripFinalNewline: true }, stdoutResult);\n  const stderr = handleOutput({ stripFinalNewline: true }, stderrResult);\n\n  return defaultParsing({\n    stdout,\n    stderr,\n    error,\n    exitCode,\n    signal,\n    timedOut,\n    command: \"powershell.exe\",\n    options,\n    parentError: new Error(),\n  });\n}\n", "import { Cache } from \"@raycast/api\";\nimport { hash, replacer, reviver } from \"./helpers\";\n\n/**\n * Wraps a function with caching functionality using Raycast's Cache API.\n * Allows for caching of expensive functions like paginated API calls that rarely change.\n *\n * @param fn - The async function to cache results from\n * @param options - Optional configuration for the cache behavior\n * @param options.validate - Optional validation function for cached data\n * @param options.maxAge - Maximum age of cached data in milliseconds\n * @returns An async function that returns the result of the function, either from cache or fresh execution\n *\n * @example\n * ```ts\n * const cachedFunction = withCache(fetchExpensiveData, {\n *   maxAge: 5 * 60 * 1000 // Cache for 5 minutes\n * });\n *\n * const result = await cachedFunction(query);\n * ```\n */\nexport function withCache<Fn extends (...args: any) => Promise<any>>(\n  fn: Fn,\n  options?: {\n    /** function that receives the cached data and returns a boolean depending on whether the data is still valid or not. */\n    validate?: (data: Awaited<ReturnType<Fn>>) => boolean;\n    /** Maximum age of cached data in milliseconds after which the data will be considered invalid */\n    maxAge?: number;\n  },\n): Fn & { clearCache: () => void } {\n  const cache = new Cache({ namespace: hash(fn) });\n\n  const wrappedFn = async (...args: Parameters<Fn>) => {\n    const key =\n      hash(args || []) + (options as unknown as { internal_cacheKeySuffix?: string })?.internal_cacheKeySuffix;\n    const cached = cache.get(key);\n    if (cached) {\n      const { data, timestamp } = JSON.parse(cached, reviver);\n      const isExpired = options?.maxAge && Date.now() - timestamp > options.maxAge;\n      if (!isExpired && (!options?.validate || options.validate(data))) {\n        return data;\n      }\n    }\n\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    const result = await fn(...args);\n    cache.set(\n      key,\n      JSON.stringify(\n        {\n          data: result,\n          timestamp: Date.now(),\n        },\n        replacer,\n      ),\n    );\n    return result;\n  };\n\n  wrappedFn.clearCache = () => {\n    cache.clear();\n  };\n\n  // @ts-expect-error too complex for TS\n  return wrappedFn;\n}\n", "/**\n * Hook for fetching installed brew packages.\n *\n * Uses Raycast's useCachedPromise for caching with keepPreviousData\n * to show stale data while revalidating.\n */\n\nimport { useRef } from \"react\";\nimport { showToast, Toast } from \"@raycast/api\";\nimport { useCachedPromise } from \"@raycast/utils\";\nimport { brewFetchInstalled, InstalledMap, isBrewLockError, getErrorMessage, brewLogger } from \"../utils\";\n\n/**\n * Hook to fetch and cache installed brew packages.\n *\n * Uses useCachedPromise with keepPreviousData to implement stale-while-revalidate:\n * - Shows cached data immediately if available\n * - Fetches fresh data in background\n * - Loading state is true until data is available\n *\n * @returns Object containing loading state, data, and revalidate function\n */\nexport function useBrewInstalled() {\n  const loadingToastRef = useRef<Toast | undefined>(undefined);\n\n  const result = useCachedPromise(\n    async (): Promise<InstalledMap | undefined> => {\n      return await brewFetchInstalled(true);\n    },\n    [],\n    {\n      keepPreviousData: true,\n      onWillExecute: async () => {\n        loadingToastRef.current = await showToast({\n          style: Toast.Style.Animated,\n          title: \"Loading Installed Packages\u2026\",\n        });\n      },\n      onData: () => {\n        loadingToastRef.current?.hide();\n      },\n      onError: async (error) => {\n        loadingToastRef.current?.hide();\n        brewLogger.error(\"Failed to fetch installed packages\", {\n          errorType: error.name,\n          message: error.message,\n          isLockError: isBrewLockError(error),\n        });\n\n        const isLock = isBrewLockError(error);\n        const message = getErrorMessage(error);\n\n        await showToast({\n          style: Toast.Style.Failure,\n          title: isLock ? \"Brew is Busy\" : \"Failed to fetch installed packages\",\n          message: isLock ? \"Another brew process is running. Please wait and try again.\" : message,\n          primaryAction: {\n            title: \"Retry\",\n            onAction: (toast) => {\n              toast.hide();\n              result.revalidate();\n            },\n          },\n        });\n      },\n    },\n  );\n\n  return result;\n}\n", "import { getPreferenceValues } from \"@raycast/api\";\n\nexport const preferences = <Preferences & Preferences.CleanUp>getPreferenceValues();\n", "/**\n * Logger utilities for the Brew extension.\n *\n * Uses @chrismessina/raycast-logger for verbose logging support.\n * Child loggers are created for different modules to provide context.\n */\n\nimport { Logger } from \"@chrismessina/raycast-logger\";\n\n/**\n * Main logger instance for the Brew extension.\n */\nexport const logger = new Logger({\n  prefix: \"[Brew]\",\n});\n\n/**\n * Child logger for brew command operations.\n */\nexport const brewLogger = logger.child(\"[Commands]\");\n\n/**\n * Child logger for cache operations.\n */\nexport const cacheLogger = logger.child(\"[Cache]\");\n\n/**\n * Child logger for action operations (install, uninstall, upgrade).\n */\nexport const actionsLogger = logger.child(\"[Actions]\");\n\n/**\n * Child logger for fetch operations.\n */\nexport const fetchLogger = logger.child(\"[Fetch]\");\n\n/**\n * Child logger for search operations.\n */\nexport const searchLogger = logger.child(\"[Search]\");\n\n/**\n * Child logger for UI operations (toasts, etc.).\n */\nexport const uiLogger = logger.child(\"[UI]\");\n", "/**\n * Error types for the Brew extension.\n *\n * Provides granular error types for different failure scenarios:\n * - Network errors (transient, recoverable)\n * - Parse errors (corrupted data)\n * - Brew command errors (brew-specific failures)\n * - Brew lock errors (concurrent process detection)\n * - Cache errors (file system issues)\n */\n\n/**\n * Base error class for all Brew extension errors.\n */\nexport class BrewError extends Error {\n  readonly brewCause?: Error;\n\n  constructor(message: string, options?: { cause?: Error }) {\n    super(message);\n    this.name = \"BrewError\";\n    this.brewCause = options?.cause;\n  }\n}\n\n/**\n * Network-related errors (HTTP failures, timeouts, etc.).\n * These are typically transient and recoverable.\n */\nexport class NetworkError extends BrewError {\n  readonly statusCode?: number;\n  readonly url?: string;\n\n  constructor(message: string, options?: { cause?: Error; statusCode?: number; url?: string }) {\n    super(message, { cause: options?.cause });\n    this.name = \"NetworkError\";\n    this.statusCode = options?.statusCode;\n    this.url = options?.url;\n  }\n}\n\n/**\n * Parse errors for corrupted or invalid data.\n */\nexport class ParseError extends BrewError {\n  constructor(message: string, options?: { cause?: Error }) {\n    super(message, options);\n    this.name = \"ParseError\";\n  }\n}\n\n/**\n * Brew command execution errors.\n */\nexport class BrewCommandError extends BrewError {\n  readonly command?: string;\n  readonly exitCode?: number;\n  readonly stderr?: string;\n\n  constructor(message: string, options?: { cause?: Error; command?: string; exitCode?: number; stderr?: string }) {\n    super(message, { cause: options?.cause });\n    this.name = \"BrewCommandError\";\n    this.command = options?.command;\n    this.exitCode = options?.exitCode;\n    this.stderr = options?.stderr;\n  }\n}\n\n/**\n * Error when brew executable is not found.\n */\nexport class BrewNotFoundError extends BrewError {\n  readonly path?: string;\n\n  constructor(message: string, options?: { cause?: Error; path?: string }) {\n    super(message, { cause: options?.cause });\n    this.name = \"BrewNotFoundError\";\n    this.path = options?.path;\n  }\n}\n\n/**\n * Cache-related errors (file system issues).\n */\nexport class CacheError extends BrewError {\n  readonly path?: string;\n\n  constructor(message: string, options?: { cause?: Error; path?: string }) {\n    super(message, { cause: options?.cause });\n    this.name = \"CacheError\";\n    this.path = options?.path;\n  }\n}\n\n/**\n * Error when another brew process is already running.\n * This is a recoverable error - the user can retry after the other process finishes.\n */\nexport class BrewLockError extends BrewError {\n  readonly command?: string;\n\n  constructor(message: string, options?: { cause?: Error; command?: string }) {\n    super(message, { cause: options?.cause });\n    this.name = \"BrewLockError\";\n    this.command = options?.command;\n  }\n}\n\n/**\n * Error when a download or operation times out.\n * This is a recoverable error - the user can retry.\n */\nexport class DownloadTimeoutError extends BrewError {\n  readonly packageName?: string;\n  readonly phase?: string;\n  readonly timeoutMs?: number;\n  readonly elapsedMs?: number;\n\n  constructor(\n    message: string,\n    options?: {\n      cause?: Error;\n      packageName?: string;\n      phase?: string;\n      timeoutMs?: number;\n      elapsedMs?: number;\n    },\n  ) {\n    super(message, { cause: options?.cause });\n    this.name = \"DownloadTimeoutError\";\n    this.packageName = options?.packageName;\n    this.phase = options?.phase;\n    this.timeoutMs = options?.timeoutMs;\n    this.elapsedMs = options?.elapsedMs;\n  }\n}\n\n/**\n * Error when a brew process appears to be stale/stuck.\n * This happens when no progress is made for an extended period.\n */\nexport class StaleProcessError extends BrewError {\n  readonly packageName?: string;\n  readonly lastPhase?: string;\n  readonly staleDurationMs?: number;\n\n  constructor(\n    message: string,\n    options?: {\n      cause?: Error;\n      packageName?: string;\n      lastPhase?: string;\n      staleDurationMs?: number;\n    },\n  ) {\n    super(message, { cause: options?.cause });\n    this.name = \"StaleProcessError\";\n    this.packageName = options?.packageName;\n    this.lastPhase = options?.lastPhase;\n    this.staleDurationMs = options?.staleDurationMs;\n  }\n}\n\n/**\n * Error when a package is not found.\n */\nexport class PackageNotFoundError extends BrewError {\n  readonly packageName?: string;\n  readonly packageType?: \"formula\" | \"cask\";\n\n  constructor(message: string, options?: { cause?: Error; packageName?: string; packageType?: \"formula\" | \"cask\" }) {\n    super(message, { cause: options?.cause });\n    this.name = \"PackageNotFoundError\";\n    this.packageName = options?.packageName;\n    this.packageType = options?.packageType;\n  }\n}\n\n/**\n * Error when a package has been disabled/discontinued.\n * This is not recoverable - the package is no longer available.\n */\nexport class PackageDisabledError extends BrewError {\n  readonly packageName?: string;\n  readonly packageType?: \"formula\" | \"cask\";\n  readonly disabledDate?: string;\n  readonly reason?: string;\n\n  constructor(\n    message: string,\n    options?: {\n      cause?: Error;\n      packageName?: string;\n      packageType?: \"formula\" | \"cask\";\n      disabledDate?: string;\n      reason?: string;\n    },\n  ) {\n    super(message, { cause: options?.cause });\n    this.name = \"PackageDisabledError\";\n    this.packageName = options?.packageName;\n    this.packageType = options?.packageType;\n    this.disabledDate = options?.disabledDate;\n    this.reason = options?.reason;\n  }\n}\n\n/**\n * Error when a package conflicts with another installed package.\n */\nexport class PackageConflictError extends BrewError {\n  readonly packageName?: string;\n  readonly conflictsWith?: string[];\n\n  constructor(message: string, options?: { cause?: Error; packageName?: string; conflictsWith?: string[] }) {\n    super(message, { cause: options?.cause });\n    this.name = \"PackageConflictError\";\n    this.packageName = options?.packageName;\n    this.conflictsWith = options?.conflictsWith;\n  }\n}\n\n/**\n * Error when a package requires a specific macOS version.\n */\nexport class UnsupportedMacOSError extends BrewError {\n  readonly packageName?: string;\n  readonly requiredVersion?: string;\n  readonly currentVersion?: string;\n\n  constructor(\n    message: string,\n    options?: { cause?: Error; packageName?: string; requiredVersion?: string; currentVersion?: string },\n  ) {\n    super(message, { cause: options?.cause });\n    this.name = \"UnsupportedMacOSError\";\n    this.packageName = options?.packageName;\n    this.requiredVersion = options?.requiredVersion;\n    this.currentVersion = options?.currentVersion;\n  }\n}\n\n/// Type Guards\n\n/**\n * Check if an error is a BrewError.\n */\nexport function isBrewError(error: unknown): error is BrewError {\n  return error instanceof BrewError;\n}\n\n/**\n * Check if an error is a NetworkError.\n */\nexport function isNetworkError(error: unknown): error is NetworkError {\n  return error instanceof NetworkError;\n}\n\n/**\n * Check if an error is a BrewLockError.\n */\nexport function isBrewLockError(error: unknown): error is BrewLockError {\n  return error instanceof BrewLockError;\n}\n\n/**\n * Check if an error is a DownloadTimeoutError.\n */\nexport function isDownloadTimeoutError(error: unknown): error is DownloadTimeoutError {\n  return error instanceof DownloadTimeoutError;\n}\n\n/**\n * Check if an error is a StaleProcessError.\n */\nexport function isStaleProcessError(error: unknown): error is StaleProcessError {\n  return error instanceof StaleProcessError;\n}\n\n/**\n * Check if an error is a PackageDisabledError.\n */\nexport function isPackageDisabledError(error: unknown): error is PackageDisabledError {\n  return error instanceof PackageDisabledError;\n}\n\n/**\n * Check if an error is a PackageConflictError.\n */\nexport function isPackageConflictError(error: unknown): error is PackageConflictError {\n  return error instanceof PackageConflictError;\n}\n\n/**\n * Check if an error is an UnsupportedMacOSError.\n */\nexport function isUnsupportedMacOSError(error: unknown): error is UnsupportedMacOSError {\n  return error instanceof UnsupportedMacOSError;\n}\n\n/**\n * Check if an error is recoverable (can be retried).\n * Network errors, lock errors, timeout errors, and stale process errors are typically recoverable.\n * Disabled packages, conflicts, and macOS version errors are NOT recoverable.\n */\nexport function isRecoverableError(error: unknown): boolean {\n  return isNetworkError(error) || isBrewLockError(error) || isDownloadTimeoutError(error) || isStaleProcessError(error);\n}\n\n/// Message Detection\n\n/**\n * Patterns that indicate a brew lock/concurrent process error.\n */\nconst BREW_LOCK_PATTERNS = [\n  /lockf:.*already locked/i,\n  /another active Homebrew/i,\n  /another brew process/i,\n  /another.*brew.*update.*process/i,\n  /Homebrew is already running/i,\n  /Error: Another active Homebrew/i,\n  /Error: Another.*brew.*process/i,\n  /waiting for lock/i,\n  /lock file/i,\n  /has already locked/i, // Homebrew 5.0: \"A `brew upgrade` process has already locked ...\"\n  /brew upgrade.*process has already/i,\n];\n\n/**\n * Pattern to detect disabled/discontinued packages.\n * Matches: \"Error: Cask 'name' has been disabled because it is discontinued upstream! It was disabled on 2024-12-16.\"\n * Or: \"Error: Formula 'name' has been disabled because ...\"\n */\nconst DISABLED_PACKAGE_PATTERN =\n  /Error: (Cask|Formula) '([^']+)' has been disabled(?: because (.+?))?(?:! It was disabled on (\\d{4}-\\d{2}-\\d{2}))?/i;\n\n/**\n * Pattern to detect package conflicts.\n * Matches: \"Error: Cask 'name' conflicts with 'other'\"\n */\nconst CONFLICT_PATTERN = /Error: (Cask|Formula) '([^']+)' conflicts with '([^']+)'/i;\n\n/**\n * Pattern to detect macOS version requirements.\n * Matches: \"Error: Cask 'name' requires macOS >= 12.0\"\n */\nconst MACOS_VERSION_PATTERN = /Error: (Cask|Formula) '([^']+)' requires macOS\\s*([><=]+\\s*[\\d.]+)/i;\n\n/**\n * Check if an error message indicates a brew lock error.\n */\nexport function isBrewLockMessage(message: string): boolean {\n  return BREW_LOCK_PATTERNS.some((pattern) => pattern.test(message));\n}\n\n/**\n * Check if an error message indicates a disabled package.\n */\nexport function isDisabledPackageMessage(message: string): boolean {\n  return DISABLED_PACKAGE_PATTERN.test(message);\n}\n\n/**\n * Parse disabled package details from an error message.\n */\nexport function parseDisabledPackageMessage(message: string): {\n  packageType: \"formula\" | \"cask\";\n  packageName: string;\n  reason?: string;\n  disabledDate?: string;\n} | null {\n  const match = message.match(DISABLED_PACKAGE_PATTERN);\n  if (!match) return null;\n\n  return {\n    packageType: match[1].toLowerCase() as \"formula\" | \"cask\",\n    packageName: match[2],\n    reason: match[3]?.trim(),\n    disabledDate: match[4],\n  };\n}\n\n/**\n * Check if an error message indicates a package conflict.\n */\nexport function isConflictMessage(message: string): boolean {\n  return CONFLICT_PATTERN.test(message);\n}\n\n/**\n * Check if an error message indicates a macOS version requirement.\n */\nexport function isMacOSVersionMessage(message: string): boolean {\n  return MACOS_VERSION_PATTERN.test(message);\n}\n\n/**\n * Safely cast an unknown error to an Error instance.\n * If the value is already an Error, returns it as-is.\n * Otherwise, wraps it in a new Error with the string representation.\n */\nexport function ensureError(err: unknown): Error {\n  return err instanceof Error ? err : new Error(String(err));\n}\n\n/**\n * Get a user-friendly error message from an error.\n */\nexport function getErrorMessage(error: unknown): string {\n  if (error instanceof BrewLockError) {\n    return \"Another brew process is already running. Please wait for it to finish and try again.\";\n  }\n\n  if (error instanceof DownloadTimeoutError) {\n    const pkg = error.packageName ? ` for \"${error.packageName}\"` : \"\";\n    const phase = error.phase ? ` during ${error.phase}` : \"\";\n    return `Download timed out${pkg}${phase}. Please try again.`;\n  }\n\n  if (error instanceof StaleProcessError) {\n    const pkg = error.packageName ? ` for \"${error.packageName}\"` : \"\";\n    const phase = error.lastPhase ? ` (stuck at ${error.lastPhase})` : \"\";\n    return `Process appears stuck${pkg}${phase}. The operation was cancelled.`;\n  }\n\n  if (error instanceof PackageDisabledError) {\n    const type = error.packageType ?? \"package\";\n    const typeName = type.charAt(0).toUpperCase() + type.slice(1);\n    let message = `${typeName} \"${error.packageName}\" has been discontinued`;\n    if (error.reason) {\n      message += `: ${error.reason}`;\n    }\n    if (error.disabledDate) {\n      message += ` (disabled on ${error.disabledDate})`;\n    }\n    return message;\n  }\n\n  if (error instanceof PackageConflictError) {\n    const conflicts = error.conflictsWith?.join(\", \") ?? \"another package\";\n    return `\"${error.packageName}\" conflicts with ${conflicts}. Please uninstall the conflicting package first.`;\n  }\n\n  if (error instanceof UnsupportedMacOSError) {\n    let message = `\"${error.packageName}\" requires a different macOS version`;\n    if (error.requiredVersion) {\n      message += ` (requires ${error.requiredVersion})`;\n    }\n    return message;\n  }\n\n  if (error instanceof NetworkError) {\n    if (error.statusCode) {\n      return `Network error (HTTP ${error.statusCode}): ${error.message}`;\n    }\n    return `Network error: ${error.message}`;\n  }\n\n  if (error instanceof BrewNotFoundError) {\n    return `Homebrew not found: ${error.message}`;\n  }\n\n  if (error instanceof PackageNotFoundError) {\n    const type = error.packageType ?? \"package\";\n    return `${type.charAt(0).toUpperCase() + type.slice(1)} not found: ${error.packageName ?? error.message}`;\n  }\n\n  if (error instanceof BrewCommandError) {\n    // Check for null exit code (process was killed/cancelled)\n    if (error.exitCode === undefined || error.exitCode === null) {\n      return \"Cancelled\";\n    }\n    // Check if the stderr contains a known error pattern for better messages\n    if (error.stderr) {\n      // Check for disabled package\n      const disabledInfo = parseDisabledPackageMessage(error.stderr);\n      if (disabledInfo) {\n        let message = `${disabledInfo.packageType.charAt(0).toUpperCase() + disabledInfo.packageType.slice(1)} \"${disabledInfo.packageName}\" has been discontinued`;\n        if (disabledInfo.reason) {\n          message += `: ${disabledInfo.reason}`;\n        }\n        if (disabledInfo.disabledDate) {\n          message += ` (disabled on ${disabledInfo.disabledDate})`;\n        }\n        return message;\n      }\n    }\n    return error.stderr ?? error.message;\n  }\n\n  if (error instanceof BrewError) {\n    return error.message;\n  }\n\n  if (error instanceof Error) {\n    // Handle abort errors with user-friendly message\n    if (error.name === \"AbortError\") {\n      return \"Cancelled\";\n    }\n\n    // Check for ExecError-like objects\n    const execError = error as { stderr?: string; stdout?: string };\n    if (execError.stderr) {\n      // Check for disabled package in raw stderr\n      const disabledInfo = parseDisabledPackageMessage(execError.stderr);\n      if (disabledInfo) {\n        let message = `${disabledInfo.packageType.charAt(0).toUpperCase() + disabledInfo.packageType.slice(1)} \"${disabledInfo.packageName}\" has been discontinued`;\n        if (disabledInfo.reason) {\n          message += `: ${disabledInfo.reason}`;\n        }\n        if (disabledInfo.disabledDate) {\n          message += ` (disabled on ${disabledInfo.disabledDate})`;\n        }\n        return message;\n      }\n      return execError.stderr;\n    }\n    return error.message;\n  }\n\n  return String(error);\n}\n", "/**\n * Cache utilities for the Brew extension.\n *\n * Provides functions for managing cached data and remote fetching.\n */\n\nimport { environment, showToast, Toast } from \"@raycast/api\";\nimport path from \"path\";\nimport fs from \"fs\";\nimport { rm } from \"fs/promises\";\nimport { stat } from \"fs/promises\";\nimport { Readable } from \"stream\";\nimport { ReadableStream } from \"stream/web\";\nimport { chain } from \"stream-chain\";\nimport { parser } from \"stream-json\";\nimport { filter } from \"stream-json/filters/Filter\";\nimport { streamArray } from \"stream-json/streamers/StreamArray\";\nimport { pipeline as streamPipeline } from \"stream/promises\";\nimport { Remote, DownloadProgressCallback } from \"./types\";\nimport { cacheLogger, fetchLogger } from \"./logger\";\nimport { NetworkError, ParseError, isNetworkError, isRecoverableError, ensureError } from \"./errors\";\nimport { wait } from \"./async\";\nimport { preferences } from \"./preferences\";\n\n/// Cache Paths\n\nexport const supportPath: string = (() => {\n  try {\n    fs.mkdirSync(environment.supportPath, { recursive: true });\n  } catch {\n    cacheLogger.warn(\"Failed to create supportPath\");\n  }\n  return environment.supportPath;\n})();\n\nexport const bundleIdentifier: string = (() => {\n  return (\n    environment.supportPath.split(path.sep).find((comp) => {\n      if (comp.startsWith(\"com.raycast\")) {\n        return true;\n      }\n      return false;\n    }) ?? \"com.raycast.macos\"\n  );\n})();\n\nexport function cachePath(name: string): string {\n  return path.join(supportPath, name);\n}\n\nconst CACHE_FILES = [\"formula.json\", \"cask.json\", \"installedv2.json\"];\n\n/**\n * Clear all cached data files (formulae, casks, installed packages).\n */\nexport async function clearCache(): Promise<void> {\n  try {\n    cacheLogger.log(\"Starting cache clear operation\");\n    await showToast(Toast.Style.Animated, \"Clearing downloaded casks and formulae...\");\n\n    // Check which files exist before clearing\n    const existingFiles: string[] = [];\n    const fileSizes: Record<string, number> = {};\n\n    for (const file of CACHE_FILES) {\n      const filePath = path.join(environment.supportPath, file);\n      try {\n        const stats = await stat(filePath);\n        existingFiles.push(file);\n        fileSizes[file] = stats.size;\n      } catch {\n        // File doesn't exist\n      }\n    }\n\n    if (existingFiles.length > 0) {\n      cacheLogger.log(\"Clearing cache files\", {\n        files: existingFiles,\n        sizes: fileSizes,\n        totalBytes: Object.values(fileSizes).reduce((a, b) => a + b, 0),\n      });\n    } else {\n      cacheLogger.log(\"No cache files to clear\");\n    }\n\n    await Promise.all(\n      CACHE_FILES.map((file) =>\n        rm(path.join(environment.supportPath, file), { force: true }).catch(() => {\n          // Ignore errors for files that don't exist\n        }),\n      ),\n    );\n\n    cacheLogger.log(\"Cache clear completed\", {\n      filesCleared: existingFiles,\n      fileCount: existingFiles.length,\n    });\n\n    await showToast(Toast.Style.Success, \"Cache files cleared\");\n  } catch (err) {\n    const error = ensureError(err);\n    cacheLogger.error(\"Failed to clear cache\", { error: error.message });\n    await showToast(Toast.Style.Failure, \"Failed to clear cache\", error.message);\n  }\n}\n\n/// Remote Fetching\n\n// Top-level object keys which should be parsed from the raw JSON objects.\nconst valid_keys = [\n  \"name\",\n  \"tap\",\n  \"desc\",\n  \"homepage\",\n  \"versions\",\n  \"outdated\",\n  \"caveats\",\n  \"token\",\n  \"version\",\n  \"installed\",\n  \"auto_updates\",\n  \"depends_on\",\n  \"conflicts_with\",\n  \"license\",\n  \"aliases\",\n  \"dependencies\",\n  \"build_dependencies\",\n  \"installed\",\n  \"keg_only\",\n  \"linked_key\",\n  \"pinned\",\n];\n\n/** Maximum number of retry attempts for network requests */\nconst MAX_FETCH_RETRIES = 2;\n/** Delay between retry attempts in milliseconds */\nconst RETRY_DELAY_MS = 1000;\n\nexport async function fetchRemote<T>(remote: Remote<T>, onProgress?: DownloadProgressCallback): Promise<T[]> {\n  if (remote.value) {\n    // Already cached in memory\n    onProgress?.({\n      url: remote.url,\n      bytesDownloaded: 0,\n      totalBytes: 0,\n      percent: 100,\n      complete: true,\n    });\n    return remote.value;\n  } else if (remote.fetch) {\n    return remote.fetch;\n  } else {\n    remote.fetch = _fetchRemoteWithRetry(remote, onProgress)\n      .then((value) => {\n        remote.value = value;\n        return value;\n      })\n      .finally(() => {\n        remote.fetch = undefined;\n      });\n    return remote.fetch;\n  }\n}\n\n/**\n * Fetch remote data with automatic retry for transient network errors.\n */\nasync function _fetchRemoteWithRetry<T>(remote: Remote<T>, onProgress?: DownloadProgressCallback): Promise<T[]> {\n  let lastError: Error | undefined;\n\n  for (let attempt = 0; attempt <= MAX_FETCH_RETRIES; attempt++) {\n    try {\n      return await _fetchRemote(remote, attempt, onProgress);\n    } catch (error) {\n      lastError = error instanceof Error ? error : new Error(String(error));\n\n      // Only retry for recoverable errors (network issues)\n      if (!isRecoverableError(error) || attempt >= MAX_FETCH_RETRIES) {\n        throw lastError;\n      }\n\n      fetchLogger.warn(\"Fetch failed, retrying\", {\n        url: remote.url,\n        attempt: attempt + 1,\n        maxRetries: MAX_FETCH_RETRIES,\n        error: lastError.message,\n      });\n\n      // Wait before retrying\n      await wait(RETRY_DELAY_MS * (attempt + 1));\n    }\n  }\n\n  throw lastError;\n}\n\nasync function _fetchRemote<T>(\n  remote: Remote<T>,\n  attempt: number,\n  onProgress?: DownloadProgressCallback,\n): Promise<T[]> {\n  const fetchStartTime = Date.now();\n  fetchLogger.log(\"Fetching remote\", { url: remote.url, attempt });\n\n  async function fetchURL(): Promise<void> {\n    const downloadStartTime = Date.now();\n    fetchLogger.log(\"Starting download\", { url: remote.url });\n\n    try {\n      // Request uncompressed data so Content-Length matches actual bytes for accurate progress\n      const response = await fetch(remote.url, {\n        headers: {\n          \"Accept-Encoding\": \"identity\",\n        },\n      });\n      if (!response.ok || !response.body) {\n        throw new NetworkError(`HTTP ${response.status}: ${response.statusText}`, {\n          statusCode: response.status,\n          url: remote.url,\n        });\n      }\n\n      // Track response size for progress reporting\n      // With Accept-Encoding: identity, Content-Length should match actual bytes\n      const contentLength = response.headers.get(\"content-length\");\n      const totalBytes = contentLength ? parseInt(contentLength, 10) : 0;\n\n      // Track bytes for progress reporting\n      let bytesDownloaded = 0;\n\n      // Report initial progress\n      onProgress?.({\n        url: remote.url,\n        bytesDownloaded: 0,\n        totalBytes,\n        percent: 0,\n        complete: false,\n      });\n\n      // Create write stream with error handling\n      const writeStream = fs.createWriteStream(remote.cachePath);\n\n      try {\n        // If we have a progress callback, use a transform stream to track progress\n        // Otherwise, stream directly to avoid overhead\n        if (onProgress) {\n          // Throttle progress updates to avoid render loops (max once per 100ms)\n          let lastProgressUpdate = 0;\n          const PROGRESS_THROTTLE_MS = 100;\n\n          const progressStream = new TransformStream({\n            transform(chunk, controller) {\n              bytesDownloaded += chunk.length;\n              const now = Date.now();\n\n              // Only report progress if enough time has passed OR this is the final chunk\n              const isComplete = totalBytes > 0 && bytesDownloaded >= totalBytes;\n              if (isComplete || now - lastProgressUpdate >= PROGRESS_THROTTLE_MS) {\n                const percent = totalBytes > 0 ? Math.round((bytesDownloaded / totalBytes) * 100) : -1;\n                lastProgressUpdate = now;\n\n                onProgress({\n                  url: remote.url,\n                  bytesDownloaded,\n                  totalBytes,\n                  percent: Math.min(percent, 100), // Cap at 100%\n                  complete: false,\n                });\n              }\n\n              controller.enqueue(chunk);\n            },\n          });\n\n          // Pipe through progress tracker\n          const progressBody = response.body.pipeThrough(progressStream);\n          await streamPipeline(Readable.fromWeb(progressBody as ReadableStream), writeStream);\n        } else {\n          // Direct stream without progress tracking\n          await streamPipeline(Readable.fromWeb(response.body as ReadableStream), writeStream);\n        }\n      } catch (streamError) {\n        // Clean up partial file on stream failure\n        writeStream.destroy();\n        try {\n          fs.unlinkSync(remote.cachePath);\n          fetchLogger.log(\"Cleaned up partial cache file\", { path: remote.cachePath });\n        } catch {\n          // Ignore cleanup errors\n        }\n\n        // Report error state to progress callback\n        const errorMessage = streamError instanceof Error ? streamError.message : String(streamError);\n        onProgress?.({\n          url: remote.url,\n          bytesDownloaded,\n          totalBytes,\n          percent: -1,\n          complete: false,\n          error: true,\n          errorMessage,\n        });\n\n        throw streamError;\n      }\n\n      // Report completion\n      onProgress?.({\n        url: remote.url,\n        bytesDownloaded,\n        totalBytes,\n        percent: 100,\n        complete: true,\n      });\n\n      const downloadDurationMs = Date.now() - downloadStartTime;\n\n      // Log cache update with size metrics\n      const logData: Record<string, unknown> = {\n        path: remote.cachePath,\n        url: remote.url,\n        downloadDurationMs,\n      };\n\n      if (totalBytes > 0) {\n        const contentLengthKb = (totalBytes / 1024).toFixed(2);\n        logData.responseSizeBytes = totalBytes;\n        logData.responseSizeKb = `${contentLengthKb} KB`;\n      }\n\n      if (preferences.useInternalApi) {\n        logData.usingInternalApi = true;\n      }\n\n      cacheLogger.log(\"Cache updated from remote\", logData);\n    } catch (error) {\n      const downloadDurationMs = Date.now() - downloadStartTime;\n      fetchLogger.error(\"Download failed\", { url: remote.url, durationMs: downloadDurationMs, error });\n\n      // Report error state to progress callback\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      onProgress?.({\n        url: remote.url,\n        bytesDownloaded: 0,\n        totalBytes: 0,\n        percent: -1,\n        complete: false,\n        error: true,\n        errorMessage,\n      });\n\n      if (isNetworkError(error)) {\n        throw error;\n      }\n      // Wrap fetch errors as NetworkError for retry logic\n      throw new NetworkError(`Failed to fetch ${remote.url}`, {\n        cause: error instanceof Error ? error : undefined,\n        url: remote.url,\n      });\n    }\n  }\n\n  async function updateCache(): Promise<void> {\n    let cacheInfo: fs.Stats | undefined;\n    let lastModified = 0;\n    try {\n      cacheInfo = await stat(remote.cachePath);\n      const response = await fetch(remote.url, { method: \"HEAD\" });\n      lastModified = Date.parse(response.headers.get(\"last-modified\") ?? \"\");\n    } catch {\n      cacheLogger.log(\"Cache miss\", { path: remote.cachePath });\n    }\n    if (!cacheInfo || cacheInfo.size == 0 || lastModified > cacheInfo.mtimeMs) {\n      await fetchURL();\n    } else {\n      fetchLogger.log(\"Using cached data (up to date)\", {\n        url: remote.url,\n        cacheAgeMs: Date.now() - cacheInfo.mtimeMs,\n      });\n    }\n  }\n\n  async function readCache(): Promise<T[]> {\n    const parseStartTime = Date.now();\n    fetchLogger.log(\"Parsing cache\", { path: remote.cachePath });\n\n    const keysRe = new RegExp(`\\\\b(${valid_keys.join(\"|\")})\\\\b`);\n\n    return new Promise<T[]>((resolve, reject) => {\n      // Note: We accumulate all parsed objects in memory. For ~7000 formulae/casks,\n      // this is typically 5-15MB of heap usage. The streaming parser avoids loading\n      // the entire 30MB+ JSON file at once, but we still need to hold the parsed\n      // objects for the UI. A SQLite backend could reduce memory but adds complexity.\n      const value: T[] = [];\n      // Throttle processing progress updates (max once per 100ms)\n      let lastProgressUpdate = 0;\n      const PROGRESS_THROTTLE_MS = 100;\n\n      /** Report processing progress to callback */\n      const reportProgress = (complete: boolean) => {\n        onProgress?.({\n          url: remote.url,\n          bytesDownloaded: 0,\n          totalBytes: 0,\n          percent: 100, // Download is complete\n          complete,\n          phase: \"processing\",\n          itemsProcessed: value.length,\n          totalItems: complete ? value.length : undefined,\n        });\n      };\n\n      // stream-json/chain is quite slow, so unfortunately not suitable for real-time queries.\n      // migrating to a sqlite backend _might_ help, although the bootstrap cost\n      // (each time json response changes) will probably be high.\n      const pipeline = chain([\n        fs.createReadStream(remote.cachePath),\n        parser(),\n        filter({ filter: keysRe }),\n        streamArray(),\n      ]);\n      pipeline.on(\"data\", (data) => {\n        if (data && typeof data === \"object\" && \"value\" in data) {\n          value.push(data.value);\n\n          // Report processing progress (throttled)\n          const now = Date.now();\n          if (onProgress && now - lastProgressUpdate >= PROGRESS_THROTTLE_MS) {\n            lastProgressUpdate = now;\n            reportProgress(false);\n          }\n        }\n      });\n      pipeline.on(\"end\", () => {\n        const parseDurationMs = Date.now() - parseStartTime;\n        const totalDurationMs = Date.now() - fetchStartTime;\n        fetchLogger.log(\"Fetch completed\", {\n          url: remote.url,\n          itemCount: value.length,\n          parseDurationMs,\n          totalDurationMs,\n        });\n        reportProgress(true);\n        resolve(value);\n      });\n      pipeline.on(\"error\", (err) => {\n        const parseDurationMs = Date.now() - parseStartTime;\n        // Cache parsing failed, remove corrupted cache and retry\n        cacheLogger.warn(\"Cache parse error, removing corrupted cache\", {\n          path: remote.cachePath,\n          error: err.message,\n          parseDurationMs,\n        });\n        fs.rmSync(remote.cachePath);\n        reject(\n          new ParseError(\"Failed to parse cached data\", {\n            cause: err,\n          }),\n        );\n      });\n    });\n  }\n\n  return updateCache().then(readCache);\n}\n", "/**\n * Async utilities for the Brew extension.\n *\n * Provides helper functions for async operations.\n */\n\nimport { setTimeout } from \"node:timers\";\n\n/**\n * Wait for a specified number of milliseconds.\n *\n * Useful for:\n * - Waiting for toast actions to be clicked\n * - Implementing retry delays\n * - Debouncing operations\n *\n * Note: For \"no view\" commands, this allows users time to click Toast actions.\n * See: https://raycastapp.slack.com/archives/C01E6LWGXJ8/p1642676284027700\n */\nexport async function wait(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n", "/**\n * Toast utilities for the Brew extension.\n *\n * Provides functions for displaying toast notifications.\n */\n\nimport { Clipboard, Toast, showHUD } from \"@raycast/api\";\nimport { ExecError } from \"./types\";\nimport { uiLogger } from \"./logger\";\nimport { isRecoverableError, getErrorMessage, isBrewLockError } from \"./errors\";\nimport { preferences } from \"./preferences\";\n\n/// Toast Types\n\ninterface ActionToastOptions {\n  title: string;\n  message?: string;\n  cancelable: boolean;\n}\n\n/**\n * Result from showActionToast that allows updating progress and showing final HUD.\n */\nexport interface ActionToastHandle {\n  /** AbortController for cancellation (if cancelable) */\n  abort?: AbortController;\n  /** Update the toast message to show progress */\n  updateMessage: (message: string) => void;\n  /** Update the toast title */\n  updateTitle: (title: string) => void;\n  /** Show success HUD (persists after Raycast closes) */\n  showSuccessHUD: (message: string) => Promise<void>;\n  /** Show failure HUD (persists after Raycast closes) */\n  showFailureHUD: (message: string) => Promise<void>;\n  /** Hide the toast */\n  hide: () => void;\n}\n\n/**\n * Show an animated toast with optional cancel action.\n * Returns a handle for updating progress and showing final HUD notifications.\n */\nexport function showActionToast(actionOptions: ActionToastOptions): ActionToastHandle {\n  const options: Toast.Options = {\n    style: Toast.Style.Animated,\n    title: actionOptions.title,\n    message: actionOptions.message,\n  };\n\n  let controller: AbortController | undefined;\n\n  if (actionOptions.cancelable) {\n    controller = new AbortController();\n    options.primaryAction = {\n      title: \"Cancel\",\n      onAction: () => {\n        controller?.abort();\n        toast.hide();\n      },\n    };\n  }\n\n  const toast = new Toast(options);\n  toast.show();\n\n  return {\n    abort: controller,\n    updateMessage: (message: string) => {\n      toast.message = message;\n    },\n    updateTitle: (title: string) => {\n      toast.title = title;\n    },\n    showSuccessHUD: async (message: string) => {\n      if (preferences.closeAfterAction) {\n        toast.hide();\n        // Close window and show HUD\n        await showHUD(`\u2705 ${message}`);\n      } else {\n        // Keep window open - update existing toast in-place to avoid stale detail HUD\n        toast.style = Toast.Style.Success;\n        toast.title = message;\n        toast.message = undefined;\n        toast.primaryAction = undefined;\n      }\n    },\n    showFailureHUD: async (message: string) => {\n      if (preferences.closeAfterAction) {\n        toast.hide();\n        // Close window and show HUD\n        await showHUD(`\u274C ${message}`);\n      } else {\n        // Keep window open - update existing toast in-place to avoid stale detail HUD\n        toast.style = Toast.Style.Failure;\n        toast.title = message;\n        toast.message = undefined;\n        toast.primaryAction = undefined;\n      }\n    },\n    hide: () => {\n      toast.hide();\n    },\n  };\n}\n\n/**\n * Show a Brew-specific failure toast with error details and optional retry action.\n *\n * Unlike the standard `showFailureToast` from `@raycast/utils`, this function:\n * - Detects Homebrew lock errors and shows \"Brew is Busy\" with helpful context\n * - Logs structured error details (stderr, exit code, error type) via uiLogger\n * - Provides a \"Copy Logs\" action with brew-specific troubleshooting tips\n * - Supports conditional retry for recoverable brew errors\n * - Silently ignores AbortError (user-initiated cancellations)\n *\n * Use this for all Homebrew operations. Use `showFailureToast` from `@raycast/utils`\n * for general extension errors unrelated to brew commands.\n */\nexport async function showBrewFailureToast(\n  title: string,\n  error: Error,\n  options?: { retryAction?: () => Promise<void> },\n): Promise<void> {\n  if (error.name === \"AbortError\") {\n    uiLogger.log(\"Operation aborted by user\");\n    return;\n  }\n\n  const execError = error as ExecError;\n  const errorMessage = getErrorMessage(error);\n  const isLockError = isBrewLockError(error);\n\n  uiLogger.error(title, {\n    errorType: error.name,\n    message: error.message,\n    stderr: execError.stderr,\n    code: execError.code,\n    recoverable: isRecoverableError(error),\n    isLockError,\n  });\n\n  // Use a more specific title for lock errors\n  const toastTitle = isLockError ? \"Brew is Busy\" : title;\n\n  const toastOptions: Toast.Options = {\n    style: Toast.Style.Failure,\n    title: toastTitle,\n    message: errorMessage,\n    primaryAction: {\n      title: \"Copy Logs\",\n      onAction: () => {\n        // For lock errors, include more context in the copied log\n        const logContent = isLockError\n          ? `${toastTitle}\\n${errorMessage}\\n\\nTip: Check Activity Monitor or run 'ps aux | grep brew' in Terminal to see what's running.`\n          : errorMessage;\n        Clipboard.copy(logContent);\n      },\n    },\n  };\n\n  // Add retry action for recoverable errors (including lock errors)\n  if (isRecoverableError(error) && options?.retryAction) {\n    const retryAction = options.retryAction;\n    toastOptions.secondaryAction = {\n      title: \"Retry\",\n      onAction: async (toast) => {\n        toast.style = Toast.Style.Animated;\n        toast.title = \"Retrying...\";\n        toast.message = undefined;\n        try {\n          await retryAction();\n          toast.style = Toast.Style.Success;\n          toast.title = \"Success\";\n        } catch (retryError) {\n          toast.style = Toast.Style.Failure;\n          toast.title = isBrewLockError(retryError) ? \"Brew is Busy\" : title;\n          toast.message = getErrorMessage(retryError);\n        }\n      },\n    };\n  }\n\n  const toast = new Toast(toastOptions);\n  await toast.show();\n}\n", "/**\n * Array prototype extensions for the Brew extension.\n *\n * Adds utility methods to Array prototype for convenience.\n * These are used throughout the extension for working with search results.\n */\n\n/// Array Extensions\n\ndeclare global {\n  interface Array<T> {\n    /** Total length before truncation (for paginated results) */\n    totalLength?: number;\n    /** Get the first element of the array */\n    first(): T | undefined;\n    /** Get the last element of the array */\n    last(): T | undefined;\n    /** Check if the array was truncated (totalLength > length) */\n    isTruncated(): boolean;\n  }\n}\n\nif (!Array.prototype.first) {\n  Array.prototype.first = function <T>(this: T[]): T | undefined {\n    return this.at(0);\n  };\n}\n\nif (!Array.prototype.last) {\n  Array.prototype.last = function <T>(this: T[]): T | undefined {\n    return this.at(-1);\n  };\n}\n\nif (!Array.prototype.isTruncated) {\n  Array.prototype.isTruncated = function <T>(this: T[]): boolean {\n    if (this.totalLength) {\n      return this.length < this.totalLength;\n    }\n    return false;\n  };\n}\n\n/// String Extensions\n\ndeclare global {\n  interface StringConstructor {\n    ellipsis: string;\n  }\n}\n\nif (!String.ellipsis) {\n  String.ellipsis = \"\u2026\";\n}\n\n// Export empty object to make this a module\nexport {};\n", "/**\n * Memory diagnostics utilities.\n *\n * Provides functions for monitoring memory usage in Raycast's constrained\n * worker environment. Helps identify memory issues and potential leaks.\n *\n * Usage:\n *   import { memoryLogger, logMemory, withMemoryTracking } from \"./memory\";\n *\n *   // Simple logging\n *   logMemory(\"Before large operation\");\n *\n *   // Track memory around an operation\n *   const result = await withMemoryTracking(\"fetchFormulae\", async () => {\n *     return await fetchData();\n *   });\n */\n\nimport { Logger } from \"@chrismessina/raycast-logger\";\n\n/**\n * Memory logger instance.\n */\nexport const memoryLogger = new Logger({\n  prefix: \"[Brew]\",\n}).child(\"[Memory]\");\n\n/**\n * Memory usage snapshot with additional context.\n */\nexport interface MemorySnapshot {\n  /** Timestamp of the snapshot */\n  timestamp: number;\n  /** Label for this snapshot */\n  label: string;\n  /** Resident Set Size - total memory allocated to the process */\n  rss: number;\n  /** Total heap size allocated */\n  heapTotal: number;\n  /** Heap memory currently in use */\n  heapUsed: number;\n  /** Memory used by external C++ objects */\n  external: number;\n  /** Memory used by ArrayBuffers */\n  arrayBuffers: number;\n  /** Percentage of heap used (heapUsed / heapTotal) */\n  heapPercent: number;\n  /** Caller information (function name, file, line) */\n  caller?: CallerInfo;\n  /** Stack trace (if enabled) */\n  stack?: string;\n}\n\n/**\n * Caller information extracted from stack trace.\n */\nexport interface CallerInfo {\n  /** Function name */\n  functionName: string;\n  /** File path */\n  fileName: string;\n  /** Line number */\n  lineNumber: number;\n  /** Column number */\n  columnNumber: number;\n}\n\n/**\n * Memory tracking result for operations.\n */\nexport interface MemoryTrackingResult<T> {\n  /** The result of the tracked operation */\n  result: T;\n  /** Memory snapshot before the operation */\n  before: MemorySnapshot;\n  /** Memory snapshot after the operation */\n  after: MemorySnapshot;\n  /** Memory delta (after - before) */\n  delta: MemoryDelta;\n  /** Duration of the operation in milliseconds */\n  durationMs: number;\n}\n\n/**\n * Memory delta between two snapshots.\n */\nexport interface MemoryDelta {\n  rss: number;\n  heapTotal: number;\n  heapUsed: number;\n  external: number;\n  arrayBuffers: number;\n}\n\n/**\n * Warning thresholds for memory usage.\n */\nconst MEMORY_THRESHOLDS = {\n  /** Warn when heap usage exceeds this percentage */\n  heapPercentWarning: 70,\n  /** Critical when heap usage exceeds this percentage */\n  heapPercentCritical: 85,\n  /** Warn when a single operation increases heap by this many MB */\n  deltaWarningMB: 50,\n};\n\n/**\n * Format bytes to a human-readable string.\n */\nfunction formatBytes(bytes: number): string {\n  if (bytes < 1024) return `${bytes} B`;\n  if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;\n  return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;\n}\n\n/**\n * Parse a V8 stack trace line to extract caller info.\n * Format: \"    at functionName (filePath:line:column)\"\n * Or:     \"    at filePath:line:column\"\n */\nfunction parseStackLine(line: string): CallerInfo | undefined {\n  // Match: \"at functionName (filePath:line:column)\"\n  const withFunctionMatch = line.match(/at\\s+(.+?)\\s+\\((.+):(\\d+):(\\d+)\\)/);\n  if (withFunctionMatch) {\n    return {\n      functionName: withFunctionMatch[1],\n      fileName: withFunctionMatch[2],\n      lineNumber: parseInt(withFunctionMatch[3], 10),\n      columnNumber: parseInt(withFunctionMatch[4], 10),\n    };\n  }\n\n  // Match: \"at filePath:line:column\" (anonymous function)\n  const anonymousMatch = line.match(/at\\s+(.+):(\\d+):(\\d+)/);\n  if (anonymousMatch) {\n    return {\n      functionName: \"<anonymous>\",\n      fileName: anonymousMatch[1],\n      lineNumber: parseInt(anonymousMatch[2], 10),\n      columnNumber: parseInt(anonymousMatch[3], 10),\n    };\n  }\n\n  return undefined;\n}\n\n/**\n * Get caller information from the current stack trace.\n * @param skipFrames Number of stack frames to skip (default: 2 to skip this function and the caller)\n */\nfunction getCallerInfo(skipFrames = 2): CallerInfo | undefined {\n  const stack = new Error().stack;\n  if (!stack) return undefined;\n\n  const lines = stack.split(\"\\n\");\n  // Skip \"Error\" line and the specified number of frames\n  const callerLine = lines[skipFrames + 1];\n  if (!callerLine) return undefined;\n\n  return parseStackLine(callerLine);\n}\n\n/**\n * Get a cleaned stack trace string.\n * @param skipFrames Number of stack frames to skip\n * @param maxFrames Maximum number of frames to include\n */\nfunction getStackTrace(skipFrames = 2, maxFrames = 5): string {\n  const stack = new Error().stack;\n  if (!stack) return \"\";\n\n  const lines = stack.split(\"\\n\");\n  // Skip \"Error\" line and the specified number of frames\n  const relevantLines = lines.slice(skipFrames + 1, skipFrames + 1 + maxFrames);\n\n  return relevantLines.map((line) => line.trim()).join(\"\\n\");\n}\n\n/**\n * Take a memory snapshot with caller information.\n * @param label A descriptive label for this snapshot\n * @param includeStack Whether to include the full stack trace\n */\nexport function takeMemorySnapshot(label: string, includeStack = false): MemorySnapshot {\n  const mem = process.memoryUsage();\n  const heapPercent = mem.heapTotal > 0 ? (mem.heapUsed / mem.heapTotal) * 100 : 0;\n\n  const snapshot: MemorySnapshot = {\n    timestamp: Date.now(),\n    label,\n    rss: mem.rss,\n    heapTotal: mem.heapTotal,\n    heapUsed: mem.heapUsed,\n    external: mem.external,\n    arrayBuffers: mem.arrayBuffers,\n    heapPercent,\n    caller: getCallerInfo(3), // Skip: takeMemorySnapshot, logMemory/withMemoryTracking, actual caller\n  };\n\n  if (includeStack) {\n    snapshot.stack = getStackTrace(3);\n  }\n\n  return snapshot;\n}\n\n/**\n * Calculate the delta between two memory snapshots.\n */\nfunction calculateDelta(before: MemorySnapshot, after: MemorySnapshot): MemoryDelta {\n  return {\n    rss: after.rss - before.rss,\n    heapTotal: after.heapTotal - before.heapTotal,\n    heapUsed: after.heapUsed - before.heapUsed,\n    external: after.external - before.external,\n    arrayBuffers: after.arrayBuffers - before.arrayBuffers,\n  };\n}\n\n/**\n * Get a warning indicator based on heap percentage.\n */\nfunction getWarningIndicator(heapPercent: number): string {\n  if (heapPercent >= MEMORY_THRESHOLDS.heapPercentCritical) return \"\uD83D\uDD34 CRITICAL\";\n  if (heapPercent >= MEMORY_THRESHOLDS.heapPercentWarning) return \"\u26A0\uFE0F HIGH\";\n  return \"\";\n}\n\n/**\n * Format a memory snapshot for logging.\n */\nfunction formatSnapshot(snapshot: MemorySnapshot): Record<string, unknown> {\n  const warning = getWarningIndicator(snapshot.heapPercent);\n\n  const result: Record<string, unknown> = {\n    label: snapshot.label,\n    heapUsed: formatBytes(snapshot.heapUsed),\n    heapTotal: formatBytes(snapshot.heapTotal),\n    heapPercent: `${snapshot.heapPercent.toFixed(1)}%`,\n    rss: formatBytes(snapshot.rss),\n  };\n\n  if (warning) {\n    result.warning = warning;\n  }\n\n  if (snapshot.caller) {\n    const { functionName, fileName, lineNumber } = snapshot.caller;\n    // Shorten file path for readability\n    const shortFileName = fileName.split(\"/\").slice(-2).join(\"/\");\n    result.caller = `${functionName} (${shortFileName}:${lineNumber})`;\n  }\n\n  if (snapshot.stack) {\n    result.stack = snapshot.stack;\n  }\n\n  return result;\n}\n\n/**\n * Log current memory usage with caller information.\n * @param label A descriptive label for this log entry\n * @param includeStack Whether to include the full stack trace\n */\nexport function logMemory(label: string, includeStack = false): MemorySnapshot {\n  const snapshot = takeMemorySnapshot(label, includeStack);\n  memoryLogger.log(label, formatSnapshot(snapshot));\n  return snapshot;\n}\n\n/**\n * Log a warning if memory usage is high.\n * @param label A descriptive label\n * @param snapshot The memory snapshot to check\n */\nfunction logMemoryWarning(label: string, snapshot: MemorySnapshot): void {\n  if (snapshot.heapPercent >= MEMORY_THRESHOLDS.heapPercentCritical) {\n    memoryLogger.error(`${label} - CRITICAL memory usage`, {\n      ...formatSnapshot(snapshot),\n      recommendation: \"Consider reducing data size or clearing cache\",\n    });\n  } else if (snapshot.heapPercent >= MEMORY_THRESHOLDS.heapPercentWarning) {\n    memoryLogger.warn(`${label} - High memory usage`, formatSnapshot(snapshot));\n  }\n}\n\n/**\n * Track memory usage around an async operation.\n * Logs before/after snapshots and the delta.\n *\n * @param operationName Name of the operation being tracked\n * @param operation The async operation to track\n * @param options Tracking options\n * @returns The result of the operation along with memory tracking data\n */\nexport async function withMemoryTracking<T>(\n  operationName: string,\n  operation: () => Promise<T>,\n  options: { includeStack?: boolean; logAlways?: boolean } = {},\n): Promise<MemoryTrackingResult<T>> {\n  const { includeStack = false, logAlways = true } = options;\n\n  const before = takeMemorySnapshot(`Before ${operationName}`, includeStack);\n  const startTime = Date.now();\n\n  if (logAlways) {\n    memoryLogger.log(`Starting: ${operationName}`, formatSnapshot(before));\n  }\n\n  let result: T;\n  try {\n    result = await operation();\n  } catch (error) {\n    // Log memory state on error\n    const errorSnapshot = takeMemorySnapshot(`Error in ${operationName}`, true);\n    memoryLogger.error(`Memory state at error in ${operationName}`, {\n      ...formatSnapshot(errorSnapshot),\n      error: error instanceof Error ? error.message : String(error),\n    });\n    throw error;\n  }\n\n  const after = takeMemorySnapshot(`After ${operationName}`, includeStack);\n  const durationMs = Date.now() - startTime;\n  const delta = calculateDelta(before, after);\n\n  const deltaHeapMB = delta.heapUsed / (1024 * 1024);\n  const isLargeDelta = Math.abs(deltaHeapMB) >= MEMORY_THRESHOLDS.deltaWarningMB;\n\n  if (logAlways || isLargeDelta) {\n    memoryLogger.log(`Completed: ${operationName}`, {\n      durationMs,\n      heapDelta: formatBytes(delta.heapUsed),\n      heapBefore: formatBytes(before.heapUsed),\n      heapAfter: formatBytes(after.heapUsed),\n      heapPercent: `${after.heapPercent.toFixed(1)}%`,\n      ...(isLargeDelta ? { warning: `\u26A0\uFE0F Large heap change: ${deltaHeapMB.toFixed(1)} MB` } : {}),\n    });\n  }\n\n  // Check for warnings after operation\n  logMemoryWarning(operationName, after);\n\n  return {\n    result,\n    before,\n    after,\n    delta,\n    durationMs,\n  };\n}\n\n/**\n * Synchronous version of withMemoryTracking for non-async operations.\n */\nexport function withMemoryTrackingSync<T>(\n  operationName: string,\n  operation: () => T,\n  options: { includeStack?: boolean; logAlways?: boolean } = {},\n): MemoryTrackingResult<T> {\n  const { includeStack = false, logAlways = true } = options;\n\n  const before = takeMemorySnapshot(`Before ${operationName}`, includeStack);\n  const startTime = Date.now();\n\n  if (logAlways) {\n    memoryLogger.log(`Starting: ${operationName}`, formatSnapshot(before));\n  }\n\n  let result: T;\n  try {\n    result = operation();\n  } catch (error) {\n    const errorSnapshot = takeMemorySnapshot(`Error in ${operationName}`, true);\n    memoryLogger.error(`Memory state at error in ${operationName}`, {\n      ...formatSnapshot(errorSnapshot),\n      error: error instanceof Error ? error.message : String(error),\n    });\n    throw error;\n  }\n\n  const after = takeMemorySnapshot(`After ${operationName}`, includeStack);\n  const durationMs = Date.now() - startTime;\n  const delta = calculateDelta(before, after);\n\n  const deltaHeapMB = delta.heapUsed / (1024 * 1024);\n  const isLargeDelta = Math.abs(deltaHeapMB) >= MEMORY_THRESHOLDS.deltaWarningMB;\n\n  if (logAlways || isLargeDelta) {\n    memoryLogger.log(`Completed: ${operationName}`, {\n      durationMs,\n      heapDelta: formatBytes(delta.heapUsed),\n      heapBefore: formatBytes(before.heapUsed),\n      heapAfter: formatBytes(after.heapUsed),\n      heapPercent: `${after.heapPercent.toFixed(1)}%`,\n      ...(isLargeDelta ? { warning: `\u26A0\uFE0F Large heap change: ${deltaHeapMB.toFixed(1)} MB` } : {}),\n    });\n  }\n\n  logMemoryWarning(operationName, after);\n\n  return {\n    result,\n    before,\n    after,\n    delta,\n    durationMs,\n  };\n}\n\n/**\n * Get a summary of current memory usage.\n * Useful for periodic health checks.\n */\nexport function getMemorySummary(): {\n  heapUsed: string;\n  heapTotal: string;\n  heapPercent: string;\n  rss: string;\n  status: \"ok\" | \"warning\" | \"critical\";\n} {\n  const mem = process.memoryUsage();\n  const heapPercent = mem.heapTotal > 0 ? (mem.heapUsed / mem.heapTotal) * 100 : 0;\n\n  let status: \"ok\" | \"warning\" | \"critical\" = \"ok\";\n  if (heapPercent >= MEMORY_THRESHOLDS.heapPercentCritical) {\n    status = \"critical\";\n  } else if (heapPercent >= MEMORY_THRESHOLDS.heapPercentWarning) {\n    status = \"warning\";\n  }\n\n  return {\n    heapUsed: formatBytes(mem.heapUsed),\n    heapTotal: formatBytes(mem.heapTotal),\n    heapPercent: `${heapPercent.toFixed(1)}%`,\n    rss: formatBytes(mem.rss),\n    status,\n  };\n}\n", "/**\n * Homebrew path utilities.\n *\n * Provides functions for resolving brew installation paths.\n */\n\nimport { execSync } from \"child_process\";\nimport { join as path_join } from \"path\";\nimport { cpus } from \"os\";\nimport { preferences } from \"../preferences\";\n\n/**\n * The Homebrew prefix directory.\n * Determined by:\n * 1. Custom brew path preference (if set)\n * 2. Running `brew --prefix` command\n * 3. Fallback based on CPU architecture\n */\nexport const brewPrefix = (() => {\n  if (preferences.customBrewPath && preferences.customBrewPath.length > 0)\n    return path_join(preferences.customBrewPath, \"..\", \"..\");\n  try {\n    return execSync(\"brew --prefix\", { encoding: \"utf8\" }).trim();\n  } catch {\n    const firstCpu = cpus()[0];\n    return firstCpu?.model?.includes(\"Apple\") ? \"/opt/homebrew\" : \"/usr/local\";\n  }\n})();\n\n/**\n * Get a path relative to the brew prefix.\n */\nexport const brewPath = (suffix: string): string => path_join(brewPrefix, suffix);\n\n/**\n * Get the path to the brew executable.\n */\nexport const brewExecutable = (): string => brewPath(\"bin/brew\");\n", "/**\n * Homebrew command execution utilities.\n *\n * Provides functions for executing brew commands with proper error handling.\n *\n * Homebrew 5.0 Compatibility Notes:\n * - Download concurrency is now enabled by default (HOMEBREW_DOWNLOAD_CONCURRENCY=auto)\n * - The extension supports controlling this via preferences\n * - --no-quarantine and --quarantine flags are deprecated\n * - HOMEBREW_USE_INTERNAL_API can be enabled for the new smaller JSON API\n */\n\nimport { exec } from \"child_process\";\nimport { promisify } from \"util\";\nimport { constants as fs_constants } from \"fs\";\nimport * as fs from \"fs/promises\";\nimport { join as path_join } from \"path\";\nimport { environment } from \"@raycast/api\";\nimport { ExecError, ExecResult } from \"../types\";\nimport { brewExecutable } from \"./paths\";\nimport { preferences } from \"../preferences\";\nimport { brewLogger } from \"../logger\";\nimport { BrewLockError, isBrewLockMessage } from \"../errors\";\nimport { bundleIdentifier } from \"../cache\";\n\nconst execp = promisify(exec);\n\n// Track if we've logged the Homebrew 5.0 environment configuration\nlet homebrewEnvLogged = false;\n\n/**\n * Execute a brew command.\n */\nexport async function execBrew(cmd: string, options?: { signal?: AbortSignal }): Promise<ExecResult> {\n  try {\n    const env = await execBrewEnv();\n    return await execp(`${brewExecutable()} ${cmd}`, {\n      signal: options?.signal,\n      env: env,\n      maxBuffer: 10 * 1024 * 1024,\n    });\n  } catch (err) {\n    const execErr = err as ExecError;\n\n    // Check for brew lock/concurrent process error\n    const errorOutput = execErr?.stderr || execErr?.stdout || \"\";\n    if (isBrewLockMessage(errorOutput)) {\n      brewLogger.warn(\"Brew lock detected - another process is running\", {\n        command: cmd,\n        stderr: execErr?.stderr,\n      });\n      throw new BrewLockError(\"Another brew process is already running\", {\n        command: cmd,\n        cause: execErr,\n      });\n    }\n\n    // Check for brew not found\n    if (preferences.customBrewPath && execErr && execErr.code === 127) {\n      execErr.stderr = `Brew executable not found at: ${preferences.customBrewPath}`;\n      throw execErr;\n    }\n\n    throw err;\n  }\n}\n\n/**\n * Get the environment variables for brew execution.\n *\n * Homebrew 5.0 environment variables:\n * - HOMEBREW_DOWNLOAD_CONCURRENCY: Controls parallel downloads (default: \"auto\")\n *   Set to \"1\" to disable concurrent downloads\n * - HOMEBREW_USE_INTERNAL_API: Opt-in to the new smaller internal JSON API\n */\nexport async function execBrewEnv(): Promise<NodeJS.ProcessEnv> {\n  const askpassPath = path_join(environment.assetsPath, \"askpass.sh\");\n  try {\n    await fs.access(askpassPath, fs_constants.X_OK);\n  } catch {\n    await fs.chmod(askpassPath, 0o755);\n  }\n  const env = { ...process.env };\n  env[\"SUDO_ASKPASS\"] = askpassPath;\n  // Use HOMEBREW_BROWSER to pass through the app's bundle identifier.\n  // Brew will ignore custom environment variables.\n  env[\"HOMEBREW_BROWSER\"] = bundleIdentifier;\n\n  // Homebrew 5.0: Control download concurrency\n  // By default, Homebrew 5.0 enables concurrent downloads (auto)\n  // Users can disable this via preferences if they experience issues\n  const downloadConcurrencyDisabled = preferences.disableDownloadConcurrency;\n  if (downloadConcurrencyDisabled) {\n    env[\"HOMEBREW_DOWNLOAD_CONCURRENCY\"] = \"1\";\n  }\n\n  // Homebrew 5.0: Opt-in to the new internal API (smaller JSON)\n  // This will become default in a future version\n  const useInternalApi = preferences.useInternalApi;\n  if (useInternalApi) {\n    env[\"HOMEBREW_USE_INTERNAL_API\"] = \"1\";\n  }\n\n  // Log Homebrew 5.0 configuration once per session\n  if (!homebrewEnvLogged) {\n    homebrewEnvLogged = true;\n    brewLogger.log(\"Homebrew 5.0 Configuration\", {\n      downloadConcurrencyEnabled: !downloadConcurrencyDisabled,\n      downloadConcurrencyMode: downloadConcurrencyDisabled ? \"sequential (1)\" : \"parallel (auto)\",\n      internalApiEnabled: useInternalApi,\n      verboseLogging: preferences.verboseLogging,\n    });\n  }\n\n  return env;\n}\n", "/**\n * Homebrew progress tracking utilities.\n *\n * Provides functions for executing brew commands with real-time progress updates.\n */\n\nimport { spawn } from \"child_process\";\nimport { brewExecutable } from \"./paths\";\nimport { execBrewEnv } from \"./commands\";\nimport { brewLogger } from \"../logger\";\nimport { BrewLockError, isBrewLockMessage, BrewCommandError, StaleProcessError } from \"../errors\";\nimport { ExecResult } from \"../types\";\n\n/// Configuration\n\n/**\n * Default timeout for stale process detection (5 minutes).\n * If no progress is made for this duration, the process is considered stuck.\n */\nexport const DEFAULT_STALE_TIMEOUT_MS = 5 * 60 * 1000;\n\n/**\n * Timeout for download phase specifically (10 minutes).\n * Downloads can take longer, especially for large packages like LLVM.\n */\nexport const DOWNLOAD_PHASE_TIMEOUT_MS = 10 * 60 * 1000;\n\n/// Progress Types\n\n/**\n * Phases of a brew operation.\n */\nexport type BrewPhase =\n  | \"starting\"\n  | \"downloading\"\n  | \"verifying\"\n  | \"extracting\"\n  | \"installing\"\n  | \"linking\"\n  | \"cleaning\"\n  | \"complete\"\n  | \"error\";\n\n/**\n * Progress information for a brew operation.\n */\nexport interface BrewProgress {\n  phase: BrewPhase;\n  message: string;\n  percentage?: number;\n  bytesDownloaded?: number;\n  totalBytes?: number;\n}\n\n/**\n * Callback for progress updates.\n */\nexport type ProgressCallback = (progress: BrewProgress) => void;\n\n/// Progress Parsing\n\n/**\n * Parse brew output to extract progress information.\n */\nexport function parseBrewOutput(line: string): BrewProgress | null {\n  const trimmedLine = line.trim();\n  if (!trimmedLine) return null;\n\n  // Strip the \"==>\" prefix from Homebrew output for cleaner UI messages\n  const cleanMessage = trimmedLine.replace(/^=+>\\s*/, \"\");\n\n  // Downloading phase\n  if (trimmedLine.includes(\"Downloading\")) {\n    return { phase: \"downloading\", message: cleanMessage };\n  }\n\n  // Download progress (e.g., \"######## 50.0%\")\n  const percentMatch = trimmedLine.match(/#+\\s*(\\d+\\.?\\d*)%/);\n  if (percentMatch) {\n    return {\n      phase: \"downloading\",\n      message: `Downloading... ${percentMatch[1]}%`,\n      percentage: parseFloat(percentMatch[1]),\n    };\n  }\n\n  // Verifying checksum\n  if (trimmedLine.includes(\"Verifying\") || trimmedLine.includes(\"checksum\")) {\n    return { phase: \"verifying\", message: cleanMessage };\n  }\n\n  // Extracting/Pouring\n  if (trimmedLine.includes(\"Pouring\") || trimmedLine.includes(\"Extracting\")) {\n    return { phase: \"extracting\", message: cleanMessage };\n  }\n\n  // Installing\n  if (trimmedLine.includes(\"Installing\") || trimmedLine.includes(\"==> Installing\")) {\n    return { phase: \"installing\", message: cleanMessage };\n  }\n\n  // Linking\n  if (trimmedLine.includes(\"Linking\") || trimmedLine.includes(\"==> Linking\")) {\n    return { phase: \"linking\", message: cleanMessage };\n  }\n\n  // Cleaning\n  if (trimmedLine.includes(\"Cleaning\") || trimmedLine.includes(\"Removing\")) {\n    return { phase: \"cleaning\", message: cleanMessage };\n  }\n\n  // Caveats or summary\n  if (trimmedLine.includes(\"==> Caveats\") || trimmedLine.includes(\"==> Summary\")) {\n    return { phase: \"complete\", message: cleanMessage };\n  }\n\n  // Generic progress message\n  if (trimmedLine.startsWith(\"==>\")) {\n    return { phase: \"installing\", message: cleanMessage };\n  }\n\n  return null;\n}\n\n/**\n * Format bytes to human-readable string.\n */\nexport function formatBytes(bytes: number): string {\n  if (bytes < 1024) return `${bytes} B`;\n  if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;\n  if (bytes < 1024 * 1024 * 1024) return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;\n  return `${(bytes / (1024 * 1024 * 1024)).toFixed(1)} GB`;\n}\n\n/**\n * Options for executing brew commands with progress tracking.\n */\nexport interface ExecBrewWithProgressOptions {\n  /** Callback for progress updates */\n  onProgress?: ProgressCallback;\n  /** AbortSignal for cancellation */\n  cancel?: AbortSignal;\n  /** Timeout for stale process detection (ms). Default: 5 minutes */\n  staleTimeoutMs?: number;\n  /** Package name for error context */\n  packageName?: string;\n  /** Enable detailed phase logging */\n  verboseLogging?: boolean;\n}\n\n/**\n * Execute a brew command with real-time progress updates and stale process detection.\n *\n * Features:\n * - Real-time progress parsing from stdout/stderr\n * - Stale process detection (kills process if no progress for timeout period)\n * - Detailed phase logging for debugging stuck operations\n * - Lock error detection and proper error handling\n */\nexport async function execBrewWithProgress(\n  cmd: string,\n  onProgress?: ProgressCallback,\n  cancel?: AbortSignal,\n  options?: Omit<ExecBrewWithProgressOptions, \"onProgress\" | \"cancel\">,\n): Promise<ExecResult> {\n  const env = await execBrewEnv();\n  const args = cmd.split(/\\s+/).filter(Boolean);\n  const staleTimeoutMs = options?.staleTimeoutMs ?? DEFAULT_STALE_TIMEOUT_MS;\n  const packageName = options?.packageName;\n  const verboseLogging = options?.verboseLogging ?? false;\n\n  brewLogger.log(\"Executing brew with progress\", { command: cmd, packageName, staleTimeoutMs });\n\n  return new Promise((resolve, reject) => {\n    const proc = spawn(brewExecutable(), args, {\n      env,\n      stdio: [\"ignore\", \"pipe\", \"pipe\"],\n    });\n\n    let stdout = \"\";\n    let stderr = \"\";\n    let lastProgressTime = Date.now();\n    let currentPhase: BrewPhase = \"starting\";\n    let staleCheckInterval: NodeJS.Timeout | null = null;\n    let isRejected = false;\n\n    // Helper to clean up and reject\n    const cleanup = () => {\n      if (staleCheckInterval) {\n        clearInterval(staleCheckInterval);\n        staleCheckInterval = null;\n      }\n    };\n\n    const rejectOnce = (error: Error) => {\n      if (isRejected) return;\n      isRejected = true;\n      cleanup();\n      proc.kill(\"SIGTERM\");\n      reject(error);\n    };\n\n    // Stale process detection - check every 30 seconds\n    staleCheckInterval = setInterval(() => {\n      const now = Date.now();\n      const staleDuration = now - lastProgressTime;\n\n      // Use longer timeout for download phase\n      const effectiveTimeout = currentPhase === \"downloading\" ? DOWNLOAD_PHASE_TIMEOUT_MS : staleTimeoutMs;\n\n      if (staleDuration > effectiveTimeout) {\n        brewLogger.warn(\"Stale process detected\", {\n          command: cmd,\n          packageName,\n          lastPhase: currentPhase,\n          staleDurationMs: staleDuration,\n          timeoutMs: effectiveTimeout,\n        });\n\n        rejectOnce(\n          new StaleProcessError(`Process appears stuck during ${currentPhase}`, {\n            packageName,\n            lastPhase: currentPhase,\n            staleDurationMs: staleDuration,\n          }),\n        );\n      } else if (verboseLogging) {\n        brewLogger.log(\"Stale check passed\", {\n          command: cmd,\n          phase: currentPhase,\n          timeSinceLastProgress: staleDuration,\n          timeout: effectiveTimeout,\n        });\n      }\n    }, 30000);\n\n    // Handle cancellation\n    if (cancel) {\n      cancel.addEventListener(\"abort\", () => {\n        if (isRejected) return;\n        isRejected = true;\n        cleanup();\n        proc.kill(\"SIGTERM\");\n        const error = new Error(\"Cancelled\");\n        error.name = \"AbortError\";\n        reject(error);\n      });\n    }\n\n    // Report starting\n    onProgress?.({ phase: \"starting\", message: `Running: brew ${cmd.trim()}` });\n\n    // Helper to process output and update progress\n    const processOutput = (text: string, source: \"stdout\" | \"stderr\") => {\n      lastProgressTime = Date.now();\n\n      const lines = text.split(\"\\n\");\n      for (const line of lines) {\n        const progress = parseBrewOutput(line);\n        if (progress) {\n          // Track phase transitions for detailed logging\n          if (progress.phase !== currentPhase) {\n            brewLogger.log(\"Phase transition\", {\n              command: cmd,\n              packageName,\n              from: currentPhase,\n              to: progress.phase,\n              message: progress.message,\n            });\n            currentPhase = progress.phase;\n          }\n          onProgress?.(progress);\n        } else if (verboseLogging && line.trim()) {\n          // Log unparsed output for debugging\n          brewLogger.log(`Unparsed ${source}`, { line: line.trim() });\n        }\n      }\n    };\n\n    proc.stdout?.on(\"data\", (data: Buffer) => {\n      const text = data.toString();\n      stdout += text;\n      processOutput(text, \"stdout\");\n    });\n\n    proc.stderr?.on(\"data\", (data: Buffer) => {\n      const text = data.toString();\n      stderr += text;\n\n      // Check for lock errors\n      if (isBrewLockMessage(text)) {\n        rejectOnce(\n          new BrewLockError(\"Another brew process is already running\", {\n            command: cmd,\n          }),\n        );\n        return;\n      }\n\n      // Parse stderr for progress too (brew outputs some progress to stderr)\n      processOutput(text, \"stderr\");\n    });\n\n    proc.on(\"close\", (code) => {\n      cleanup();\n      if (isRejected) return;\n\n      brewLogger.log(\"Command completed\", {\n        command: cmd,\n        packageName,\n        exitCode: code,\n        finalPhase: currentPhase,\n      });\n\n      if (code === 0) {\n        onProgress?.({ phase: \"complete\", message: \"Operation completed successfully\" });\n        resolve({ stdout, stderr });\n      } else {\n        onProgress?.({ phase: \"error\", message: `Command failed with exit code ${code}` });\n        reject(\n          new BrewCommandError(`brew ${cmd} failed with exit code ${code}`, {\n            command: cmd,\n            exitCode: code ?? undefined,\n            stderr,\n          }),\n        );\n      }\n    });\n\n    proc.on(\"error\", (err) => {\n      cleanup();\n      if (isRejected) return;\n      onProgress?.({ phase: \"error\", message: err.message });\n      reject(err);\n    });\n  });\n}\n", "/**\n * Homebrew data fetching utilities.\n *\n * Provides functions for fetching installed and outdated packages.\n *\n * Performance optimization: Uses a two-phase loading strategy:\n * 1. Fast initial load with `brew list --versions` (returns minimal data quickly)\n * 2. Background fetch with `brew info --json=v2 --installed` for full metadata\n *\n * When `useInternalApi` preference is enabled, uses Homebrew's internal API:\n * - Formula: ~1 MB vs ~30 MB (96% smaller, much faster)\n * - Cask: Similar size but in JWS format\n */\n\nimport * as fs from \"fs/promises\";\nimport { execSync } from \"child_process\";\nimport {\n  Cask,\n  Formula,\n  InstallableResults,\n  InstalledMap,\n  OutdatedResults,\n  Remote,\n  DownloadProgressCallback,\n} from \"../types\";\nimport { cachePath, fetchRemote } from \"../cache\";\nimport { brewPath } from \"./paths\";\nimport { execBrew } from \"./commands\";\nimport { brewLogger, cacheLogger } from \"../logger\";\nimport { preferences } from \"../preferences\";\nimport { downloadAndCacheInternalFormulae, logInternalApiConfig } from \"./internal-api\";\n\n/// Cache Paths\n\nconst installedCachePath = cachePath(\"installedv2.json\");\nconst formulaCachePath = cachePath(\"formula.json\");\nconst caskCachePath = cachePath(\"cask.json\");\n\n/// Remote URLs\n\nconst formulaURL = \"https://formulae.brew.sh/api/formula.json\";\nconst caskURL = \"https://formulae.brew.sh/api/cask.json\";\n\nconst formulaRemote: Remote<Formula> = { url: formulaURL, cachePath: formulaCachePath };\nconst caskRemote: Remote<Cask> = { url: caskURL, cachePath: caskCachePath };\n\n/**\n * Check if the search cache files exist (formula.json and cask.json).\n * Used to determine if this is a cold start (no cache) or warm start (cache exists).\n */\nexport async function hasSearchCache(): Promise<boolean> {\n  try {\n    const [formulaStats, caskStats] = await Promise.all([fs.stat(formulaCachePath), fs.stat(caskCachePath)]);\n    // Both files must exist and have content\n    return formulaStats.size > 0 && caskStats.size > 0;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Minimal installed package info parsed from `brew list --versions`.\n * This is much faster than `brew info --json=v2 --installed`.\n */\ninterface InstalledListItem {\n  name: string;\n  version: string;\n  installed_on_request: boolean;\n}\n\n/**\n * Parse `brew list --versions` output into InstalledListItem array.\n * Format: \"package_name version1 version2 ...\" (one per line)\n */\nfunction parseListVersionsOutput(output: string): InstalledListItem[] {\n  const items: InstalledListItem[] = [];\n  const lines = output\n    .trim()\n    .split(\"\\n\")\n    .filter((line) => line.length > 0);\n\n  for (const line of lines) {\n    const parts = line.split(/\\s+/);\n    if (parts.length >= 2) {\n      const name = parts[0];\n      // Use the first (most recent) version\n      const version = parts[1];\n      items.push({\n        name,\n        version,\n        // We don't know this from list output, default to true\n        installed_on_request: true,\n      });\n    }\n  }\n\n  return items;\n}\n\n/**\n * Fetch a fast list of installed packages (names and versions only).\n * Uses `brew list --versions` which is significantly faster than `brew info --json=v2 --installed`.\n *\n * @returns Minimal installed package data for quick initial display\n */\nexport async function brewFetchInstalledFast(cancel?: AbortSignal): Promise<InstalledMap | undefined> {\n  const startTime = Date.now();\n\n  try {\n    // Try to read from cache first\n    const cacheBuffer = await fs.readFile(installedCachePath);\n    const cached = JSON.parse(cacheBuffer.toString()) as InstallableResults;\n    const mapped = brewMapInstalled(cached);\n    const duration = Date.now() - startTime;\n\n    cacheLogger.log(\"Fast load from cache\", {\n      formulaeCount: mapped?.formulae.size ?? 0,\n      casksCount: mapped?.casks.size ?? 0,\n      durationMs: duration,\n    });\n\n    return mapped;\n  } catch {\n    // Cache miss - fall back to fast list command\n    const listStartTime = Date.now();\n\n    try {\n      // brew list --versions is fast and gives us name + version\n      // Note: --versions output is \"name version1 version2 ...\" per line\n      const [formulaeOutput, casksOutput] = await Promise.all([\n        execBrew(`list --formula --versions`, cancel ? { signal: cancel } : undefined),\n        execBrew(`list --cask --versions`, cancel ? { signal: cancel } : undefined),\n      ]);\n\n      const formulaeList = parseListVersionsOutput(formulaeOutput.stdout);\n      const casksList = parseListVersionsOutput(casksOutput.stdout);\n\n      // Create minimal Formula/Cask objects for display\n      const formulae = new Map<string, Formula>();\n      for (const item of formulaeList) {\n        formulae.set(item.name, createMinimalFormula(item));\n      }\n\n      const casks = new Map<string, Cask>();\n      for (const item of casksList) {\n        casks.set(item.name, createMinimalCask(item));\n      }\n\n      const duration = Date.now() - listStartTime;\n      brewLogger.log(\"Fast list fetched\", {\n        formulaeCount: formulae.size,\n        casksCount: casks.size,\n        durationMs: duration,\n      });\n\n      return { formulae, casks };\n    } catch (err) {\n      brewLogger.error(\"Fast list fetch failed\", { error: err });\n      return undefined;\n    }\n  }\n}\n\n/**\n * Create a minimal Formula object from list data.\n */\nfunction createMinimalFormula(item: InstalledListItem): Formula {\n  return {\n    name: item.name,\n    tap: \"\",\n    homepage: \"\",\n    versions: { stable: item.version, bottle: false },\n    outdated: false,\n    license: null,\n    aliases: [],\n    dependencies: [],\n    build_dependencies: [],\n    installed: [\n      {\n        version: item.version,\n        installed_as_dependency: !item.installed_on_request,\n        installed_on_request: item.installed_on_request,\n      },\n    ],\n    keg_only: false,\n    linked_key: \"\",\n    pinned: false,\n  };\n}\n\n/**\n * Create a minimal Cask object from list data.\n */\nfunction createMinimalCask(item: InstalledListItem): Cask {\n  return {\n    token: item.name,\n    name: [item.name],\n    tap: \"\",\n    homepage: \"\",\n    version: item.version,\n    versions: { stable: item.version, bottle: false },\n    outdated: false,\n    installed: item.version,\n    auto_updates: false,\n    depends_on: {},\n  };\n}\n\n/**\n * Fetch all installed packages with full metadata.\n */\nexport async function brewFetchInstalled(useCache: boolean, cancel?: AbortSignal): Promise<InstalledMap | undefined> {\n  const startTime = Date.now();\n  const results = await brewFetchInstallableResults(useCache, cancel);\n  const mapped = brewMapInstalled(results);\n  const duration = Date.now() - startTime;\n\n  if (mapped) {\n    brewLogger.log(\"Installed packages fetched\", {\n      formulaeCount: mapped.formulae.size,\n      casksCount: mapped.casks.size,\n      totalCount: mapped.formulae.size + mapped.casks.size,\n      durationMs: duration,\n      fromCache: useCache,\n    });\n  }\n\n  return mapped;\n}\n\nasync function brewFetchInstallableResults(\n  useCache: boolean,\n  cancel?: AbortSignal,\n): Promise<InstallableResults | undefined> {\n  async function installed(): Promise<string> {\n    return (await execBrew(`info --json=v2 --installed`, cancel ? { signal: cancel } : undefined)).stdout;\n  }\n\n  if (!useCache) {\n    return JSON.parse(await installed());\n  }\n\n  async function updateCache(): Promise<InstallableResults> {\n    const startTime = Date.now();\n    const info = await installed();\n    const parsed = JSON.parse(info) as InstallableResults;\n    const duration = Date.now() - startTime;\n\n    try {\n      await fs.writeFile(installedCachePath, info);\n      const responseSizeBytes = Buffer.byteLength(info, \"utf8\");\n      const responseSizeKb = (responseSizeBytes / 1024).toFixed(2);\n\n      cacheLogger.log(\"Updated installed cache\", {\n        path: installedCachePath,\n        formulaeCount: parsed.formulae.length,\n        casksCount: parsed.casks.length,\n        totalCount: parsed.formulae.length + parsed.casks.length,\n        durationMs: duration,\n        responseSizeBytes,\n        responseSizeKb: `${responseSizeKb} KB`,\n        usingInternalApi: preferences.useInternalApi,\n      });\n    } catch (err) {\n      cacheLogger.error(\"Failed to write installed cache\", {\n        path: installedCachePath,\n        formulaeCount: parsed.formulae.length,\n        casksCount: parsed.casks.length,\n        error: err,\n      });\n    }\n    return parsed;\n  }\n\n  async function mtimeMs(path: string): Promise<number> {\n    return (await fs.stat(path)).mtimeMs;\n  }\n\n  async function readCache(): Promise<InstallableResults> {\n    const cacheTime = await mtimeMs(installedCachePath);\n    // 'var/homebrew/locks' is updated after installed keg_only or linked formula.\n    const locksTime = await mtimeMs(brewPath(\"var/homebrew/locks\"));\n    // Casks\n    const caskroomTime = await mtimeMs(brewPath(\"Caskroom\"));\n\n    // 'var/homebrew/pinned' is updated after pin/unpin actions (but does not exist if there are no pinned formula).\n    let pinnedTime;\n    try {\n      pinnedTime = await mtimeMs(brewPath(\"var/homebrew/pinned\"));\n    } catch {\n      pinnedTime = 0;\n    }\n    // Because '/var/homebrew/pinned can be removed, we need to also check the parent directory'\n    const homebrewTime = await mtimeMs(brewPath(\"var/homebrew\"));\n\n    if (homebrewTime < cacheTime && caskroomTime < cacheTime && locksTime < cacheTime && pinnedTime < cacheTime) {\n      const cacheBuffer = await fs.readFile(installedCachePath);\n      const cached = JSON.parse(cacheBuffer.toString()) as InstallableResults;\n      cacheLogger.log(\"Using cached installed data\", {\n        path: installedCachePath,\n        formulaeCount: cached.formulae.length,\n        casksCount: cached.casks.length,\n        totalCount: cached.formulae.length + cached.casks.length,\n        cacheAgeMs: Date.now() - cacheTime,\n      });\n      return cached;\n    } else {\n      cacheLogger.log(\"Cache invalidated, refreshing\", {\n        reason: \"brew state changed\",\n        homebrewTime,\n        caskroomTime,\n        locksTime,\n        pinnedTime,\n        cacheTime,\n      });\n      return await updateCache();\n    }\n  }\n\n  try {\n    return await readCache();\n  } catch {\n    return await updateCache();\n  }\n}\n\nfunction brewMapInstalled(installed?: InstallableResults): InstalledMap | undefined {\n  if (!installed) {\n    return undefined;\n  }\n\n  const formulae = new Map<string, Formula>();\n  for (const formula of installed.formulae) {\n    formulae.set(formula.name, formula);\n  }\n\n  const casks = new Map<string, Cask>();\n  for (const cask of installed.casks) {\n    casks.set(cask.token, cask);\n  }\n\n  return { formulae: formulae, casks: casks };\n}\n\n/**\n * Fetch outdated packages.\n *\n * @param greedy - Include auto-updating casks\n * @param cancel - AbortController for cancellation\n * @param skipUpdate - Skip brew update (use cached index). Faster but may miss recent updates.\n */\nexport async function brewFetchOutdated(\n  greedy: boolean,\n  cancel?: AbortSignal,\n  skipUpdate = false,\n): Promise<OutdatedResults> {\n  brewLogger.log(\"Fetching outdated packages\", { greedy, skipUpdate });\n  let cmd = `outdated --json=v2`;\n  if (greedy) {\n    cmd += \" --greedy\"; // include auto_update casks\n  }\n  // 'outdated' is only reliable after performing a 'brew update'\n  // skipUpdate allows showing stale data quickly, then refreshing\n  if (!skipUpdate) {\n    await brewUpdate(cancel);\n  }\n  const output = await execBrew(cmd, cancel ? { signal: cancel } : undefined);\n  const results = JSON.parse(output.stdout) as OutdatedResults;\n  brewLogger.log(\"Outdated packages fetched\", {\n    formulaeCount: results.formulae.length,\n    casksCount: results.casks.length,\n    skipUpdate,\n  });\n  return results;\n}\n\n/**\n * Run brew update.\n */\nexport async function brewUpdate(cancel?: AbortSignal): Promise<void> {\n  brewLogger.log(\"Running brew update\");\n  await execBrew(`update`, cancel ? { signal: cancel } : undefined);\n  brewLogger.log(\"Brew update completed\");\n}\n\n// Track if we've logged internal API config (only log once per session)\nlet hasLoggedInternalApiConfig = false;\n\n// Mutex to prevent concurrent internal API cache updates\n// This prevents memory exhaustion when multiple search calls happen simultaneously\nlet formulaeCacheUpdateInProgress: Promise<void> | null = null;\n\n/**\n * Check if the internal API cache needs updating.\n * Uses HEAD request to check Last-Modified header.\n */\nasync function needsInternalApiCacheUpdate(internalApiUrl: string, localCachePath: string): Promise<boolean> {\n  try {\n    const stats = await fs.stat(localCachePath);\n    if (stats.size === 0) return true;\n\n    const response = await fetch(internalApiUrl, { method: \"HEAD\" });\n    const lastModified = Date.parse(response.headers.get(\"last-modified\") ?? \"\");\n\n    if (lastModified > stats.mtimeMs) {\n      cacheLogger.log(\"Internal API cache outdated\", {\n        cachePath: localCachePath,\n        cacheTime: stats.mtimeMs,\n        remoteTime: lastModified,\n      });\n      return true;\n    }\n\n    cacheLogger.log(\"Internal API cache up to date\", {\n      cachePath: localCachePath,\n      cacheAgeMs: Date.now() - stats.mtimeMs,\n    });\n    return false;\n  } catch {\n    // Cache doesn't exist or error checking\n    return true;\n  }\n}\n\n/**\n * Fetch all formulae from the remote API.\n * Uses internal API when `useInternalApi` preference is enabled.\n * Falls back to public API if internal API fails.\n *\n * Hybrid approach (when useInternalApi is enabled):\n * 1. Downloads smaller internal API (~1 MB vs ~30 MB)\n * 2. Converts to standard array format and writes to cache\n * 3. Uses existing stream-json parsing for memory-efficient reading\n *\n * Internal API benefits:\n * - ~1 MB download vs ~30 MB (96% smaller)\n * - Much faster initial load\n * - Note: No description field (search by name only)\n */\nexport async function brewFetchFormulae(onProgress?: DownloadProgressCallback): Promise<Formula[]> {\n  if (preferences.useInternalApi) {\n    if (!hasLoggedInternalApiConfig) {\n      logInternalApiConfig();\n      hasLoggedInternalApiConfig = true;\n    }\n    try {\n      // Check if we need to update the cache from internal API\n      const internalApiUrl = \"https://formulae.brew.sh/api/internal/formula.\" + getSystemTagForCache() + \".jws.json\";\n      const needsUpdate = await needsInternalApiCacheUpdate(internalApiUrl, formulaCachePath);\n\n      if (needsUpdate) {\n        // Use mutex to prevent concurrent cache updates (memory exhaustion)\n        if (formulaeCacheUpdateInProgress) {\n          brewLogger.log(\"Waiting for existing formulae cache update to complete\");\n          await formulaeCacheUpdateInProgress;\n        } else {\n          // Download internal API and write to standard cache format\n          brewLogger.log(\"Updating formulae cache from internal API\");\n          formulaeCacheUpdateInProgress = downloadAndCacheInternalFormulae(formulaCachePath, onProgress);\n          try {\n            await formulaeCacheUpdateInProgress;\n          } finally {\n            formulaeCacheUpdateInProgress = null;\n          }\n        }\n      }\n\n      // Now use the standard fetchRemote path which uses stream-json\n      // The cache file is already populated, so this will just read it\n      return await fetchRemote(formulaRemote, onProgress);\n    } catch (error) {\n      // Internal API failed, fall back to public API\n      brewLogger.warn(\"Internal formulae API failed, falling back to public API\", {\n        error: error instanceof Error ? error.message : String(error),\n      });\n      return await fetchRemote(formulaRemote, onProgress);\n    }\n  }\n  return await fetchRemote(formulaRemote, onProgress);\n}\n\n/**\n * Fetch all casks from the remote API.\n * Always uses the public API with stream-json parsing for memory efficiency.\n *\n * Note: The internal API for casks is ~13 MB (vs ~30 MB public) but requires\n * complex JWS parsing that adds memory pressure. The public API's stream-json\n * parsing is more memory-efficient overall, so we use it exclusively for casks.\n *\n * The internal API is only used for formulae where the size difference is\n * significant (~1 MB vs ~30 MB, 96% smaller).\n */\nexport async function brewFetchCasks(onProgress?: DownloadProgressCallback): Promise<Cask[]> {\n  // Always use public API for casks - stream-json parsing is more memory-efficient\n  // than the JWS parsing overhead of the internal API\n  return await fetchRemote(caskRemote, onProgress);\n}\n\n/**\n * Get the system tag for internal API URLs.\n * This is a local helper to avoid circular imports.\n */\nfunction getSystemTagForCache(): string {\n  // Use the same logic as internal-api.ts\n  const arch = process.arch === \"arm64\" ? \"arm64\" : \"x86_64\";\n\n  // Get macOS version name\n  let osVersion = \"sequoia\"; // default\n  try {\n    const swVersOutput = execSync(\"sw_vers -productVersion\", {\n      encoding: \"utf8\",\n      timeout: 5000,\n      stdio: [\"pipe\", \"pipe\", \"pipe\"],\n    }).trim();\n    const majorVersion = parseInt(swVersOutput.split(\".\")[0], 10);\n\n    const versionNames: Record<number, string> = {\n      15: \"sequoia\",\n      14: \"sonoma\",\n      13: \"ventura\",\n      12: \"monterey\",\n      11: \"big_sur\",\n    };\n    osVersion = versionNames[majorVersion] || \"sequoia\";\n  } catch {\n    // Use default\n  }\n\n  return `${arch}_${osVersion}`;\n}\n\n/**\n * Fetch info for a single formula by name.\n * Much faster than fetching all installed packages.\n */\nexport async function brewFetchFormulaInfo(name: string, cancel?: AbortSignal): Promise<Formula | undefined> {\n  const startTime = Date.now();\n  brewLogger.log(\"Fetching formula info\", { name });\n\n  try {\n    const output = await execBrew(`info --json=v2 ${name}`, cancel ? { signal: cancel } : undefined);\n    const results = JSON.parse(output.stdout) as InstallableResults;\n    const duration = Date.now() - startTime;\n\n    if (results.formulae.length > 0) {\n      brewLogger.log(\"Formula info fetched\", { name, durationMs: duration });\n      return results.formulae[0];\n    }\n\n    brewLogger.warn(\"Formula not found\", { name, durationMs: duration });\n    return undefined;\n  } catch (err) {\n    brewLogger.error(\"Failed to fetch formula info\", { name, error: err });\n    return undefined;\n  }\n}\n\n/**\n * Fetch info for a single cask by token.\n * Much faster than fetching all installed packages.\n */\nexport async function brewFetchCaskInfo(token: string, cancel?: AbortSignal): Promise<Cask | undefined> {\n  const startTime = Date.now();\n  brewLogger.log(\"Fetching cask info\", { token });\n\n  try {\n    const output = await execBrew(`info --json=v2 ${token}`, cancel ? { signal: cancel } : undefined);\n    const results = JSON.parse(output.stdout) as InstallableResults;\n    const duration = Date.now() - startTime;\n\n    if (results.casks.length > 0) {\n      brewLogger.log(\"Cask info fetched\", { token, durationMs: duration });\n      return results.casks[0];\n    }\n\n    brewLogger.warn(\"Cask not found\", { token, durationMs: duration });\n    return undefined;\n  } catch (err) {\n    brewLogger.error(\"Failed to fetch cask info\", { token, error: err });\n    return undefined;\n  }\n}\n", "/**\n * Homebrew Internal API utilities.\n *\n * Provides functions for fetching data from Homebrew's internal JSON API.\n * This API is significantly smaller and faster than the public API:\n * - Formula: ~1 MB vs ~30 MB (96% smaller)\n * - Cask: Similar size but wrapped in JWS format\n *\n * The internal API is experimental and may change without notice.\n * Use the `useInternalApi` preference to enable it.\n */\n\nimport { cpus, release } from \"os\";\nimport { execSync } from \"child_process\";\nimport * as fs from \"fs\";\nimport { chain } from \"stream-chain\";\nimport { parser } from \"stream-json\";\nimport { pick } from \"stream-json/filters/Pick\";\nimport { streamObject } from \"stream-json/streamers/StreamObject\";\nimport { Formula, DownloadProgressCallback } from \"../types\";\nimport { cacheLogger, fetchLogger } from \"../logger\";\nimport { logMemory, withMemoryTracking } from \"../memory\";\n\n/// System Tag Detection\n\n/**\n * macOS version name mapping from major version number.\n * Darwin kernel version = macOS version + 4 (e.g., Darwin 24.x = macOS 15 Sequoia)\n * https://en.wikipedia.org/wiki/Darwin_(operating_system)#Release_history\n */\nconst MACOS_VERSION_NAMES: Record<number, string> = {\n  15: \"sequoia\", // macOS 15 (Darwin 24.x)\n  14: \"sonoma\", // macOS 14 (Darwin 23.x)\n  13: \"ventura\", // macOS 13 (Darwin 22.x)\n  12: \"monterey\", // macOS 12 (Darwin 21.x)\n  11: \"big_sur\", // macOS 11 (Darwin 20.x)\n  // Homebrew 5.0 dropped support for macOS 10.14 (Mojave) and earlier\n};\n\n// Future macOS versions (for development/testing)\nconst MACOS_FUTURE_VERSIONS: Record<string, number> = {\n  tahoe: 26, // macOS 26 (future)\n};\n\n// Cache detected values to avoid repeated system calls\nlet cachedSystemTag: string | null = null;\nlet cachedMacOSVersion: number | null = null;\n\n/**\n * Get the current system tag for internal API URLs.\n * Format: {arch}_{os_version} (e.g., \"arm64_sequoia\", \"x86_64_sonoma\")\n */\nexport function getSystemTag(): string {\n  if (cachedSystemTag) {\n    return cachedSystemTag;\n  }\n\n  const arch = getArchitecture();\n  const osVersion = getMacOSVersionName();\n  cachedSystemTag = `${arch}_${osVersion}`;\n\n  fetchLogger.log(\"Detected system tag\", {\n    systemTag: cachedSystemTag,\n    architecture: arch,\n    macOSVersion: osVersion,\n  });\n\n  return cachedSystemTag;\n}\n\n/**\n * Get the CPU architecture.\n * Uses process.arch as primary source, with CPU model as fallback.\n *\n * Handles:\n * - process.arch: \"arm64\" \u2192 \"arm64\", \"x64\" \u2192 \"x86_64\"\n * - CPU model detection: Fallback for edge cases (Apple Silicon, Intel detection)\n * - Error handling: Safe defaults if detection fails (returns \"x86_64\")\n */\nfunction getArchitecture(): string {\n  // Method 1: Use process.arch (most reliable)\n  // Node.js process.arch values: https://nodejs.org/api/process.html#process_process_arch\n  if (process.arch === \"arm64\") {\n    return \"arm64\";\n  }\n  if (process.arch === \"x64\") {\n    return \"x86_64\";\n  }\n  // Other architectures (ppc64, s390x, etc.) - not supported by Homebrew on macOS\n  // Treat unknown architectures as x86_64 (safe default)\n\n  // Method 2: Fallback to CPU model detection\n  // This handles edge cases where process.arch might be unreliable\n  try {\n    const cpuList = cpus();\n    if (!cpuList || cpuList.length === 0) {\n      // No CPUs detected, use safe default\n      fetchLogger.warn(\"No CPUs detected, defaulting to x86_64\");\n      return \"x86_64\";\n    }\n\n    const firstCpu = cpuList[0];\n    if (!firstCpu || typeof firstCpu.model !== \"string\") {\n      // CPU model is not a string, use safe default\n      fetchLogger.warn(\"CPU model is not a string, defaulting to x86_64\", {\n        cpuModel: typeof firstCpu?.model,\n      });\n      return \"x86_64\";\n    }\n\n    // Check for Apple Silicon markers\n    if (firstCpu.model.includes(\"Apple\")) {\n      return \"arm64\";\n    }\n\n    // Check for Intel markers\n    if (firstCpu.model.includes(\"Intel\")) {\n      return \"x86_64\";\n    }\n\n    // Unknown CPU model, use safe default\n    fetchLogger.warn(\"Unknown CPU model, defaulting to x86_64\", {\n      cpuModel: firstCpu.model,\n    });\n    return \"x86_64\";\n  } catch (error) {\n    // CPU detection failed entirely, use safe default\n    fetchLogger.warn(\"CPU detection failed, defaulting to x86_64\", {\n      error: error instanceof Error ? error.message : String(error),\n    });\n    return \"x86_64\";\n  }\n}\n\n/**\n * Get the macOS major version number.\n * Uses multiple detection methods for reliability.\n */\nfunction getMacOSVersion(): number {\n  if (cachedMacOSVersion !== null) {\n    return cachedMacOSVersion;\n  }\n\n  // Method 1: Check environment variable override (for testing/development)\n  const envVersion = process.env.HOMEBREW_MACOS_VERSION;\n  if (envVersion) {\n    const parsed = parseInt(envVersion, 10);\n    if (!isNaN(parsed) && parsed >= 11 && parsed <= 30) {\n      cachedMacOSVersion = parsed;\n      return cachedMacOSVersion;\n    }\n  }\n\n  // Method 2: Try sw_vers command (most accurate)\n  try {\n    const swVersOutput = execSync(\"sw_vers -productVersion\", {\n      encoding: \"utf8\",\n      timeout: 5000,\n      stdio: [\"pipe\", \"pipe\", \"pipe\"],\n    }).trim();\n    // Format: \"15.1\" or \"14.6.1\"\n    const majorVersion = parseInt(swVersOutput.split(\".\")[0], 10);\n    if (!isNaN(majorVersion) && majorVersion >= 11) {\n      cachedMacOSVersion = majorVersion;\n      return cachedMacOSVersion;\n    }\n  } catch {\n    // sw_vers failed, try next method\n  }\n\n  // Method 3: Derive from Darwin kernel version\n  // Darwin version = macOS version + 4 (approximately)\n  // e.g., Darwin 24.x = macOS 15 (Sequoia)\n  try {\n    const darwinVersion = release(); // e.g., \"24.1.0\"\n    const darwinMajor = parseInt(darwinVersion.split(\".\")[0], 10);\n    if (!isNaN(darwinMajor) && darwinMajor >= 20) {\n      // Darwin 20 = macOS 11, Darwin 21 = macOS 12, etc.\n      cachedMacOSVersion = darwinMajor - 9;\n      return cachedMacOSVersion;\n    }\n  } catch {\n    // Darwin version detection failed\n  }\n\n  // Method 4: Default based on architecture (last resort)\n  // Apple Silicon requires macOS 11+, most users are on recent versions\n  const arch = getArchitecture();\n  cachedMacOSVersion = arch === \"arm64\" ? 15 : 14; // Sequoia for ARM, Sonoma for Intel\n  return cachedMacOSVersion;\n}\n\n/**\n * Get the macOS version name (e.g., \"sequoia\", \"sonoma\").\n */\nfunction getMacOSVersionName(): string {\n  const version = getMacOSVersion();\n\n  // Check known versions\n  const versionName = MACOS_VERSION_NAMES[version];\n  if (versionName) {\n    return versionName;\n  }\n\n  // Check future versions\n  for (const [name, futureVersion] of Object.entries(MACOS_FUTURE_VERSIONS)) {\n    if (version === futureVersion) {\n      return name;\n    }\n  }\n\n  // Unknown version - use the most recent known version\n  // This handles cases where a new macOS is released before we update the map\n  if (version > 15) {\n    fetchLogger.warn(\"Unknown macOS version, using sequoia as fallback\", {\n      detectedVersion: version,\n    });\n    return \"sequoia\";\n  }\n\n  // Very old version (shouldn't happen with Homebrew 5.0)\n  fetchLogger.warn(\"Unsupported macOS version detected\", {\n    detectedVersion: version,\n    minimumSupported: 11,\n  });\n  return \"big_sur\";\n}\n\n/// Internal API URLs\n\nconst INTERNAL_API_BASE = \"https://formulae.brew.sh/api/internal\";\n\n/**\n * Get the internal API URL for formulae.\n */\nexport function getInternalFormulaUrl(): string {\n  const tag = getSystemTag();\n  return `${INTERNAL_API_BASE}/formula.${tag}.jws.json`;\n}\n\n/**\n * Get the internal API URL for casks.\n *\n * Note: Currently not used - casks use the public API for better memory efficiency.\n * The internal cask API (~13 MB) requires JWS parsing overhead that negates the\n * download size benefit compared to stream-json parsing the public API (~30 MB).\n * Kept for potential future use if a more efficient JWS parser is implemented.\n */\nexport function getInternalCaskUrl(): string {\n  const tag = getSystemTag();\n  return `${INTERNAL_API_BASE}/cask.${tag}.jws.json`;\n}\n\n/// JWS Payload Parsing\n\n/**\n * Internal formula data structure from the API.\n * Array format: [version, version_scheme, rebuild, sha256, dependencies]\n */\ntype InternalFormulaArray = [string, number, number, string | null, string[]];\n\n/// Streaming Cache Functions\n\n/**\n * Download internal API and write to standard cache format.\n *\n * This hybrid approach:\n * 1. Downloads the smaller internal API (~1 MB formulae vs ~30 MB)\n * 2. Extracts the JWS payload\n * 3. Converts to array format and writes to standard cache files\n * 4. Allows existing stream-json parsing to be used for reading\n *\n * Memory optimization: We stream the download to disk, then process\n * the JWS payload incrementally to avoid holding large data in memory.\n */\n\n/**\n * Download internal formulae API and write to cache in standard array format.\n * Uses streaming to avoid loading the entire payload into memory.\n *\n * @param cachePath - Path to write the converted cache file\n * @param onProgress - Optional callback for progress updates\n */\nexport async function downloadAndCacheInternalFormulae(\n  cachePath: string,\n  onProgress?: DownloadProgressCallback,\n): Promise<void> {\n  const url = getInternalFormulaUrl();\n  const startTime = Date.now();\n  const tempJwsPath = cachePath + \".jws.tmp\";\n\n  fetchLogger.log(\"Downloading internal formulae API for cache\", { url, cachePath });\n\n  await withMemoryTracking(\n    \"downloadAndCacheInternalFormulae\",\n    async () => {\n      // Report initial progress\n      onProgress?.({\n        url,\n        bytesDownloaded: 0,\n        totalBytes: 0,\n        percent: 0,\n        complete: false,\n        phase: \"downloading\",\n      });\n\n      const response = await fetch(url);\n      if (!response.ok || !response.body) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n\n      const contentLength = response.headers.get(\"content-length\");\n      const totalBytes = contentLength ? parseInt(contentLength, 10) : 0;\n\n      // Step 1: Stream download directly to temp file (no memory accumulation)\n      let bytesDownloaded = 0;\n      let lastProgressUpdate = 0;\n      const PROGRESS_THROTTLE_MS = 100;\n\n      const downloadStream = fs.createWriteStream(tempJwsPath);\n      const reader = response.body.getReader();\n\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) break;\n\n        downloadStream.write(Buffer.from(value));\n        bytesDownloaded += value.length;\n\n        const now = Date.now();\n        if (now - lastProgressUpdate >= PROGRESS_THROTTLE_MS) {\n          lastProgressUpdate = now;\n          const percent = totalBytes > 0 ? Math.round((bytesDownloaded / totalBytes) * 100) : -1;\n          onProgress?.({\n            url,\n            bytesDownloaded,\n            totalBytes,\n            percent,\n            complete: false,\n            phase: \"downloading\",\n          });\n        }\n      }\n\n      await new Promise<void>((resolve, reject) => {\n        downloadStream.end((err: Error | null) => {\n          if (err) reject(err);\n          else resolve();\n        });\n      });\n\n      logMemory(\"After formulae download to disk\");\n\n      onProgress?.({\n        url,\n        bytesDownloaded,\n        totalBytes,\n        percent: 100,\n        complete: false,\n        phase: \"processing\",\n      });\n\n      // Step 2: Extract the payload from JWS directly to a temp file (no memory accumulation)\n      const tempPayloadPath = cachePath + \".payload.tmp\";\n      await extractJwsPayloadToFile(tempJwsPath, tempPayloadPath);\n      logMemory(\"After JWS payload extraction to disk\");\n\n      // Step 4: Stream-parse the formulae and write to cache\n      // Formulae are in format: {\"formulae\": {\"name\": [version, scheme, rebuild, sha256, deps], ...}}\n      let itemsProcessed = 0;\n      const writeStream = fs.createWriteStream(cachePath);\n      writeStream.write(\"[\");\n\n      await new Promise<void>((resolve, reject) => {\n        const pipeline = chain([\n          fs.createReadStream(tempPayloadPath),\n          parser(),\n          pick({ filter: \"formulae\" }),\n          streamObject(),\n        ]);\n\n        let isFirst = true;\n\n        pipeline.on(\"data\", (data: { key: string; value: InternalFormulaArray }) => {\n          if (data && data.key && data.value) {\n            const formula = createFormulaFromInternal(data.key, data.value);\n\n            if (!isFirst) {\n              writeStream.write(\",\\n\");\n            } else {\n              writeStream.write(\"\\n\");\n              isFirst = false;\n            }\n            writeStream.write(JSON.stringify(formula));\n            itemsProcessed++;\n\n            // Report progress (throttled)\n            const now = Date.now();\n            if (now - lastProgressUpdate >= PROGRESS_THROTTLE_MS) {\n              lastProgressUpdate = now;\n              onProgress?.({\n                url,\n                bytesDownloaded,\n                totalBytes,\n                percent: 100,\n                complete: false,\n                phase: \"processing\",\n                itemsProcessed,\n              });\n            }\n          }\n        });\n\n        pipeline.on(\"end\", () => {\n          writeStream.write(\"\\n]\");\n          writeStream.end((err: Error | null) => {\n            if (err) reject(err);\n            else resolve();\n          });\n        });\n\n        pipeline.on(\"error\", reject);\n      });\n\n      // Clean up temp files\n      try {\n        fs.unlinkSync(tempJwsPath);\n        fs.unlinkSync(tempPayloadPath);\n      } catch {\n        // Ignore cleanup errors\n      }\n\n      logMemory(\"After formulae cache write (streaming)\");\n\n      const duration = Date.now() - startTime;\n      fetchLogger.log(\"Internal formulae cached\", {\n        url,\n        cachePath,\n        count: itemsProcessed,\n        durationMs: duration,\n        downloadBytes: bytesDownloaded,\n      });\n\n      onProgress?.({\n        url,\n        bytesDownloaded,\n        totalBytes,\n        percent: 100,\n        complete: true,\n        phase: \"processing\",\n        itemsProcessed,\n        totalItems: itemsProcessed,\n      });\n    },\n    { logAlways: true },\n  );\n}\n\n/**\n * Extract the payload from a JWS file and write it directly to another file.\n * This avoids loading the entire payload string into memory.\n *\n * The JWS format is: {\"payload\": \"...escaped JSON string...\", ...}\n * We stream through the file, find the payload value, unescape it, and write to output.\n *\n * Memory optimization: Use array-based buffering to avoid string concatenation overhead.\n */\nasync function extractJwsPayloadToFile(jwsFilePath: string, outputPath: string): Promise<void> {\n  return new Promise((resolve, reject) => {\n    const readStream = fs.createReadStream(jwsFilePath, { encoding: \"utf8\", highWaterMark: 16 * 1024 });\n    const writeStream = fs.createWriteStream(outputPath, { highWaterMark: 16 * 1024 });\n\n    let state: \"searching\" | \"in_payload\" | \"done\" = \"searching\";\n    let searchBuffer = \"\";\n    let unicodeBuffer = \"\";\n    let escapeNext = false;\n\n    // Use array-based buffering to avoid string concatenation memory overhead\n    const outputChunks: string[] = [];\n    let outputSize = 0;\n    const FLUSH_THRESHOLD = 8 * 1024; // Flush every 8KB\n\n    const flushOutput = () => {\n      if (outputChunks.length > 0) {\n        writeStream.write(outputChunks.join(\"\"));\n        outputChunks.length = 0;\n        outputSize = 0;\n      }\n    };\n\n    const appendOutput = (str: string) => {\n      outputChunks.push(str);\n      outputSize += str.length;\n      if (outputSize >= FLUSH_THRESHOLD) {\n        flushOutput();\n      }\n    };\n\n    // We're looking for: \"payload\":\" then capturing until the closing unescaped \"\n    const payloadMarker = '\"payload\":\"';\n\n    readStream.on(\"data\", (chunkData: string | Buffer) => {\n      const chunk = typeof chunkData === \"string\" ? chunkData : chunkData.toString(\"utf8\");\n      if (state === \"done\") return;\n\n      // Process chunk - collect runs of regular characters to batch\n      let runStart = -1;\n\n      for (let i = 0; i < chunk.length; i++) {\n        const char = chunk[i];\n\n        if (state === \"searching\") {\n          searchBuffer += char;\n          // Keep buffer small - only need enough to match the marker\n          if (searchBuffer.length > payloadMarker.length) {\n            searchBuffer = searchBuffer.slice(-payloadMarker.length);\n          }\n          if (searchBuffer === payloadMarker) {\n            state = \"in_payload\";\n            searchBuffer = \"\";\n          }\n        } else if (state === \"in_payload\") {\n          if (escapeNext) {\n            // Handle escape sequences\n            escapeNext = false;\n            if (char === \"n\") {\n              appendOutput(\"\\n\");\n            } else if (char === \"r\") {\n              appendOutput(\"\\r\");\n            } else if (char === \"t\") {\n              appendOutput(\"\\t\");\n            } else if (char === '\"') {\n              appendOutput('\"');\n            } else if (char === \"\\\\\") {\n              appendOutput(\"\\\\\");\n            } else if (char === \"/\") {\n              appendOutput(\"/\");\n            } else if (char === \"u\") {\n              // Unicode escape - collect next 4 chars\n              unicodeBuffer = \"\\\\u\";\n            } else {\n              // Unknown escape, write as-is\n              appendOutput(char);\n            }\n          } else if (unicodeBuffer.length > 0) {\n            unicodeBuffer += char;\n            if (unicodeBuffer.length === 6) {\n              // Complete unicode escape: \\uXXXX\n              try {\n                const codePoint = parseInt(unicodeBuffer.slice(2), 16);\n                appendOutput(String.fromCharCode(codePoint));\n              } catch {\n                appendOutput(unicodeBuffer);\n              }\n              unicodeBuffer = \"\";\n            }\n          } else if (char === \"\\\\\") {\n            // Flush any pending run before escape\n            if (runStart >= 0) {\n              appendOutput(chunk.slice(runStart, i));\n              runStart = -1;\n            }\n            escapeNext = true;\n          } else if (char === '\"') {\n            // Flush any pending run\n            if (runStart >= 0) {\n              appendOutput(chunk.slice(runStart, i));\n              runStart = -1;\n            }\n            // End of payload string\n            state = \"done\";\n            flushOutput();\n            writeStream.end();\n            resolve();\n            return;\n          } else {\n            // Regular character - start or continue a run\n            if (runStart < 0) {\n              runStart = i;\n            }\n          }\n        }\n      }\n\n      // Flush any remaining run from this chunk\n      if (state === \"in_payload\" && runStart >= 0) {\n        appendOutput(chunk.slice(runStart));\n      }\n    });\n\n    readStream.on(\"end\", () => {\n      if (state !== \"done\") {\n        flushOutput();\n        writeStream.end();\n        if (state === \"searching\") {\n          reject(new Error(\"No payload found in JWS file\"));\n        } else {\n          // Payload wasn't properly terminated, but we got data\n          resolve();\n        }\n      }\n    });\n\n    readStream.on(\"error\", (err) => {\n      writeStream.end();\n      reject(err);\n    });\n\n    writeStream.on(\"error\", reject);\n  });\n}\n\n/**\n * Create a Formula object from internal API data.\n * The internal API only provides minimal data, so we create a minimal Formula.\n */\nfunction createFormulaFromInternal(name: string, data: InternalFormulaArray): Formula {\n  const [version, , , , dependencies] = data;\n\n  return {\n    name,\n    tap: \"homebrew/core\",\n    homepage: \"\",\n    versions: { stable: version, bottle: true },\n    outdated: false,\n    license: null,\n    aliases: [],\n    dependencies: dependencies || [],\n    build_dependencies: [],\n    installed: [],\n    keg_only: false,\n    linked_key: \"\",\n    pinned: false,\n    // Note: desc is not available in internal API\n    // Users can still search by name\n  };\n}\n\n/**\n * Log internal API configuration for debugging.\n */\nexport function logInternalApiConfig(): void {\n  const tag = getSystemTag();\n  const formulaUrl = getInternalFormulaUrl();\n  const caskUrl = getInternalCaskUrl();\n\n  cacheLogger.log(\"Internal API configuration\", {\n    systemTag: tag,\n    formulaUrl,\n    caskUrl,\n  });\n}\n", "/**\n * Homebrew helper utilities.\n *\n * Provides utility functions for working with brew packages.\n */\n\nimport { join as path_join } from \"path\";\nimport { Cask, Formula, Nameable } from \"../types\";\nimport { preferences } from \"../preferences\";\nimport { brewPath, brewExecutable } from \"./paths\";\n\n/// Type Guards\n\n/**\n * Check if an item is a Cask (vs Formula).\n */\nexport function isCask(maybeCask: Cask | Nameable): maybeCask is Cask {\n  return (maybeCask as Cask).token !== undefined;\n}\n\n/// Identifiers\n\n/**\n * Get the identifier for a package (token for casks, name for formulae).\n */\nexport function brewIdentifier(item: Cask | Nameable): string {\n  return isCask(item) ? item.token : item.name;\n}\n\n/**\n * Get the display name for a package.\n */\nexport function brewName(item: Cask | Nameable): string {\n  if (isCask(item)) {\n    return item.name && item.name[0] ? item.name[0] : \"Unknown\";\n  } else {\n    return item.name;\n  }\n}\n\n/// Options\n\n/**\n * Get the --cask option for brew commands if the item is a cask.\n * Optionally includes --zap for uninstall operations.\n */\nexport function brewCaskOption(maybeCask: Cask | Nameable, zappable = false): string {\n  return isCask(maybeCask) ? \"--cask\" + (zappable && preferences.zapCask ? \" --zap\" : \"\") : \"\";\n}\n\n/// Installation Status\n\n/**\n * Check if a package is installed.\n */\nexport function brewIsInstalled(installable: Cask | Formula): boolean {\n  if (isCask(installable)) {\n    return caskIsInstalled(installable);\n  } else {\n    return formulaIsInstalled(installable);\n  }\n}\n\nfunction caskIsInstalled(cask: Cask): boolean {\n  if (cask.installed) {\n    return cask.installed.length > 0;\n  }\n  return false;\n}\n\nfunction formulaIsInstalled(formula: Formula): boolean {\n  return formula.installed.length > 0;\n}\n\n/// Installation Paths\n\n/**\n * Get the installation path for a package.\n */\nexport function brewInstallPath(installable: Cask | Formula): string {\n  if (isCask(installable)) {\n    return caskInstallPath(installable);\n  } else {\n    return formulaInstallPath(installable);\n  }\n}\n\nfunction caskInstallPath(cask: Cask): string {\n  // Casks are not updated as reliably, so we don't include the cask installed version here.\n  const basePath = brewPath(path_join(\"Caskroom\", cask.token));\n  if (cask.installed) {\n    return path_join(basePath, cask.installed);\n  } else {\n    return basePath;\n  }\n}\n\nfunction formulaInstallPath(formula: Formula): string {\n  const basePath = brewPath(path_join(\"Cellar\", formula.name));\n  const firstInstalled = formula.installed[0];\n  if (firstInstalled) {\n    return path_join(basePath, firstInstalled.version);\n  } else {\n    return basePath;\n  }\n}\n\n/// Version Formatting\n\n/**\n * Format the version string for display.\n */\nexport function brewFormatVersion(installable: Cask | Formula): string {\n  if (isCask(installable)) {\n    return caskFormatVersion(installable);\n  } else {\n    return formulaFormatVersion(installable);\n  }\n}\n\nfunction caskFormatVersion(cask: Cask): string {\n  if (!cask.installed) {\n    return \"\";\n  }\n\n  let version = cask.installed;\n  if (cask.outdated) {\n    version += \" (O)\";\n  }\n  return version;\n}\n\nfunction formulaFormatVersion(formula: Formula): string {\n  const installed_version = formula.installed[0];\n  if (!installed_version) {\n    return \"\";\n  }\n\n  let version = installed_version.version;\n  let status = \"\";\n  if (installed_version.installed_as_dependency) {\n    status += \"D\";\n  }\n  if (formula.pinned) {\n    status += \"P\";\n  }\n  if (formula.outdated) {\n    status += \"O\";\n  }\n  if (status) {\n    version += ` (${status})`;\n  }\n  return version;\n}\n\n/// Sorting\n\n/**\n * Compare function for sorting search results.\n * Prioritizes exact matches over partial matches.\n */\nexport function brewCompare(lhs: string, rhs: string, target: string): number {\n  const lhs_matches = lhs.toLowerCase().includes(target);\n  const rhs_matches = rhs.toLowerCase().includes(target);\n  if (lhs_matches && !rhs_matches) {\n    return -1;\n  } else if (rhs_matches && !lhs_matches) {\n    return 1;\n  } else {\n    return lhs.localeCompare(rhs);\n  }\n}\n\n/// Command Strings\n\n/**\n * Get the brew install command string for a package.\n */\nexport function brewInstallCommand(installable: Cask | Formula | Nameable): string {\n  const identifier = brewIdentifier(installable);\n  return `${brewExecutable()} install ${brewCaskOption(installable)} ${identifier}`.replace(/ +/g, \" \");\n}\n\n/**\n * Get the brew uninstall command string for a package.\n */\nexport function brewUninstallCommand(installable: Cask | Formula | Nameable): string {\n  const identifier = brewIdentifier(installable);\n  return `${brewExecutable()} uninstall ${brewCaskOption(installable, true)} ${identifier}`.replace(/ +/g, \" \");\n}\n\n/**\n * Get the brew upgrade command string for a package.\n */\nexport function brewUpgradeCommand(upgradable: Cask | Formula | Nameable): string {\n  const identifier = brewIdentifier(upgradable);\n  return `${brewExecutable()} upgrade ${brewCaskOption(upgradable)} ${identifier}`.replace(/ +/g, \" \");\n}\n", "/**\n * Homebrew search utilities.\n *\n * Provides functions for searching formulae and casks.\n */\n\nimport { Cask, Formula, InstallableResults, DownloadProgress } from \"../types\";\nimport { searchLogger } from \"../logger\";\nimport { brewFetchFormulae, brewFetchCasks } from \"./fetch\";\nimport { brewCompare } from \"./helpers\";\n\n// Store the query so that text entered during the initial fetch is respected.\nlet searchQuery: string | undefined;\n\n/** Progress callback for search download phases */\nexport interface SearchDownloadProgress {\n  /** Current phase: which file is being downloaded */\n  phase: \"casks\" | \"formulae\" | \"parsing\" | \"complete\";\n  /** Download progress for casks (if downloading) */\n  casksProgress?: DownloadProgress;\n  /** Download progress for formulae (if downloading) */\n  formulaeProgress?: DownloadProgress;\n}\n\nexport type SearchProgressCallback = (progress: SearchDownloadProgress) => void;\n\n/**\n * Search for packages matching the given text.\n *\n * @param searchText - The text to search for\n * @param limit - Maximum number of results per category\n * @param signal - AbortSignal for cancellation\n * @param onProgress - Optional callback for progress updates\n * @returns Matching formulae and casks\n */\nexport async function brewSearch(\n  searchText: string,\n  limit?: number,\n  signal?: AbortSignal,\n  onProgress?: SearchProgressCallback,\n): Promise<InstallableResults> {\n  searchLogger.log(\"Searching\", { query: searchText, limit });\n  searchQuery = searchText;\n\n  // Track progress for both downloads\n  let casksProgress: DownloadProgress | undefined;\n  let formulaeProgress: DownloadProgress | undefined;\n\n  // Download casks first (they have descriptions and are shown first in the UI)\n  onProgress?.({ phase: \"casks\" });\n\n  let casks = await brewFetchCasks((progress) => {\n    casksProgress = progress;\n    onProgress?.({\n      phase: \"casks\",\n      casksProgress: progress,\n      formulaeProgress,\n    });\n  });\n\n  if (signal?.aborted) {\n    const error = new Error(\"Aborted\");\n    error.name = \"AbortError\";\n    throw error;\n  }\n\n  onProgress?.({ phase: \"formulae\", casksProgress, formulaeProgress });\n\n  let formulae = await brewFetchFormulae((progress) => {\n    formulaeProgress = progress;\n    onProgress?.({\n      phase: \"formulae\",\n      casksProgress,\n      formulaeProgress: progress,\n    });\n  });\n\n  if (signal?.aborted) {\n    const error = new Error(\"Aborted\");\n    error.name = \"AbortError\";\n    throw error;\n  }\n\n  if (searchQuery.length > 0) {\n    const target = searchQuery.toLowerCase();\n    formulae = formulae\n      ?.filter((formula: Formula) => {\n        return formula.name.toLowerCase().includes(target) || formula.desc?.toLowerCase().includes(target);\n      })\n      .sort((lhs: Formula, rhs: Formula) => {\n        return brewCompare(lhs.name, rhs.name, target);\n      });\n\n    casks = casks\n      ?.filter((cask: Cask) => {\n        return (\n          cask.token.toLowerCase().includes(target) ||\n          cask.name.some((name: string) => name.toLowerCase().includes(target)) ||\n          cask.desc?.toLowerCase().includes(target)\n        );\n      })\n      .sort((lhs: Cask, rhs: Cask) => {\n        return brewCompare(lhs.token, rhs.token, target);\n      });\n  }\n\n  const formulaeLen = formulae.length;\n  const casksLen = casks.length;\n\n  if (limit) {\n    formulae = formulae.slice(0, limit);\n    casks = casks.slice(0, limit);\n  }\n\n  formulae.totalLength = formulaeLen;\n  casks.totalLength = casksLen;\n\n  searchLogger.log(\"Search completed\", {\n    query: searchText,\n    formulaeResults: formulae.length,\n    casksResults: casks.length,\n    totalFormulae: formulaeLen,\n    totalCasks: casksLen,\n    truncated: formulae.length < formulaeLen || casks.length < casksLen,\n  });\n\n  // Report final progress with total counts\n  onProgress?.({\n    phase: \"complete\",\n    formulaeProgress: formulaeProgress ? { ...formulaeProgress, totalItems: formulaeLen } : undefined,\n    casksProgress: casksProgress ? { ...casksProgress, totalItems: casksLen } : undefined,\n  });\n\n  return { formulae: formulae, casks: casks };\n}\n", "/**\n * Homebrew action utilities.\n *\n * Provides functions for installing, uninstalling, and upgrading packages.\n */\n\nimport { Cask, Formula, Nameable, OutdatedFormula } from \"../types\";\nimport { actionsLogger } from \"../logger\";\nimport { preferences } from \"../preferences\";\nimport { execBrew } from \"./commands\";\nimport { execBrewWithProgress, ProgressCallback } from \"./progress\";\nimport { brewIdentifier, brewCaskOption, isCask } from \"./helpers\";\nimport { ExecError } from \"../types\";\n\n/**\n * Install a package.\n */\nexport async function brewInstall(installable: Cask | Formula, cancel?: AbortSignal): Promise<void> {\n  const identifier = brewIdentifier(installable);\n  const isCaskType = isCask(installable);\n  actionsLogger.log(\"Installing package\", {\n    identifier,\n    type: isCaskType ? \"cask\" : \"formula\",\n  });\n  await execBrew(`install ${brewCaskOption(installable)} ${identifier}`, cancel ? { signal: cancel } : undefined);\n  if (isCaskType) {\n    (installable as Cask).installed = (installable as Cask).version;\n  } else {\n    installable.installed = [\n      { version: installable.versions.stable, installed_as_dependency: false, installed_on_request: true },\n    ];\n  }\n  actionsLogger.log(\"Package installed successfully\", { identifier });\n}\n\n/**\n * Install a package with real-time progress updates.\n */\nexport async function brewInstallWithProgress(\n  installable: Cask | Formula,\n  onProgress?: ProgressCallback,\n  cancel?: AbortSignal,\n): Promise<void> {\n  const identifier = brewIdentifier(installable);\n  const isCaskType = isCask(installable);\n  actionsLogger.log(\"Installing package with progress\", {\n    identifier,\n    type: isCaskType ? \"cask\" : \"formula\",\n  });\n  await execBrewWithProgress(`install ${brewCaskOption(installable)} ${identifier}`, onProgress, cancel);\n  if (isCaskType) {\n    (installable as Cask).installed = (installable as Cask).version;\n  } else {\n    installable.installed = [\n      { version: installable.versions.stable, installed_as_dependency: false, installed_on_request: true },\n    ];\n  }\n  actionsLogger.log(\"Package installed successfully\", { identifier });\n}\n\n/**\n * Uninstall a package.\n */\nexport async function brewUninstall(installable: Cask | Nameable, cancel?: AbortSignal): Promise<void> {\n  const identifier = brewIdentifier(installable);\n  actionsLogger.log(\"Uninstalling package\", {\n    identifier,\n    type: isCask(installable) ? \"cask\" : \"formula\",\n    zap: preferences.zapCask,\n  });\n  await execBrew(`rm ${brewCaskOption(installable, true)} ${identifier}`, cancel ? { signal: cancel } : undefined);\n  actionsLogger.log(\"Package uninstalled successfully\", { identifier });\n}\n\n/**\n * Upgrade a package.\n */\nexport async function brewUpgrade(upgradable: Cask | Nameable, cancel?: AbortSignal): Promise<void> {\n  const identifier = brewIdentifier(upgradable);\n  actionsLogger.log(\"Upgrading package\", {\n    identifier,\n    type: isCask(upgradable) ? \"cask\" : \"formula\",\n  });\n  await execBrew(`upgrade ${brewCaskOption(upgradable)} ${identifier}`, cancel ? { signal: cancel } : undefined);\n  actionsLogger.log(\"Package upgraded successfully\", { identifier });\n}\n\n/**\n * Upgrade a package with real-time progress updates.\n */\nexport async function brewUpgradeSingleWithProgress(\n  upgradable: Cask | Nameable,\n  onProgress?: ProgressCallback,\n  cancel?: AbortSignal,\n): Promise<void> {\n  const identifier = brewIdentifier(upgradable);\n  actionsLogger.log(\"Upgrading package with progress\", {\n    identifier,\n    type: isCask(upgradable) ? \"cask\" : \"formula\",\n  });\n  await execBrewWithProgress(`upgrade ${brewCaskOption(upgradable)} ${identifier}`, onProgress, cancel);\n  actionsLogger.log(\"Package upgraded successfully\", { identifier });\n}\n\n/**\n * Upgrade all packages.\n */\nexport async function brewUpgradeAll(greedy: boolean, cancel?: AbortSignal): Promise<void> {\n  actionsLogger.log(\"Upgrading all packages\", { greedy });\n  let cmd = `upgrade`;\n  if (greedy) {\n    cmd += \" --greedy\";\n  }\n  await execBrew(cmd, cancel ? { signal: cancel } : undefined);\n  actionsLogger.log(\"All packages upgraded successfully\");\n}\n\n/**\n * Run cleanup to remove old versions.\n */\nexport async function brewCleanup(withoutThreshold: boolean, cancel?: AbortSignal): Promise<void> {\n  actionsLogger.log(\"Running cleanup\", { pruneAll: withoutThreshold });\n  let cmd = `cleanup`;\n  if (withoutThreshold) {\n    cmd += \" --prune=all\";\n  }\n  await execBrew(cmd, cancel ? { signal: cancel } : undefined);\n  actionsLogger.log(\"Cleanup completed successfully\");\n}\n\n/**\n * Pin a formula to prevent upgrades.\n */\nexport async function brewPinFormula(formula: Formula | OutdatedFormula): Promise<void> {\n  actionsLogger.log(\"Pinning formula\", { name: formula.name });\n  await execBrew(`pin ${formula.name}`);\n  formula.pinned = true;\n  actionsLogger.log(\"Formula pinned successfully\", { name: formula.name });\n}\n\n/**\n * Unpin a formula to allow upgrades.\n */\nexport async function brewUnpinFormula(formula: Formula | OutdatedFormula): Promise<void> {\n  actionsLogger.log(\"Unpinning formula\", { name: formula.name });\n  await execBrew(`unpin ${formula.name}`);\n  formula.pinned = false;\n  actionsLogger.log(\"Formula unpinned successfully\", { name: formula.name });\n}\n\n/**\n * Run brew doctor to check for issues.\n */\nexport async function brewDoctor(): Promise<string> {\n  try {\n    const output = await execBrew(`doctor`);\n    return output.stdout;\n  } catch (err) {\n    const execErr = err as ExecError;\n    if (execErr?.code === 1) {\n      return execErr.stderr;\n    } else {\n      return `${err}`;\n    }\n  }\n}\n", "/**\n * Hook for searching brew packages.\n */\n\nimport { useEffect, useMemo, useRef, useState } from \"react\";\nimport { showToast, Toast } from \"@raycast/api\";\nimport { useCachedPromise, MutatePromise } from \"@raycast/utils\";\nimport {\n  brewSearch,\n  InstallableResults,\n  InstalledMap,\n  Cask,\n  Formula,\n  isBrewLockError,\n  getErrorMessage,\n  searchLogger,\n  SearchDownloadProgress,\n  DownloadProgress,\n  hasSearchCache,\n} from \"../utils\";\n\ninterface UseBrewSearchOptions {\n  searchText: string;\n  limit?: number;\n  installed?: InstalledMap;\n}\n\n/** Download progress for a single file */\nexport interface FileDownloadProgress {\n  /** Whether download has started */\n  started: boolean;\n  /** Whether download is complete */\n  complete: boolean;\n  /** Bytes downloaded so far */\n  bytesDownloaded: number;\n  /** Total bytes (0 if unknown) */\n  totalBytes: number;\n  /** Percentage (0-100, or -1 if unknown) */\n  percent: number;\n  /** Number of items processed so far (during processing phase) */\n  itemsProcessed: number;\n  /** Total number of items (known after processing completes) */\n  totalItems: number;\n}\n\n/** Overall loading state for the search */\nexport interface SearchLoadingState {\n  /** Whether we're currently loading */\n  isLoading: boolean;\n  /** Whether this is the initial load (never had data) */\n  isInitialLoad: boolean;\n  /** Current loading phase */\n  phase: \"casks\" | \"formulae\" | \"parsing\" | \"complete\";\n  /** Casks download progress */\n  casksProgress: FileDownloadProgress;\n  /** Formulae download progress */\n  formulaeProgress: FileDownloadProgress;\n}\n\n/** Total counts of packages in the index (not filtered by search) */\nexport interface IndexTotals {\n  formulae: number;\n  casks: number;\n}\n\ninterface UseBrewSearchResult {\n  isLoading: boolean;\n  isInitialLoad: boolean;\n  /** True if cache files exist, false if not, null if not yet checked */\n  hasCacheFiles: boolean | null;\n  loadingState: SearchLoadingState;\n  data: InstallableResults | undefined;\n  mutate: MutatePromise<InstallableResults | undefined>;\n  /** Total counts of packages in the index (for status display) */\n  indexTotals: IndexTotals | undefined;\n}\n\n/** Default progress state for a file */\nconst defaultFileProgress: FileDownloadProgress = {\n  started: false,\n  complete: false,\n  bytesDownloaded: 0,\n  totalBytes: 0,\n  percent: 0,\n  itemsProcessed: 0,\n  totalItems: 0,\n};\n\n/**\n * Hook to search brew packages with caching and abort support.\n *\n * Uses a two-layer approach to handle the race condition between search results\n * and installed data:\n * 1. Search results are fetched and cached without installed status\n * 2. Installed status is applied via useMemo when either search results or\n *    installed data changes, ensuring we always have the latest combination\n */\nexport function useBrewSearch(options: UseBrewSearchOptions): UseBrewSearchResult {\n  const { searchText, limit = 200, installed } = options;\n\n  // Track if we've ever received data (for initial load detection)\n  const hasEverLoadedRef = useRef(false);\n\n  // Track if cache exists (checked once at startup)\n  // null = not checked yet, true = cache exists (warm start), false = no cache (cold start)\n  const [cacheExists, setCacheExists] = useState<boolean | null>(null);\n\n  // Check cache existence once on mount using AbortController for safe cleanup\n  useEffect(() => {\n    const abortController = new AbortController();\n\n    hasSearchCache()\n      .then((exists) => {\n        // Only update state if the request wasn't aborted\n        if (!abortController.signal.aborted) {\n          setCacheExists(exists);\n          searchLogger.log(\"Cache check complete\", { cacheExists: exists });\n        }\n      })\n      .catch((error) => {\n        // Silently ignore abort errors\n        if (error.name !== \"AbortError\") {\n          searchLogger.error(\"Cache check failed\", {\n            error: error instanceof Error ? error.message : String(error),\n          });\n        }\n      });\n\n    return () => {\n      abortController.abort();\n    };\n  }, []);\n\n  // Track download progress for each file\n  const [downloadProgress, setDownloadProgress] = useState<SearchDownloadProgress>({\n    phase: \"casks\",\n  });\n\n  // Throttle progress updates to avoid render loops (max once per 100ms)\n  const lastProgressUpdateRef = useRef(0);\n  const PROGRESS_THROTTLE_MS = 100;\n\n  const abortable = useRef<AbortController>(null);\n  const {\n    isLoading: isLoadingFromHook,\n    data: rawData,\n    mutate,\n  } = useCachedPromise(\n    async (query: string) => {\n      searchLogger.log(\"Starting search\", { query, isInitialLoad: !hasEverLoadedRef.current });\n\n      // Reset progress at start of search\n      setDownloadProgress({ phase: \"casks\" });\n      // Reset throttle timer so first progress update shows immediately\n      lastProgressUpdateRef.current = 0;\n\n      // Fetch search results with progress tracking\n      // Always track progress - the UI decides whether to show it based on hasCacheFiles\n      const result = await brewSearch(query, limit, abortable.current?.signal, (progress) => {\n        try {\n          // AbortController signal will prevent further updates after abort\n          if (abortable.current?.signal.aborted) return;\n\n          // Throttle UI updates to avoid excessive re-renders\n          // Always allow through: complete phase, download completion, or throttle interval\n          const now = Date.now();\n          const isComplete = progress.phase === \"complete\";\n          const isCasksComplete = progress.casksProgress?.complete === true;\n          const isFormulaeComplete = progress.formulaeProgress?.complete === true;\n          const shouldUpdate =\n            isComplete ||\n            isCasksComplete ||\n            isFormulaeComplete ||\n            now - lastProgressUpdateRef.current >= PROGRESS_THROTTLE_MS;\n\n          if (shouldUpdate) {\n            lastProgressUpdateRef.current = now;\n            setDownloadProgress(progress);\n          }\n        } catch (error) {\n          // Prevent callback errors from breaking the search\n          searchLogger.error(\"Progress callback error\", {\n            error: error instanceof Error ? error.message : String(error),\n          });\n        }\n      });\n\n      // brewSearch reports phase: \"complete\" with final totals via onProgress\n      return result;\n    },\n    [searchText],\n    {\n      abortable,\n      keepPreviousData: true,\n      onError: async (error) => {\n        // Don't show toast for abort errors (user typing)\n        if (error.name === \"AbortError\") {\n          return;\n        }\n\n        searchLogger.error(\"Search failed\", {\n          errorType: error.name,\n          message: error.message,\n          isLockError: isBrewLockError(error),\n        });\n\n        const isLock = isBrewLockError(error);\n        const message = getErrorMessage(error);\n\n        await showToast({\n          style: Toast.Style.Failure,\n          title: isLock ? \"Brew is Busy\" : \"Search failed\",\n          message: isLock ? \"Another brew process is running. Please wait and try again.\" : message,\n        });\n      },\n    },\n  );\n\n  // Track when we first receive data\n  useEffect(() => {\n    if (rawData && !hasEverLoadedRef.current) {\n      searchLogger.log(\"Initial data loaded\", {\n        formulaeCount: rawData.formulae.length,\n        casksCount: rawData.casks.length,\n      });\n      hasEverLoadedRef.current = true;\n    }\n  }, [rawData]);\n\n  // Apply installed status to search results whenever either changes\n  const data = useMemo(() => {\n    if (!rawData) return undefined;\n\n    // Create a shallow copy to avoid mutating cached data\n    const formulae = rawData.formulae.map((f) => ({ ...f }));\n    const casks = rawData.casks.map((c) => ({ ...c }));\n\n    // Preserve totalLength from original arrays (set before slicing to limit)\n    formulae.totalLength = rawData.formulae.totalLength;\n    casks.totalLength = rawData.casks.totalLength;\n\n    const results: InstallableResults = { formulae, casks };\n\n    applyInstalledStatus(results, installed);\n    return results;\n  }, [rawData, installed]);\n\n  // isInitialLoad is true when we haven't received data yet\n  const isInitialLoad = !hasEverLoadedRef.current && !rawData;\n\n  // Compute isLoading - true if hook says loading OR if we're in initial load state\n  const isLoading = isLoadingFromHook || isInitialLoad;\n\n  // Convert DownloadProgress to FileDownloadProgress\n  const toFileProgress = (dp?: DownloadProgress): FileDownloadProgress => {\n    if (!dp) return defaultFileProgress;\n    return {\n      started: true,\n      complete: dp.complete,\n      bytesDownloaded: dp.bytesDownloaded,\n      totalBytes: dp.totalBytes,\n      percent: dp.percent,\n      itemsProcessed: dp.itemsProcessed ?? 0,\n      totalItems: dp.totalItems ?? 0,\n    };\n  };\n\n  // Build loading state object for UI\n  const loadingState: SearchLoadingState = useMemo(() => {\n    const casksProgress = toFileProgress(downloadProgress.casksProgress);\n    const formulaeProgress = toFileProgress(downloadProgress.formulaeProgress);\n\n    // Mark casks as started (we always start with casks now)\n    casksProgress.started = true;\n\n    // Mark formulae as started if we're in formulae phase or later\n    if (\n      downloadProgress.phase === \"formulae\" ||\n      downloadProgress.phase === \"parsing\" ||\n      downloadProgress.phase === \"complete\"\n    ) {\n      formulaeProgress.started = true;\n    }\n\n    // IMPORTANT: Only mark as \"complete\" when the phase has moved PAST that step\n    // This ensures we show \"Parsing...\" during the long parsing phase after download\n    // The download callback reports complete:true when download finishes, but parsing\n    // can take 30+ seconds after that.\n\n    // Casks is only truly complete when we've moved to formulae phase or later\n    if (\n      downloadProgress.phase === \"formulae\" ||\n      downloadProgress.phase === \"parsing\" ||\n      downloadProgress.phase === \"complete\"\n    ) {\n      casksProgress.complete = true;\n      casksProgress.percent = 100;\n    } else {\n      // Still in casks phase - don't mark as complete even if download says so\n      // This allows UI to show \"Parsing...\" state\n      casksProgress.complete = false;\n    }\n\n    // Formulae is only truly complete when we've moved to parsing or complete phase\n    if (downloadProgress.phase === \"parsing\" || downloadProgress.phase === \"complete\") {\n      formulaeProgress.complete = true;\n      formulaeProgress.percent = 100;\n    } else if (downloadProgress.phase === \"formulae\") {\n      // Still in formulae phase - don't mark as complete even if download says so\n      formulaeProgress.complete = false;\n    }\n\n    return {\n      isLoading,\n      isInitialLoad,\n      phase: downloadProgress.phase,\n      casksProgress,\n      formulaeProgress,\n    };\n  }, [isLoading, isInitialLoad, downloadProgress]);\n\n  // hasCacheFiles: true if cache files exist, false if not\n  // null means we haven't checked yet - UI should wait before deciding which view to show\n  const hasCacheFiles = cacheExists;\n\n  // Extract index totals from download progress (set when processing completes)\n  const indexTotals: IndexTotals | undefined = useMemo(() => {\n    const casksTotal = downloadProgress.casksProgress?.totalItems;\n    const formulaeTotal = downloadProgress.formulaeProgress?.totalItems;\n    if (casksTotal !== undefined && formulaeTotal !== undefined && casksTotal > 0 && formulaeTotal > 0) {\n      return { formulae: formulaeTotal, casks: casksTotal };\n    }\n    // Fallback to rawData totalLength if available (for warm cache starts)\n    if (rawData) {\n      const formulaeLen = rawData.formulae.totalLength ?? rawData.formulae.length;\n      const casksLen = rawData.casks.totalLength ?? rawData.casks.length;\n      if (formulaeLen > 0 || casksLen > 0) {\n        return { formulae: formulaeLen, casks: casksLen };\n      }\n    }\n    return undefined;\n  }, [downloadProgress.casksProgress?.totalItems, downloadProgress.formulaeProgress?.totalItems, rawData]);\n\n  return {\n    isLoading,\n    isInitialLoad,\n    hasCacheFiles,\n    loadingState,\n    data,\n    mutate,\n    indexTotals,\n  };\n}\n\n/**\n * Apply installed status to search results.\n * Mutates the results in place.\n */\nfunction applyInstalledStatus(results: InstallableResults, installed?: InstalledMap): void {\n  if (!results || !installed) {\n    return;\n  }\n\n  for (const formula of results.formulae) {\n    const info = installed.formulae instanceof Map ? installed.formulae.get(formula.name) : undefined;\n    if (info && isFormula(info)) {\n      formula.installed = info.installed;\n      formula.outdated = info.outdated;\n      formula.pinned = info.pinned;\n    } else {\n      formula.installed = [];\n      formula.outdated = false;\n      formula.pinned = false;\n    }\n  }\n\n  for (const cask of results.casks) {\n    const info = installed.casks instanceof Map ? installed.casks.get(cask.token) : undefined;\n    if (info && isCask(info)) {\n      cask.installed = info.installed;\n      cask.outdated = info.outdated;\n    } else {\n      cask.installed = undefined;\n      cask.outdated = false;\n    }\n  }\n}\n\ntype Installable = Cask | Formula;\n\nfunction isCask(installable: Installable): installable is Cask {\n  return (installable as Cask).token != undefined;\n}\n\nfunction isFormula(installable: Installable): installable is Formula {\n  return (installable as Formula).pinned != undefined;\n}\n\n/**\n * Check if a package is installed by name.\n */\nexport function isInstalled(name: string, installed?: InstalledMap): boolean {\n  if (!installed) {\n    return false;\n  }\n  return (\n    (installed.formulae instanceof Map && installed.formulae.get(name) != undefined) ||\n    (installed.casks instanceof Map && installed.casks.get(name) != undefined)\n  );\n}\n", "import { List } from \"@raycast/api\";\n\nexport enum InstallableFilterType {\n  all = \"all\",\n  formulae = \"formulae\",\n  casks = \"casks\",\n}\n\nexport function InstallableFilterDropdown(props: { onSelect: (value: InstallableFilterType) => void }) {\n  return (\n    <List.Dropdown\n      tooltip=\"Filter by formula or cask\"\n      onChange={(value) => {\n        props.onSelect(value as InstallableFilterType);\n      }}\n      storeValue\n    >\n      <List.Dropdown.Item value={InstallableFilterType.all} title=\"All\" />\n      <List.Dropdown.Item value={InstallableFilterType.formulae} title=\"Formulae\" />\n      <List.Dropdown.Item value={InstallableFilterType.casks} title=\"Casks\" />\n    </List.Dropdown>\n  );\n}\n\nexport function placeholder(filter: InstallableFilterType): string {\n  return `Search ${\n    filter === InstallableFilterType.all\n      ? \"formulae or casks\"\n      : filter === InstallableFilterType.casks\n        ? \"casks\"\n        : \"formulae\"\n  } by name${String.ellipsis}`;\n}\n", "import React from \"react\";\nimport { Color, Icon, List } from \"@raycast/api\";\nimport { getProgressIcon } from \"@raycast/utils\";\nimport { brewFormatVersion, brewIsInstalled, brewName, Cask, Formula } from \"../utils\";\nimport { CaskActionPanel, FormulaActionPanel } from \"./actionPanels\";\n\nconst tertiaryTextColor: Color.Dynamic = {\n  light: \"#00000066\",\n  dark: \"#FFFFFF66\",\n};\n\nexport interface FormulaListProps {\n  isLoading: boolean;\n  formulae: Formula[];\n  casks: Cask[];\n  searchBarPlaceholder: string;\n  searchBarAccessory?: React.ComponentProps<typeof List>[\"searchBarAccessory\"];\n  onSearchTextChange?: (q: string) => void;\n  isInstalled: (name: string) => boolean;\n  onAction: () => void;\n  filtering?: boolean;\n  dataFetched?: boolean;\n}\n\nexport function FormulaList(props: FormulaListProps) {\n  const formulae = props.formulae;\n  const casks = props.casks;\n  const hasResults = formulae.length > 0 || casks.length > 0;\n\n  return (\n    <List\n      searchBarPlaceholder={props.searchBarPlaceholder}\n      searchBarAccessory={props.searchBarAccessory}\n      onSearchTextChange={props.onSearchTextChange}\n      isLoading={props.isLoading}\n      filtering={props.filtering ?? true}\n      throttle\n    >\n      {!hasResults && (props.isLoading || !props.dataFetched) && (\n        <List.EmptyView\n          icon={getProgressIcon(0.5)}\n          title=\"Loading Packages\"\n          description=\"Fetching casks and formulae from Homebrew...\"\n        />\n      )}\n      {!hasResults && !props.isLoading && props.dataFetched && (\n        <List.EmptyView icon={Icon.MagnifyingGlass} title=\"No Results\" description=\"No packages found\" />\n      )}\n      {formulae.length > 0 && (\n        <List.Section title=\"Formulae\">\n          {formulae.map((formula) => (\n            <FormulaListItem\n              key={`formula-${formula.name}`}\n              formula={formula}\n              isInstalled={props.isInstalled}\n              onAction={props.onAction}\n            />\n          ))}\n          {formulae.isTruncated() && <MoreListItem />}\n        </List.Section>\n      )}\n      {casks.length > 0 && (\n        <List.Section title=\"Casks\">\n          {casks.map((cask) => (\n            <CaskListItem\n              key={`cask-${cask.token}`}\n              cask={cask}\n              isInstalled={props.isInstalled}\n              onAction={props.onAction}\n            />\n          ))}\n          {casks.isTruncated() && <MoreListItem />}\n        </List.Section>\n      )}\n    </List>\n  );\n}\n\nexport function FormulaListItem(props: {\n  formula: Formula;\n  isInstalled: (name: string) => boolean;\n  onAction: () => void;\n}) {\n  const formula = props.formula;\n  let version = formula.versions.stable;\n  let tintColor: Color.ColorLike = tertiaryTextColor;\n  let tooltip: string | undefined = undefined;\n  let iconMark: Icon = Icon.Circle;\n\n  if (brewIsInstalled(formula)) {\n    version = brewFormatVersion(formula);\n    tintColor = formula.outdated ? Color.Red : Color.Green;\n    iconMark = Icon.CheckCircle;\n    tooltip = formula.outdated ? \"Outdated\" : \"Up to date\";\n  }\n\n  const icon = { source: iconMark, tintColor: tintColor };\n\n  return (\n    <List.Item\n      title={formula.name}\n      subtitle={formula.desc}\n      accessories={[{ text: version }]}\n      icon={tooltip ? { value: icon, tooltip } : icon}\n      actions={\n        <FormulaActionPanel\n          formula={formula}\n          showDetails={true}\n          isInstalled={props.isInstalled}\n          onAction={props.onAction}\n        />\n      }\n    />\n  );\n}\n\nexport function CaskListItem(props: { cask: Cask; isInstalled: (name: string) => boolean; onAction: () => void }) {\n  const cask = props.cask;\n  let version = cask.version;\n  let tintColor: Color.ColorLike = tertiaryTextColor;\n  let tooltip: string | undefined = undefined;\n  let iconMark: Icon = Icon.Circle;\n\n  if (brewIsInstalled(cask)) {\n    version = brewFormatVersion(cask);\n    tintColor = cask.outdated ? Color.Red : Color.Green;\n    iconMark = Icon.CheckCircle;\n    tooltip = cask.outdated ? \"Outdated\" : \"Up to date\";\n  }\n\n  const icon = { source: iconMark, tintColor: tintColor };\n\n  return (\n    <List.Item\n      title={brewName(cask)}\n      subtitle={cask.desc}\n      accessories={[{ text: version }]}\n      icon={tooltip ? { value: icon, tooltip } : icon}\n      actions={\n        <CaskActionPanel cask={cask} showDetails={true} isInstalled={props.isInstalled} onAction={props.onAction} />\n      }\n    />\n  );\n}\n\nexport function MoreListItem() {\n  return <List.Item title=\"\" icon={Icon.Dot} />;\n}\n", "import { Action, ActionPanel, Detail, Icon } from \"@raycast/api\";\nimport {\n  brewIsInstalled,\n  brewInstallPath,\n  brewInstallCommand,\n  brewUninstallCommand,\n  brewUpgradeCommand,\n  Cask,\n  Formula,\n  OutdatedCask,\n  OutdatedFormula,\n} from \"../utils\";\nimport { FormulaInfo } from \"./formulaInfo\";\nimport { CaskInfo } from \"./caskInfo\";\nimport * as Actions from \"./actions\";\nimport { useTerminalApp } from \"../utils/terminal\";\n\nconst DebugSection = (props: { obj: Cask | Formula }) => (\n  <ActionPanel.Section>\n    <Action.Push\n      target={\n        <Detail\n          navigationTitle=\"Debug Info\"\n          markdown={\"```json\\n\" + JSON.stringify(props.obj, null, 2) + \"\\n```\"}\n          actions={\n            <ActionPanel>\n              <Action.CopyToClipboard title=\"Copy JSON\" content={JSON.stringify(props.obj, null, 2)} />\n            </ActionPanel>\n          }\n        />\n      }\n      title=\"Debug\"\n      icon={Icon.MagnifyingGlass}\n    />\n  </ActionPanel.Section>\n);\n\nexport function CaskActionPanel(props: {\n  cask: Cask;\n  showDetails: boolean;\n  isInstalled: (name: string) => boolean;\n  onAction: (result: boolean) => void;\n}) {\n  const { cask } = props;\n  const { terminalName, terminalIcon, runCommandInTerminal } = useTerminalApp();\n\n  function installedActionPanel() {\n    return (\n      <ActionPanel>\n        <ActionPanel.Section>\n          {props.showDetails && (\n            <Action.Push\n              title=\"Show Details\"\n              icon={Icon.Document}\n              target={<CaskInfo cask={cask} isInstalled={props.isInstalled} onAction={props.onAction} />}\n            />\n          )}\n          {cask.outdated && <Actions.FormulaUpgradeAction formula={cask} onAction={props.onAction} />}\n          <Action.ShowInFinder path={brewInstallPath(cask)} />\n        </ActionPanel.Section>\n        <ActionPanel.Section>\n          <Action.OpenInBrowser title=\"Open Cask\" url={`https://formulae.brew.sh/cask/${cask.token}`} />\n          <Action.CopyToClipboard title=\"Copy Cask URL\" content={`https://formulae.brew.sh/cask/${cask.token}`} />\n        </ActionPanel.Section>\n        <ActionPanel.Section>\n          <Action.OpenInBrowser title=\"Open Homepage\" url={cask.homepage} />\n          <Action.CopyToClipboard title=\"Copy Homepage URL\" content={cask.homepage} />\n        </ActionPanel.Section>\n        <ActionPanel.Section>\n          <Actions.FormulaUninstallAction formula={cask} onAction={props.onAction} />\n          <Action.CopyToClipboard\n            title=\"Copy Uninstall Command\"\n            content={brewUninstallCommand(cask)}\n            shortcut={{ modifiers: [\"cmd\", \"opt\"], key: \"c\" }}\n          />\n          <Action\n            title={`Run Uninstall in ${terminalName}`}\n            icon={terminalIcon}\n            style={Action.Style.Destructive}\n            onAction={() => runCommandInTerminal(brewUninstallCommand(cask))}\n          />\n        </ActionPanel.Section>\n\n        <ActionPanel.Section>\n          <Action.CopyToClipboard\n            title=\"Copy Cask Name\"\n            content={cask.token}\n            shortcut={{ modifiers: [\"cmd\", \"shift\"], key: \"c\" }}\n          />\n          <Action.CopyToClipboard title=\"Copy Tap Name\" content={cask.tap} />\n        </ActionPanel.Section>\n\n        <DebugSection obj={cask} />\n      </ActionPanel>\n    );\n  }\n\n  function uninstalledActionPanel() {\n    return (\n      <ActionPanel>\n        <ActionPanel.Section>\n          {props.showDetails && (\n            <Action.Push\n              title=\"Show Details\"\n              icon={Icon.Document}\n              target={<CaskInfo cask={cask} isInstalled={props.isInstalled} onAction={props.onAction} />}\n            />\n          )}\n          <Actions.FormulaInstallAction formula={cask} onAction={props.onAction} />\n        </ActionPanel.Section>\n        <ActionPanel.Section>\n          <Action.CopyToClipboard title=\"Copy Tap Name\" content={cask.tap} />\n\n          <Action.CopyToClipboard\n            title=\"Copy Cask Name\"\n            content={cask.token}\n            shortcut={{ modifiers: [\"cmd\", \"shift\"], key: \"c\" }}\n          />\n          <Action.CopyToClipboard\n            title=\"Copy Install Command\"\n            content={brewInstallCommand(cask)}\n            shortcut={{ modifiers: [\"cmd\", \"opt\"], key: \"c\" }}\n          />\n          <Action\n            title={`Run Install in ${terminalName}`}\n            icon={terminalIcon}\n            onAction={() => runCommandInTerminal(brewInstallCommand(cask))}\n          />\n        </ActionPanel.Section>\n        <ActionPanel.Section>\n          <Action.OpenInBrowser title=\"Open Cask\" url={`https://formulae.brew.sh/cask/${cask.token}`} />\n          <Action.CopyToClipboard title=\"Copy Cask URL\" content={`https://formulae.brew.sh/cask/${cask.token}`} />\n        </ActionPanel.Section>\n        <ActionPanel.Section>\n          <Action.OpenInBrowser title=\"Open Homepage\" url={cask.homepage} />\n          <Action.CopyToClipboard title=\"Copy Homepage URL\" content={cask.homepage} />\n        </ActionPanel.Section>\n      </ActionPanel>\n    );\n  }\n\n  if (brewIsInstalled(props.cask)) {\n    return installedActionPanel();\n  } else {\n    return uninstalledActionPanel();\n  }\n}\n\nexport function FormulaActionPanel(props: {\n  formula: Formula;\n  showDetails: boolean;\n  isInstalled: (name: string) => boolean;\n  onAction: (result: boolean) => void;\n}) {\n  const { formula } = props;\n  const { terminalName, terminalIcon, runCommandInTerminal } = useTerminalApp();\n\n  function installedActionPanel() {\n    return (\n      <ActionPanel>\n        <ActionPanel.Section>\n          {props.showDetails && (\n            <Action.Push\n              title=\"Show Details\"\n              icon={Icon.Document}\n              target={<FormulaInfo formula={formula} isInstalled={props.isInstalled} onAction={props.onAction} />}\n            />\n          )}\n          {formula.outdated && <Actions.FormulaUpgradeAction formula={formula} onAction={props.onAction} />}\n          <Action.ShowInFinder path={brewInstallPath(formula)} />\n          <Actions.FormulaPinAction formula={formula} onAction={props.onAction} />\n        </ActionPanel.Section>\n        <ActionPanel.Section>\n          <Action.OpenInBrowser title=\"Open Formula\" url={`https://formulae.brew.sh/formula/${formula.name}`} />\n          <Action.CopyToClipboard\n            title=\"Copy Formula URL\"\n            content={`https://formulae.brew.sh/formula/${formula.name}`}\n          />\n        </ActionPanel.Section>\n        <ActionPanel.Section>\n          <Action.OpenInBrowser title=\"Open Homepage\" url={formula.homepage} />\n          <Action.CopyToClipboard title=\"Copy Homepage URL\" content={formula.homepage} />\n        </ActionPanel.Section>\n        <ActionPanel.Section>\n          <Actions.FormulaUninstallAction formula={formula} onAction={props.onAction} />\n          <Action.CopyToClipboard\n            title=\"Copy Uninstall Command\"\n            content={brewUninstallCommand(formula)}\n            shortcut={{ modifiers: [\"cmd\", \"opt\"], key: \"c\" }}\n          />\n          <Action\n            title={`Run Uninstall in ${terminalName}`}\n            style={Action.Style.Destructive}\n            icon={terminalIcon}\n            onAction={() => runCommandInTerminal(brewUninstallCommand(formula))}\n          />\n        </ActionPanel.Section>\n\n        <DebugSection obj={formula} />\n      </ActionPanel>\n    );\n  }\n\n  function uninstalledActionPanel() {\n    return (\n      <ActionPanel>\n        <ActionPanel.Section>\n          {props.showDetails && (\n            <Action.Push\n              title=\"Show Details\"\n              icon={Icon.Document}\n              target={<FormulaInfo formula={formula} isInstalled={props.isInstalled} onAction={props.onAction} />}\n            />\n          )}\n          <Actions.FormulaInstallAction formula={formula} onAction={props.onAction} />\n        </ActionPanel.Section>\n        <ActionPanel.Section>\n          <Action.CopyToClipboard\n            title=\"Copy Formula Name\"\n            content={formula.name}\n            shortcut={{ modifiers: [\"cmd\", \"shift\"], key: \"c\" }}\n          />\n\n          <Action.CopyToClipboard\n            title=\"Copy Install Command\"\n            content={brewInstallCommand(formula)}\n            shortcut={{ modifiers: [\"cmd\", \"opt\"], key: \"c\" }}\n          />\n          <Action\n            title={`Run Install in ${terminalName}`}\n            icon={terminalIcon}\n            onAction={() => runCommandInTerminal(brewInstallCommand(formula))}\n          />\n        </ActionPanel.Section>\n        <ActionPanel.Section>\n          <Action.OpenInBrowser title=\"Open Formula\" url={`https://formulae.brew.sh/formula/${formula.name}`} />\n          <Action.CopyToClipboard\n            title=\"Copy Formula URL\"\n            content={`https://formulae.brew.sh/formula/${formula.name}`}\n          />\n        </ActionPanel.Section>\n        <ActionPanel.Section>\n          <Action.OpenInBrowser title=\"Open Homepage\" url={formula.homepage} />\n          <Action.CopyToClipboard title=\"Copy Homepage URL\" content={formula.homepage} />\n        </ActionPanel.Section>\n\n        <DebugSection obj={formula} />\n      </ActionPanel>\n    );\n  }\n\n  if (brewIsInstalled(props.formula)) {\n    return installedActionPanel();\n  } else {\n    return uninstalledActionPanel();\n  }\n}\n\nexport function OutdatedActionPanel(props: {\n  outdated: OutdatedCask | OutdatedFormula;\n  onAction: (result: boolean) => void;\n}) {\n  const { outdated } = props;\n  const { terminalName, terminalIcon, runCommandInTerminal } = useTerminalApp();\n\n  function isPinable(o: OutdatedCask | OutdatedFormula): o is OutdatedFormula {\n    return (o as OutdatedFormula).pinned != undefined;\n  }\n\n  return (\n    <ActionPanel>\n      <ActionPanel.Section>\n        <Actions.FormulaUpgradeAction formula={outdated} onAction={props.onAction} />\n        <Actions.FormulaUpgradeAllAction onAction={props.onAction} />\n        {isPinable(outdated) && <Actions.FormulaPinAction formula={outdated} onAction={props.onAction} />}\n      </ActionPanel.Section>\n      <ActionPanel.Section>\n        <Action.CopyToClipboard\n          title=\"Copy Upgrade Command\"\n          content={brewUpgradeCommand(outdated)}\n          shortcut={{ modifiers: [\"cmd\", \"opt\"], key: \"c\" }}\n        />\n        <Action\n          title={`Run Upgrade in ${terminalName}`}\n          icon={terminalIcon}\n          onAction={() => runCommandInTerminal(brewUpgradeCommand(outdated))}\n        />\n      </ActionPanel.Section>\n      <ActionPanel.Section>\n        <Actions.FormulaUninstallAction formula={outdated} onAction={props.onAction} />\n        <Action.CopyToClipboard title=\"Copy Uninstall Command\" content={brewUninstallCommand(outdated)} />\n        <Action\n          title={`Run Uninstall in ${terminalName}`}\n          icon={terminalIcon}\n          style={Action.Style.Destructive}\n          onAction={() => runCommandInTerminal(brewUninstallCommand(outdated))}\n        />\n      </ActionPanel.Section>\n    </ActionPanel>\n  );\n}\n", "import React, { useEffect, useState } from \"react\";\nimport { Detail, showToast, Toast, useNavigation } from \"@raycast/api\";\nimport { FormulaActionPanel } from \"./actionPanels\";\nimport { Formula, brewIsInstalled, brewPrefix, brewFetchFormulaInfo, uiLogger, ensureError } from \"../utils\";\nimport { Dependencies } from \"./dependencies\";\n\n/**\n * Check if a formula has minimal data (from fast list) vs full data.\n */\nfunction hasMinimalData(formula: Formula): boolean {\n  // Minimal formulae have missing or empty homepage, tap, or desc\n  return !formula.homepage || !formula.tap || !formula.desc;\n}\n\nexport function FormulaInfo(props: {\n  formula: Formula;\n  isInstalled: (name: string) => boolean;\n  onAction: (result: boolean) => void;\n}) {\n  const { pop } = useNavigation();\n  const [formula, setFormula] = useState<Formula>(props.formula);\n  const [isLoading, setIsLoading] = useState(false);\n\n  // Log when viewing formula info\n  useEffect(() => {\n    uiLogger.log(\"Viewing formula info\", {\n      name: props.formula.name,\n      hasMinimalData: hasMinimalData(props.formula),\n      installed: props.formula.installed?.length > 0,\n      version: props.formula.versions.stable,\n    });\n  }, [props.formula]);\n\n  // Lazy load full formula data if we only have minimal data\n  useEffect(() => {\n    if (!hasMinimalData(props.formula)) {\n      return;\n    }\n\n    const loadFullData = async () => {\n      setIsLoading(true);\n      const toast = await showToast({\n        style: Toast.Style.Animated,\n        title: `Loading ${props.formula.name} info...`,\n      });\n\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout\n\n      try {\n        const fullFormula = await brewFetchFormulaInfo(props.formula.name, controller.signal);\n        clearTimeout(timeoutId);\n\n        if (fullFormula) {\n          // Preserve installed info from initial formula\n          if (props.formula.installed?.length > 0) {\n            fullFormula.installed = props.formula.installed;\n          }\n          setFormula(fullFormula);\n          uiLogger.log(\"Formula info loaded\", {\n            name: fullFormula.name,\n            desc: fullFormula.desc?.substring(0, 50),\n            dependencies: fullFormula.dependencies?.length ?? 0,\n          });\n          toast.hide();\n        } else {\n          toast.style = Toast.Style.Failure;\n          toast.title = \"Failed to load formula info\";\n        }\n      } catch (err) {\n        clearTimeout(timeoutId);\n        const isTimeout = ensureError(err).name === \"AbortError\";\n        uiLogger.error(\"Failed to load formula info\", {\n          name: props.formula.name,\n          error: err,\n          timeout: isTimeout,\n        });\n        toast.style = Toast.Style.Failure;\n        toast.title = isTimeout ? \"Formula info load timed out\" : \"Failed to load formula info\";\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    loadFullData();\n  }, [props.formula]);\n\n  return (\n    <Detail\n      isLoading={isLoading}\n      markdown={formatInfo(formula)}\n      metadata={\n        <Detail.Metadata>\n          {formula.homepage ? (\n            <Detail.Metadata.Link title=\"Homepage\" text={formula.homepage} target={formula.homepage} />\n          ) : (\n            <Detail.Metadata.Label title=\"Homepage\" text=\"Loading...\" />\n          )}\n          {formula.license && <Detail.Metadata.Label title=\"License\" text={formula.license} />}\n          <Detail.Metadata.Label title=\"Versions\" text={formatVersions(formula)} />\n          {formula.versions.head && <Detail.Metadata.Label title=\"\" text={formula.versions.head} />}\n          <Dependencies title=\"Dependencies\" dependencies={formula.dependencies} isInstalled={props.isInstalled} />\n          <Dependencies\n            title=\"Build Dependencies\"\n            dependencies={formula.build_dependencies}\n            isInstalled={props.isInstalled}\n          />\n          <Dependencies title=\"Conflicts With\" dependencies={formula.conflicts_with} isInstalled={props.isInstalled} />\n          {formula.pinned && <Detail.Metadata.Label title=\"Pinned\" text=\"Yes\" />}\n          {formula.keg_only && <Detail.Metadata.Label title=\"Keg Only\" text=\"Yes\" />}\n        </Detail.Metadata>\n      }\n      actions={\n        <FormulaActionPanel\n          formula={formula}\n          showDetails={false}\n          isInstalled={props.isInstalled}\n          onAction={(result) => {\n            pop();\n            props.onAction(result);\n          }}\n        />\n      }\n    />\n  );\n}\n\n/// Private\n\nfunction formatInfo(formula: Formula): string {\n  return `\n# ${formula.name}\n${formula.desc}\n\n${formatCaveats(formula)}\n  `;\n}\n\nfunction formatVersions(formula: Formula): string {\n  const versions = formula.versions;\n  const status = [];\n  if (versions.bottle) {\n    status.push(\"bottled\");\n  }\n  if (brewIsInstalled(formula)) {\n    status.push(\"installed\");\n  }\n  if (formula.installed.first()?.installed_as_dependency) {\n    status.push(\"dependency\");\n  }\n  return `${versions.stable} ${status ? `(${status.join(\", \")})` : \"\"}`;\n}\n\nfunction formatCaveats(formula: Formula): string {\n  let caveats = \"\";\n\n  if (formula.keg_only) {\n    caveats += `\n${formula.name} is keg-only, which means it is not symlinked into ${brewPrefix}.\n    `;\n  }\n\n  if (formula.caveats) {\n    caveats += `\n${formula.caveats}\n    `;\n  }\n\n  if (caveats) {\n    return `#### Caveats\n${caveats}\n    `;\n  } else {\n    return \"\";\n  }\n}\n", "/**\n * Dependencies component for displaying package dependencies.\n *\n * Shows a list of dependencies with installation status indicators.\n */\n\nimport { Detail, Color } from \"@raycast/api\";\n\ninterface DependenciesProps {\n  title: string;\n  dependencies?: string[];\n  isInstalled: (name: string) => boolean;\n}\n\n/**\n * Display a list of dependencies with installation status.\n */\nexport function Dependencies({ title, dependencies, isInstalled }: DependenciesProps) {\n  if (!dependencies || dependencies.length === 0) {\n    return null;\n  }\n\n  return (\n    <Detail.Metadata.TagList title={title}>\n      {dependencies.map((dep) => (\n        <Detail.Metadata.TagList.Item\n          key={dep}\n          text={dep}\n          color={isInstalled(dep) ? Color.Green : Color.SecondaryText}\n        />\n      ))}\n    </Detail.Metadata.TagList>\n  );\n}\n", "import React, { useEffect, useState } from \"react\";\nimport { Detail, showToast, Toast, useNavigation } from \"@raycast/api\";\nimport { CaskActionPanel } from \"./actionPanels\";\nimport { Cask, brewName, brewFetchCaskInfo, uiLogger, ensureError } from \"../utils\";\nimport { Dependencies } from \"./dependencies\";\n\n/**\n * Check if a cask has minimal data (from fast list) vs full data.\n */\nfunction hasMinimalData(cask: Cask): boolean {\n  // Minimal casks have missing or empty homepage, tap, or desc\n  return !cask.homepage || !cask.tap || !cask.desc;\n}\n\nexport function CaskInfo({\n  cask: initialCask,\n  isInstalled,\n  onAction,\n}: {\n  cask: Cask;\n  isInstalled: (name: string) => boolean;\n  onAction: (result: boolean) => void;\n}) {\n  const { pop } = useNavigation();\n  const [cask, setCask] = useState<Cask>(initialCask);\n  const [isLoading, setIsLoading] = useState(false);\n\n  // Log when viewing cask info\n  useEffect(() => {\n    uiLogger.log(\"Viewing cask info\", {\n      token: initialCask.token,\n      name: brewName(initialCask),\n      hasMinimalData: hasMinimalData(initialCask),\n      installed: initialCask.installed,\n      version: initialCask.version,\n    });\n  }, [initialCask]);\n\n  // Lazy load full cask data if we only have minimal data\n  useEffect(() => {\n    if (!hasMinimalData(initialCask)) {\n      return;\n    }\n\n    const loadFullData = async () => {\n      setIsLoading(true);\n      const toast = await showToast({\n        style: Toast.Style.Animated,\n        title: `Loading ${brewName(initialCask)} info...`,\n      });\n\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout\n\n      try {\n        const fullCask = await brewFetchCaskInfo(initialCask.token, controller.signal);\n        clearTimeout(timeoutId);\n\n        if (fullCask) {\n          // Preserve installed version from initial cask\n          if (initialCask.installed) {\n            fullCask.installed = initialCask.installed;\n          }\n          setCask(fullCask);\n          uiLogger.log(\"Cask info loaded\", {\n            token: fullCask.token,\n            name: brewName(fullCask),\n            desc: fullCask.desc?.substring(0, 50),\n          });\n          toast.hide();\n        } else {\n          toast.style = Toast.Style.Failure;\n          toast.title = \"Failed to load cask info\";\n        }\n      } catch (err) {\n        clearTimeout(timeoutId);\n        const isTimeout = ensureError(err).name === \"AbortError\";\n        uiLogger.error(\"Failed to load cask info\", {\n          token: initialCask.token,\n          error: err,\n          timeout: isTimeout,\n        });\n        toast.style = Toast.Style.Failure;\n        toast.title = isTimeout ? \"Cask info load timed out\" : \"Failed to load cask info\";\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    loadFullData();\n  }, [initialCask]);\n\n  return (\n    <Detail\n      isLoading={isLoading}\n      markdown={formatInfo(cask)}\n      navigationTitle={`Cask Info: ${brewName(cask)}`}\n      metadata={\n        <Detail.Metadata>\n          {cask.homepage ? (\n            <Detail.Metadata.Link title=\"Homepage\" text={cask.homepage} target={cask.homepage} />\n          ) : (\n            <Detail.Metadata.Label title=\"Homepage\" text=\"Loading...\" />\n          )}\n          <Detail.Metadata.Label title=\"Tap\" text={cask.tap || \"Loading...\"} />\n          <CaskVersion cask={cask} />\n          <CaskDependencies cask={cask} />\n          <Dependencies title=\"Conflicts With\" dependencies={cask.conflicts_with?.cask} isInstalled={isInstalled} />\n          <Detail.Metadata.Label title=\"Auto Updates\" text={cask.auto_updates ? \"Yes\" : \"No\"} />\n        </Detail.Metadata>\n      }\n      actions={\n        <CaskActionPanel\n          cask={cask}\n          showDetails={false}\n          isInstalled={isInstalled}\n          onAction={(result) => {\n            pop();\n            onAction(result);\n          }}\n        />\n      }\n    />\n  );\n}\n\n/// Private\n\nfunction CaskDependencies({ cask }: { cask: Cask }) {\n  const macos = cask.depends_on?.macos;\n\n  if (!macos) {\n    return null;\n  }\n\n  return (\n    <Detail.Metadata.TagList title=\"macOS Version\">\n      {Object.keys(macos).map((key) => {\n        const values = macos[key];\n        if (values) {\n          return <Detail.Metadata.TagList.Item key={key} text={`${key} ${values.join(\", \")}`} />;\n        }\n        return null;\n      })}\n    </Detail.Metadata.TagList>\n  );\n}\n\nfunction CaskVersion({ cask }: { cask: Cask }) {\n  const version = cask.installed ? `${cask.installed} (installed)` : cask.version;\n  return version ? <Detail.Metadata.Label title=\"Version\" text={version} /> : null;\n}\n\nfunction formatInfo(cask: Cask): string {\n  return `\n# ${brewName(cask)}\n${cask.desc}\n\n${formatCaveats(cask)}\n  `;\n}\n\nfunction formatCaveats(cask: Cask): string {\n  if (cask.caveats) {\n    return `#### Caveats\n${cask.caveats}\n    `;\n  }\n  return \"\";\n}\n", "import { Action, Icon, Keyboard, showToast, Toast } from \"@raycast/api\";\nimport {\n  brewName,\n  brewInstallWithProgress,\n  brewUninstall,\n  brewPinFormula,\n  brewUnpinFormula,\n  brewUpgradeSingleWithProgress,\n  brewUpgradeAll,\n  preferences,\n  showActionToast,\n  showBrewFailureToast,\n  ensureError,\n  Cask,\n  Formula,\n  OutdatedFormula,\n  Nameable,\n  BrewProgress,\n} from \"../utils\";\n\nexport function FormulaInstallAction(props: { formula: Cask | Formula; onAction: (result: boolean) => void }) {\n  // TD: Support installing other versions?\n  return (\n    <Action\n      title={\"Install\"}\n      icon={Icon.Plus}\n      shortcut={{ modifiers: [\"cmd\"], key: \"i\" }}\n      onAction={async () => {\n        props.onAction(await install(props.formula));\n      }}\n    />\n  );\n}\n\nexport function FormulaUninstallAction(props: { formula: Cask | Nameable; onAction: (result: boolean) => void }) {\n  return (\n    <Action\n      title=\"Uninstall\"\n      icon={Icon.Trash}\n      shortcut={Keyboard.Shortcut.Common.Remove}\n      style={Action.Style.Destructive}\n      onAction={async () => {\n        const result = await uninstall(props.formula);\n        props.onAction(result);\n      }}\n    />\n  );\n}\n\nexport function FormulaUpgradeAction(props: { formula: Cask | Nameable; onAction: (result: boolean) => void }) {\n  return (\n    <Action\n      title=\"Upgrade\"\n      icon={Icon.Hammer}\n      shortcut={{ modifiers: [\"cmd\", \"shift\"], key: \"u\" }}\n      onAction={async () => {\n        const result = await upgrade(props.formula);\n        props.onAction(result);\n      }}\n    />\n  );\n}\n\nexport function FormulaUpgradeAllAction(props: { onAction: (result: boolean) => void }) {\n  return (\n    <Action\n      title=\"Upgrade All\"\n      icon={Icon.Hammer}\n      onAction={async () => {\n        const result = await upgradeAll();\n        props.onAction(result);\n      }}\n    />\n  );\n}\n\nexport function FormulaPinAction(props: { formula: Formula | OutdatedFormula; onAction: (result: boolean) => void }) {\n  const isPinned = props.formula.pinned;\n  return (\n    <Action\n      title={isPinned ? \"Unpin\" : \"Pin\"}\n      icon={Icon.Pin}\n      shortcut={Keyboard.Shortcut.Common.Pin}\n      onAction={async () => {\n        if (isPinned) {\n          props.onAction(await unpin(props.formula));\n        } else {\n          props.onAction(await pin(props.formula));\n        }\n      }}\n    />\n  );\n}\n\n/// Utilties\n\nasync function install(formula: Cask | Formula): Promise<boolean> {\n  const name = brewName(formula);\n  const handle = showActionToast({ title: `Installing ${name}`, message: \"\", cancelable: true });\n  try {\n    // Use progress-enabled install to show download progress\n    await brewInstallWithProgress(\n      formula,\n      (progress: BrewProgress) => {\n        handle.updateMessage(progress.message);\n      },\n      handle.abort?.signal,\n    );\n    // Use HUD for success - persists even if Raycast is closed\n    await handle.showSuccessHUD(`Installed ${name}`);\n    return true;\n  } catch (err) {\n    const error = ensureError(err);\n    // Show HUD for failure if user might have closed Raycast\n    await handle.showFailureHUD(`Failed to install ${name}`);\n    // Also show detailed toast if Raycast is still open\n    showBrewFailureToast(\"Install failed\", error);\n    return false;\n  }\n}\n\nasync function uninstall(formula: Cask | Nameable): Promise<boolean> {\n  const name = brewName(formula);\n  const handle = showActionToast({ title: `Uninstalling ${name}`, message: \"\", cancelable: true });\n  try {\n    await brewUninstall(formula, handle.abort?.signal);\n    await handle.showSuccessHUD(`Uninstalled ${name}`);\n    return true;\n  } catch (err) {\n    const error = ensureError(err);\n    await handle.showFailureHUD(`Failed to uninstall ${name}`);\n    showBrewFailureToast(\"Uninstall failed\", error);\n    return false;\n  }\n}\n\nasync function upgrade(formula: Cask | Nameable): Promise<boolean> {\n  const name = brewName(formula);\n  const handle = showActionToast({ title: `Upgrading ${name}`, message: \"\", cancelable: true });\n  try {\n    // Use progress-enabled upgrade to show download progress\n    await brewUpgradeSingleWithProgress(\n      formula,\n      (progress: BrewProgress) => {\n        handle.updateMessage(progress.message);\n      },\n      handle.abort?.signal,\n    );\n    await handle.showSuccessHUD(`Upgraded ${name}`);\n    return true;\n  } catch (err) {\n    const error = ensureError(err);\n    await handle.showFailureHUD(`Failed to upgrade ${name}`);\n    showBrewFailureToast(\"Upgrade failed\", error);\n    return false;\n  }\n}\n\nasync function upgradeAll(): Promise<boolean> {\n  const handle = showActionToast({\n    title: \"Upgrading all packages\",\n    message: \"This may take a while...\",\n    cancelable: true,\n  });\n  try {\n    await brewUpgradeAll(preferences.greedyUpgrades, handle.abort?.signal);\n    await handle.showSuccessHUD(\"All packages upgraded\");\n    return true;\n  } catch (err) {\n    const error = ensureError(err);\n    await handle.showFailureHUD(\"Failed to upgrade packages\");\n    showBrewFailureToast(\"Upgrade failed\", error);\n    return false;\n  }\n}\n\nasync function pin(formula: Formula | OutdatedFormula): Promise<boolean> {\n  showToast(Toast.Style.Animated, `Pinning ${brewName(formula)}`);\n  try {\n    await brewPinFormula(formula);\n    formula.pinned = true;\n    showToast(Toast.Style.Success, `Pinned ${brewName(formula)}`);\n    return true;\n  } catch (err) {\n    showBrewFailureToast(\"Pin formula failed\", ensureError(err));\n    return false;\n  }\n}\n\nasync function unpin(formula: Formula | OutdatedFormula): Promise<boolean> {\n  showToast(Toast.Style.Animated, `Unpinning ${brewName(formula)}`);\n  try {\n    await brewUnpinFormula(formula);\n    formula.pinned = false;\n    showToast(Toast.Style.Success, `Unpinned ${brewName(formula)}`);\n    return true;\n  } catch (err) {\n    showBrewFailureToast(\"Unpin formula failed\", ensureError(err));\n    return false;\n  }\n}\n", "import { closeMainWindow, getApplications, Image } from \"@raycast/api\";\nimport { runAppleScript, useCachedPromise } from \"@raycast/utils\";\nimport { preferences } from \"../utils\";\n\ntype TerminalApp = (typeof preferences)[\"terminalApp\"];\n\nconst names: { [key in TerminalApp]: string } = {\n  alacritty: \"Alacritty\",\n  ghostty: \"Ghostty\",\n  hyper: \"Hyper\",\n  iterm: \"iTerm\",\n  kitty: \"kitty\",\n  terminal: \"Terminal\",\n  warp: \"Warp\",\n  wezterm: \"WezTerm\",\n};\n\nconst icons: { [key in TerminalApp]: Image.ImageLike } = {\n  alacritty: { fileIcon: \"/Applications/Alacritty.app\" },\n  ghostty: { fileIcon: \"/Applications/Ghostty.app\" },\n  hyper: { fileIcon: \"/Applications/Hyper.app\" },\n  iterm: { fileIcon: \"/Applications/iTerm.app\" },\n  kitty: { fileIcon: \"/Applications/kitty.app\" },\n  terminal: { fileIcon: \"/System/Applications/Utilities/Terminal.app\" },\n  warp: { fileIcon: \"/Applications/Warp.app\" },\n  wezterm: { fileIcon: \"/Applications/WezTerm.app\" },\n};\n\nconst appBundleIds: { [key in TerminalApp]: string } = {\n  alacritty: \"org.alacritty\",\n  ghostty: \"com.mitchellh.ghostty\",\n  hyper: \"co.zeit.hyper\",\n  iterm: \"com.googlecode.iterm2\",\n  kitty: \"org.kovidgoyal.kitty\",\n  terminal: \"com.apple.terminal\",\n  warp: \"dev.warp.Warp-Stable\",\n  wezterm: \"com.github.wez.wezterm\",\n};\n\nconst runCommandInTermAppleScript = (c: string, terminalApp: string): string => `\n    tell application \"${terminalApp}\" to activate\n    tell application \"System Events\" to tell process \"${terminalApp}\"\n        keystroke \"t\" using command down\n        delay 0.5\n        keystroke \"${c}\"\n        keystroke return\n    end tell\n  `;\n\nconst appleScripts: { [key in TerminalApp]: (c: string) => string } = {\n  alacritty: (c: string) => runCommandInTermAppleScript(c, names.alacritty),\n  ghostty: (c: string) => runCommandInTermAppleScript(c, names.ghostty),\n  hyper: (c: string) => runCommandInTermAppleScript(c, names.hyper),\n  iterm: (c: string) => `\n    tell application \"iTerm\"\n      set newWindow to create window with default profile command \"bash -c '${c}; read -n 1 -s -r -p \\\\\"Press any key to exit - will not quit\\\\\" ; echo' ; exit\"\n    end tell\n    `,\n  kitty: (c: string) => runCommandInTermAppleScript(c, names.kitty),\n  terminal: (c: string) => `\n    tell application \"Terminal\"\n      do shell script \"open -a 'Terminal'\"\n      do script \"echo ; ${c} ; bash -c 'read -n 1 -s -r -p \\\\\"Press any key to exit - will not quit\\\\\"' ; exit\" in selected tab of the front window\n    end tell\n  `,\n  warp: (c: string) => runCommandInTermAppleScript(c, names.warp),\n  wezterm: (c: string) => runCommandInTermAppleScript(c, names.wezterm),\n};\n\nexport const useTerminalApp = () => {\n  const { data } = useCachedPromise(\n    async (terminalApp: TerminalApp) => {\n      const apps = await getApplications();\n      return apps.some((app) => app.bundleId?.toLowerCase() === appBundleIds[terminalApp].toLowerCase());\n    },\n    [preferences.terminalApp],\n    { failureToastOptions: { title: \"Failed to check if Terminal App is installed\" } },\n  );\n\n  return {\n    terminalIcon: data ? icons[preferences.terminalApp] : icons.terminal,\n    terminalName: data ? names[preferences.terminalApp] : names.terminal,\n    runCommandInTerminal: async (command: string) => {\n      await closeMainWindow(); // Close Raycast in case the brew cmd typed in raycast window\n      await new Promise((resolve) => setTimeout(resolve, 400)); // Wait for Raycast to close\n      const cmd = data ? appleScripts[preferences.terminalApp](command) : appleScripts.terminal(command);\n      await runAppleScript(cmd);\n      await closeMainWindow();\n    },\n  };\n};\n"],
  "mappings": "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",
  "names": ["exports", "redactString", "sanitizeArgs", "maskEmail", "text", "_m", "p1", "p2", "input", "s", "redactValueByKey", "key", "value", "k", "json", "prop", "val", "args", "arg", "api_1", "redaction_1", "Logger", "_Logger", "config", "error", "message", "args", "formattedMessage", "processedMessage", "processedArgs", "prefix", "childPrefix", "exports", "logger_1", "exports", "redaction_1", "require_stream_chain", "__commonJSMin", "exports", "module", "Readable", "Writable", "Duplex", "Transform", "none", "finalSymbol", "manySymbol", "final", "value", "many", "values", "isFinal", "o", "isMany", "getFinalValue", "getManyValues", "runAsyncGenerator", "gen", "stream", "data", "Chain", "wrapFunction", "fn", "chunk", "encoding", "callback", "result", "error", "wrapArray", "fns", "i", "isReadableNodeStream", "obj", "isWritableNodeStream", "isDuplexNodeStream", "_Chain", "options", "index", "s", "output", "_1", "_2", "e", "require_Utf8Stream", "__commonJSMin", "exports", "module", "Transform", "StringDecoder", "Utf8Stream", "options", "chunk", "encoding", "callback", "_", "require_Parser", "__commonJSMin", "exports", "module", "Utf8Stream", "patterns", "MAX_PATTERN_SIZE", "noSticky", "key", "src", "values", "expected", "fromHex", "s", "codes", "Parser", "_Parser", "options", "callback", "error", "match", "value", "index", "main", "t", "require_emit", "__commonJSMin", "exports", "module", "emit", "stream", "item", "require_stream_json", "__commonJSMin", "exports", "module", "Parser", "emit", "make", "options", "require_FilterBase", "__commonJSMin", "exports", "module", "Transform", "FilterBase", "_FilterBase", "string", "separator", "stack", "path", "regExp", "array", "options", "filter", "replacement", "chunk", "_", "callback", "passValue", "last", "post", "expected", "skipValue", "require_withParser", "__commonJSMin", "exports", "module", "chain", "Parser", "withParser", "fn", "options", "require_Filter", "__commonJSMin", "exports", "module", "FilterBase", "withParser", "Filter", "_Filter", "options", "callback", "chunk", "stack", "last", "stackLength", "lastLength", "commonLength", "n", "key", "require_Assembler", "__commonJSMin", "exports", "module", "EventEmitter", "startObject", "Ctr", "Assembler", "_Assembler", "stream", "options", "chunk", "path", "i", "key", "level", "index", "value", "require_StreamBase", "__commonJSMin", "exports", "module", "Transform", "Assembler", "Counter", "initialDepth", "StreamBase", "options", "chunk", "encoding", "callback", "result", "require_StreamArray", "__commonJSMin", "exports", "module", "StreamBase", "withParser", "StreamArray", "_StreamArray", "options", "chunk", "_", "callback", "discard", "require_Pick", "__commonJSMin", "exports", "module", "FilterBase", "withParser", "Pick", "_Pick", "options", "chunk", "require_StreamObject", "__commonJSMin", "exports", "module", "StreamBase", "withParser", "StreamObject", "_StreamObject", "options", "chunk", "_", "callback", "discard", "search_exports", "__export", "SearchView", "__toCommonJS", "import_react", "import_api", "has", "dequal", "foo", "bar", "ctor", "len", "$a57ed8effbd797c7$export$722debc0e56fea39", "value", "ref", "$hgUW1$useRef", "signalRef", "dequal", "$hgUW1$useMemo", "$bfcf6ee368b3bd9f$export$d4b699e2c1148419", "$c718fd03aba6111c$export$80e5033e369189f3", "error", "options", "message", "$hgUW1$showToast", "$hgUW1$Toast", "$c718fd03aba6111c$var$handleErrorToastAction", "privateExtension", "title", "extensionURL", "packageJSON", "$hgUW1$readFileSync", "$hgUW1$join", "$hgUW1$environment", "fallback", "stack", "toast", "$hgUW1$Clipboard", "$hgUW1$open", "$cefc05764ce5eacd$export$dd6b79aaabe7bc37", "fn", "args", "lastCallId", "state", "set", "$hgUW1$useState", "fnRef", "latestAbortable", "latestArgs", "latestOnError", "latestOnData", "latestOnWillExecute", "latestFailureToast", "latestValue", "latestCallback", "paginationArgsRef", "usePaginationRef", "hasMoreRef", "pageSizeRef", "abort", "$hgUW1$useCallback", "callback", "callId", "prevState", "promiseOrPaginatedPromise", "$cefc05764ce5eacd$var$bindPromiseIfNeeded", "handleError", "$hgUW1$LaunchType", "data", "hasMore", "cursor", "previousData", "revalidate", "mutate", "asyncUpdate", "dataBeforeOptimisticUpdate", "update", "err", "onLoadMore", "$hgUW1$useEffect", "isLoading", "stateWithLoadingFixed", "pagination", "$93381684554307cb$var$isNativeFunction", "f", "$93381684554307cb$var$hashReplacer", "$93381684554307cb$export$fe386877a696ae78", "writeTo", "context", "write", "str", "object", "pattern", "objString", "objType", "objectNumber", "keys", "self", "key", "arr", "unordered", "entry", "contextAdditions", "entries", "strm", "$93381684554307cb$var$PassThrough", "localContext", "date", "sym", "bool", "string", "number", "xml", "regex", "url", "map", "file", "b", "$e2e1ea6dd3b7d2e1$export$b644b65666fe0c18", "_value", "$e2e1ea6dd3b7d2e1$export$63698c10df99509c", "_key", "$e2e1ea6dd3b7d2e1$export$d6af199866bfb566", "hashingStream", "$hgUW1$nodecrypto", "$c40d7eded38ca69c$var$rootCache", "$c40d7eded38ca69c$var$cacheMap", "$c40d7eded38ca69c$export$14afb9e4c16377d3", "initialState", "config", "cacheKey", "cache", "$hgUW1$Cache", "keyRef", "initialValueRef", "cachedState", "$hgUW1$useSyncExternalStore", "stateRef", "setStateAndCache", "updater", "newValue", "stringifiedValue", "$a7f3824c7be647eb$var$emptyCache", "$a7f3824c7be647eb$export$b15740c74e256244", "initialData", "keepPreviousData", "internal_cacheKeySuffix", "usePromiseOptions", "lastUpdateFrom", "cachedData", "mutateCache", "laggyDataRef", "_mutate", "returnedData", "latestData", "$e6272883088c6834$var$processOk", "process1", "$e6272883088c6834$var$kExitEmitter", "$e6272883088c6834$var$Emitter", "$parcel$global", "ev", "fn", "list", "i", "code", "signal", "ret", "$e6272883088c6834$var$SignalExitFallback", "$e6272883088c6834$var$SignalExit", "#hupSig", "#emitter", "#process", "#originalProcessEmit", "#originalProcessReallyExit", "#sigListeners", "#loaded", "#signals", "sig", "listeners", "count", "p", "s", "cb", "opts", "a", "#processEmit", "#processReallyExit", "listener", "args", "og", "$e6272883088c6834$var$signalExit", "$e6272883088c6834$export$47a57ed64c292d4f", "$c86e3701e284ece4$export$6e3a9b5342d42997", "spawned", "timeout", "spawnedPromise", "resolve", "reject", "exitCode", "error", "removeExitHandler", "timeoutId", "timeoutPromise", "_resolve", "safeSpawnedPromise", "$c86e3701e284ece4$var$MaxBufferError", "$c86e3701e284ece4$var$bufferStream", "options", "encoding", "isBuffer", "stream", "$hgUW1$nodestream", "length", "chunks", "chunk", "$c86e3701e284ece4$var$getStream", "inputStream", "rejectPromise", "$hgUW1$constants", "$hgUW1$promisify", "$c86e3701e284ece4$var$getBufferedData", "streamPromise", "$c86e3701e284ece4$export$67b768ac9e1c70fa", "stdout", "stderr", "processDone", "stdoutPromise", "stderrPromise", "$c86e3701e284ece4$var$stripFinalNewline", "input", "LF", "CR", "$c86e3701e284ece4$export$200978bbc0b73ca", "value", "$c86e3701e284ece4$var$getErrorPrefix", "timedOut", "$c86e3701e284ece4$var$makeError", "command", "parentError", "execaMessage", "shortMessage", "message", "$c86e3701e284ece4$export$a8f5efe603803b77", "$a5607a6abce196a8$var$polarToCartesian", "centerX", "centerY", "radius", "angleInDegrees", "angleInRadians", "$a5607a6abce196a8$var$describeArc", "x", "y", "startAngle", "endAngle", "start", "end", "largeArcFlag", "$a5607a6abce196a8$export$e7138cfc4fbdc77c", "progress", "color", "$hgUW1$Color", "options", "background", "$hgUW1$environment", "backgroundOpacity", "stroke", "svg", "$179449bbef1d262b$export$8982d27dc997624f", "script", "optionsOrArgs", "options", "humanReadableOutput", "language", "timeout", "execOptions", "outputArguments", "spawned", "$hgUW1$nodechild_process", "spawnedPromise", "$c86e3701e284ece4$export$6e3a9b5342d42997", "error", "exitCode", "signal", "timedOut", "stdoutResult", "stderrResult", "$c86e3701e284ece4$export$67b768ac9e1c70fa", "stdout", "$c86e3701e284ece4$export$200978bbc0b73ca", "stderr", "$c86e3701e284ece4$export$a8f5efe603803b77", "import_react", "import_api", "import_api", "preferences", "import_raycast_logger", "logger", "brewLogger", "cacheLogger", "actionsLogger", "fetchLogger", "searchLogger", "uiLogger", "BrewError", "message", "options", "NetworkError", "ParseError", "BrewCommandError", "BrewNotFoundError", "BrewLockError", "BrewError", "message", "options", "DownloadTimeoutError", "StaleProcessError", "PackageNotFoundError", "PackageDisabledError", "PackageConflictError", "UnsupportedMacOSError", "isNetworkError", "error", "NetworkError", "isBrewLockError", "BrewLockError", "isDownloadTimeoutError", "DownloadTimeoutError", "isStaleProcessError", "StaleProcessError", "isRecoverableError", "error", "isNetworkError", "isBrewLockError", "isDownloadTimeoutError", "isStaleProcessError", "BREW_LOCK_PATTERNS", "DISABLED_PACKAGE_PATTERN", "isBrewLockMessage", "message", "BREW_LOCK_PATTERNS", "pattern", "parseDisabledPackageMessage", "message", "match", "DISABLED_PACKAGE_PATTERN", "ensureError", "err", "getErrorMessage", "error", "BrewLockError", "DownloadTimeoutError", "pkg", "phase", "StaleProcessError", "PackageDisabledError", "type", "message", "PackageConflictError", "conflicts", "UnsupportedMacOSError", "NetworkError", "BrewNotFoundError", "PackageNotFoundError", "BrewCommandError", "disabledInfo", "parseDisabledPackageMessage", "BrewError", "execError", "import_api", "import_path", "import_fs", "import_promises", "import_stream", "import_stream_chain", "import_stream_json", "import_Filter", "import_StreamArray", "import_node_timers", "wait", "ms", "resolve", "supportPath", "fs", "cacheLogger", "bundleIdentifier", "path", "comp", "cachePath", "name", "valid_keys", "MAX_FETCH_RETRIES", "RETRY_DELAY_MS", "fetchRemote", "remote", "onProgress", "_fetchRemoteWithRetry", "value", "lastError", "attempt", "_fetchRemote", "error", "isRecoverableError", "fetchLogger", "wait", "fetchStartTime", "fetchURL", "downloadStartTime", "response", "NetworkError", "contentLength", "totalBytes", "bytesDownloaded", "writeStream", "fs", "lastProgressUpdate", "PROGRESS_THROTTLE_MS", "progressStream", "chunk", "controller", "now", "percent", "progressBody", "streamPipeline", "streamError", "errorMessage", "downloadDurationMs", "logData", "contentLengthKb", "preferences", "cacheLogger", "isNetworkError", "updateCache", "cacheInfo", "lastModified", "readCache", "parseStartTime", "keysRe", "resolve", "reject", "reportProgress", "complete", "pipeline", "data", "parseDurationMs", "totalDurationMs", "err", "ParseError", "import_api", "showActionToast", "actionOptions", "options", "controller", "toast", "message", "title", "preferences", "showBrewFailureToast", "error", "uiLogger", "execError", "errorMessage", "getErrorMessage", "isLockError", "isBrewLockError", "isRecoverableError", "toastTitle", "toastOptions", "logContent", "retryAction", "retryError", "import_raycast_logger", "memoryLogger", "MEMORY_THRESHOLDS", "formatBytes", "bytes", "parseStackLine", "line", "withFunctionMatch", "anonymousMatch", "getCallerInfo", "skipFrames", "stack", "callerLine", "getStackTrace", "maxFrames", "takeMemorySnapshot", "label", "includeStack", "mem", "heapPercent", "snapshot", "calculateDelta", "before", "after", "getWarningIndicator", "formatSnapshot", "warning", "result", "functionName", "fileName", "lineNumber", "shortFileName", "logMemory", "logMemoryWarning", "withMemoryTracking", "operationName", "operation", "options", "logAlways", "startTime", "error", "errorSnapshot", "durationMs", "delta", "deltaHeapMB", "isLargeDelta", "import_child_process", "import_path", "import_os", "brewPrefix", "preferences", "path_join", "brewPath", "suffix", "brewExecutable", "import_child_process", "import_util", "import_fs", "fs", "import_path", "import_api", "execp", "homebrewEnvLogged", "execBrew", "cmd", "options", "env", "execBrewEnv", "brewExecutable", "err", "execErr", "errorOutput", "isBrewLockMessage", "brewLogger", "BrewLockError", "preferences", "askpassPath", "path_join", "fs_constants", "bundleIdentifier", "downloadConcurrencyDisabled", "useInternalApi", "import_child_process", "DEFAULT_STALE_TIMEOUT_MS", "DOWNLOAD_PHASE_TIMEOUT_MS", "parseBrewOutput", "line", "trimmedLine", "cleanMessage", "percentMatch", "execBrewWithProgress", "cmd", "onProgress", "cancel", "options", "env", "execBrewEnv", "args", "staleTimeoutMs", "DEFAULT_STALE_TIMEOUT_MS", "packageName", "verboseLogging", "brewLogger", "resolve", "reject", "proc", "brewExecutable", "stdout", "stderr", "lastProgressTime", "currentPhase", "staleCheckInterval", "isRejected", "cleanup", "rejectOnce", "error", "staleDuration", "effectiveTimeout", "DOWNLOAD_PHASE_TIMEOUT_MS", "StaleProcessError", "processOutput", "text", "source", "lines", "line", "progress", "parseBrewOutput", "data", "isBrewLockMessage", "BrewLockError", "code", "BrewCommandError", "err", "fs", "import_child_process", "import_os", "import_child_process", "fs", "import_stream_chain", "import_stream_json", "import_Pick", "import_StreamObject", "MACOS_VERSION_NAMES", "MACOS_FUTURE_VERSIONS", "cachedSystemTag", "cachedMacOSVersion", "getSystemTag", "arch", "getArchitecture", "osVersion", "getMacOSVersionName", "fetchLogger", "cpuList", "firstCpu", "error", "getMacOSVersion", "envVersion", "parsed", "swVersOutput", "majorVersion", "darwinVersion", "darwinMajor", "version", "versionName", "name", "futureVersion", "INTERNAL_API_BASE", "getInternalFormulaUrl", "tag", "getInternalCaskUrl", "downloadAndCacheInternalFormulae", "cachePath", "onProgress", "url", "startTime", "tempJwsPath", "withMemoryTracking", "response", "contentLength", "totalBytes", "bytesDownloaded", "lastProgressUpdate", "PROGRESS_THROTTLE_MS", "downloadStream", "reader", "done", "value", "now", "percent", "resolve", "reject", "err", "logMemory", "tempPayloadPath", "extractJwsPayloadToFile", "itemsProcessed", "writeStream", "pipeline", "isFirst", "data", "formula", "createFormulaFromInternal", "duration", "jwsFilePath", "outputPath", "readStream", "state", "searchBuffer", "unicodeBuffer", "escapeNext", "outputChunks", "outputSize", "FLUSH_THRESHOLD", "flushOutput", "appendOutput", "str", "payloadMarker", "chunkData", "chunk", "runStart", "i", "char", "codePoint", "dependencies", "logInternalApiConfig", "formulaUrl", "caskUrl", "cacheLogger", "installedCachePath", "cachePath", "formulaCachePath", "caskCachePath", "formulaURL", "caskURL", "formulaRemote", "caskRemote", "hasSearchCache", "formulaStats", "caskStats", "brewFetchInstalled", "useCache", "cancel", "startTime", "results", "brewFetchInstallableResults", "mapped", "brewMapInstalled", "duration", "brewLogger", "installed", "execBrew", "updateCache", "info", "parsed", "installedCachePath", "responseSizeBytes", "responseSizeKb", "cacheLogger", "preferences", "err", "mtimeMs", "path", "readCache", "cacheTime", "locksTime", "brewPath", "caskroomTime", "pinnedTime", "homebrewTime", "cacheBuffer", "cached", "formulae", "formula", "casks", "cask", "hasLoggedInternalApiConfig", "formulaeCacheUpdateInProgress", "needsInternalApiCacheUpdate", "internalApiUrl", "localCachePath", "stats", "response", "lastModified", "cacheLogger", "brewFetchFormulae", "onProgress", "preferences", "logInternalApiConfig", "getSystemTagForCache", "formulaCachePath", "brewLogger", "downloadAndCacheInternalFormulae", "fetchRemote", "formulaRemote", "error", "brewFetchCasks", "caskRemote", "arch", "osVersion", "swVersOutput", "majorVersion", "brewFetchFormulaInfo", "name", "cancel", "startTime", "output", "execBrew", "results", "duration", "err", "brewFetchCaskInfo", "token", "import_path", "isCask", "maybeCask", "brewIdentifier", "item", "brewName", "brewCaskOption", "zappable", "preferences", "brewIsInstalled", "installable", "caskIsInstalled", "formulaIsInstalled", "cask", "formula", "brewInstallPath", "caskInstallPath", "formulaInstallPath", "basePath", "brewPath", "path_join", "firstInstalled", "brewFormatVersion", "caskFormatVersion", "formulaFormatVersion", "version", "installed_version", "status", "brewCompare", "lhs", "rhs", "target", "lhs_matches", "rhs_matches", "brewInstallCommand", "identifier", "brewExecutable", "brewUninstallCommand", "searchQuery", "brewSearch", "searchText", "limit", "signal", "onProgress", "searchLogger", "casksProgress", "formulaeProgress", "casks", "brewFetchCasks", "progress", "error", "formulae", "brewFetchFormulae", "target", "formula", "lhs", "rhs", "brewCompare", "cask", "name", "formulaeLen", "casksLen", "brewInstallWithProgress", "installable", "onProgress", "cancel", "identifier", "brewIdentifier", "isCaskType", "isCask", "actionsLogger", "execBrewWithProgress", "brewCaskOption", "brewUninstall", "preferences", "execBrew", "brewUpgradeSingleWithProgress", "upgradable", "onProgress", "cancel", "identifier", "brewIdentifier", "actionsLogger", "isCask", "execBrewWithProgress", "brewCaskOption", "brewPinFormula", "formula", "actionsLogger", "execBrew", "brewUnpinFormula", "useBrewInstalled", "loadingToastRef", "result", "$a7f3824c7be647eb$export$b15740c74e256244", "brewFetchInstalled", "error", "brewLogger", "isBrewLockError", "isLock", "message", "getErrorMessage", "toast", "import_react", "import_api", "defaultFileProgress", "useBrewSearch", "options", "searchText", "limit", "installed", "hasEverLoadedRef", "cacheExists", "setCacheExists", "abortController", "hasSearchCache", "exists", "searchLogger", "error", "downloadProgress", "setDownloadProgress", "lastProgressUpdateRef", "PROGRESS_THROTTLE_MS", "abortable", "isLoadingFromHook", "rawData", "mutate", "$a7f3824c7be647eb$export$b15740c74e256244", "query", "brewSearch", "progress", "now", "isComplete", "isCasksComplete", "isFormulaeComplete", "isBrewLockError", "isLock", "message", "getErrorMessage", "data", "formulae", "f", "casks", "c", "results", "applyInstalledStatus", "isInitialLoad", "isLoading", "toFileProgress", "dp", "loadingState", "casksProgress", "formulaeProgress", "hasCacheFiles", "indexTotals", "casksTotal", "formulaeTotal", "formulaeLen", "casksLen", "formula", "info", "isFormula", "cask", "isCask", "installable", "isInstalled", "name", "import_api", "import_jsx_runtime", "InstallableFilterDropdown", "props", "value", "placeholder", "filter", "import_api", "import_api", "import_react", "import_api", "import_api", "import_jsx_runtime", "Dependencies", "title", "dependencies", "isInstalled", "dep", "import_jsx_runtime", "hasMinimalData", "formula", "FormulaInfo", "props", "pop", "setFormula", "isLoading", "setIsLoading", "uiLogger", "toast", "controller", "timeoutId", "fullFormula", "brewFetchFormulaInfo", "err", "isTimeout", "ensureError", "formatInfo", "formatVersions", "Dependencies", "FormulaActionPanel", "result", "formatCaveats", "versions", "status", "brewIsInstalled", "caveats", "brewPrefix", "import_react", "import_api", "import_jsx_runtime", "hasMinimalData", "cask", "CaskInfo", "initialCask", "isInstalled", "onAction", "pop", "setCask", "isLoading", "setIsLoading", "uiLogger", "brewName", "toast", "controller", "timeoutId", "fullCask", "brewFetchCaskInfo", "err", "isTimeout", "ensureError", "formatInfo", "CaskVersion", "CaskDependencies", "Dependencies", "CaskActionPanel", "result", "macos", "key", "values", "version", "formatCaveats", "import_api", "import_jsx_runtime", "FormulaInstallAction", "props", "install", "FormulaUninstallAction", "result", "uninstall", "FormulaUpgradeAction", "upgrade", "FormulaPinAction", "props", "isPinned", "unpin", "pin", "install", "formula", "name", "brewName", "handle", "showActionToast", "brewInstallWithProgress", "progress", "err", "error", "ensureError", "showBrewFailureToast", "uninstall", "brewUninstall", "upgrade", "brewUpgradeSingleWithProgress", "pin", "formula", "brewName", "brewPinFormula", "err", "showBrewFailureToast", "ensureError", "unpin", "brewUnpinFormula", "import_api", "names", "icons", "appBundleIds", "runCommandInTermAppleScript", "c", "terminalApp", "appleScripts", "useTerminalApp", "data", "$a7f3824c7be647eb$export$b15740c74e256244", "app", "preferences", "command", "resolve", "cmd", "$179449bbef1d262b$export$8982d27dc997624f", "import_jsx_runtime", "DebugSection", "props", "CaskActionPanel", "cask", "terminalName", "terminalIcon", "runCommandInTerminal", "useTerminalApp", "installedActionPanel", "CaskInfo", "FormulaUpgradeAction", "brewInstallPath", "FormulaUninstallAction", "brewUninstallCommand", "uninstalledActionPanel", "FormulaInstallAction", "brewInstallCommand", "brewIsInstalled", "FormulaActionPanel", "formula", "FormulaInfo", "FormulaPinAction", "import_jsx_runtime", "tertiaryTextColor", "FormulaList", "props", "formulae", "casks", "hasResults", "$a5607a6abce196a8$export$e7138cfc4fbdc77c", "formula", "FormulaListItem", "MoreListItem", "cask", "CaskListItem", "version", "tintColor", "tooltip", "iconMark", "brewIsInstalled", "brewFormatVersion", "icon", "FormulaActionPanel", "brewName", "CaskActionPanel", "import_jsx_runtime", "formatBytes", "bytes", "k", "sizes", "i", "formatNumber", "num", "getDownloadSubtitle", "progress", "isProcessing", "downloaded", "percent", "getDownloadAccessory", "itemType", "getDownloadIcon", "$a5607a6abce196a8$export$e7138cfc4fbdc77c", "fraction", "SearchView", "searchText", "setSearchText", "filter", "setFilter", "isLoadingInstalled", "installed", "revalidateInstalled", "useBrewInstalled", "isLoadingSearch", "hasCacheFiles", "loadingState", "results", "indexTotals", "useBrewSearch", "formulae", "casks", "hasShownCompletionToast", "phase", "totalFormulae", "totalCasks", "casksProgress", "formulaeProgress", "isCasksDownloadDone", "isFormulaeDownloadDone", "isProcessingCasks", "isProcessingFormulae", "formulaeNotStarted", "statusMessage", "casksSubtitle", "formulaeSubtitle", "formulaeTitle", "formulaeAccessoryText", "formulaeIcon", "FormulaList", "placeholder", "InstallableFilterDropdown", "name", "isInstalled"]
}
