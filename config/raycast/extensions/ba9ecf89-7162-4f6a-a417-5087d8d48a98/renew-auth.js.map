{
  "version": 3,
  "sources": ["../src/renew-auth.ts", "../src/v8/utils.ts"],
  "sourcesContent": ["import { getSignInStatus, op } from \"./v8/utils\";\n\nexport default function renewAuth() {\n  try {\n    if (getSignInStatus()) {\n      return op([\"account\", \"get\"]);\n    }\n  } catch (error) {\n    if (error instanceof Error) {\n      console.log(error.message);\n    }\n  }\n}\n", "import { getPreferenceValues, Icon, showToast, Toast } from \"@raycast/api\";\nimport { useExec } from \"@raycast/utils\";\nimport { execFileSync, execSync } from \"node:child_process\";\nimport { existsSync } from \"node:fs\";\n\nimport { Category, CategoryName, Item, User, Vault } from \"./types\";\n\nexport type ActionID = string;\n\nconst preferences = getPreferenceValues<ExtensionPreferences>();\n\nexport class ExtensionError extends Error {\n  public title: string;\n  constructor(title: string, message?: string) {\n    if (!message) message = title;\n    super(message);\n    this.title = title;\n  }\n}\nexport class CommandLineMissingError extends ExtensionError {}\nexport class ConnectionError extends ExtensionError {}\nexport class NotFoundError extends ExtensionError {}\nexport class ZshMissingError extends ExtensionError {}\nexport const getCliPath = () => {\n  const cliPath = [preferences.cliPath, \"/usr/local/bin/op\", \"/opt/homebrew/bin/op\"]\n    .filter(Boolean)\n    .find((path) => (path ? existsSync(path) : false));\n\n  if (!cliPath) {\n    throw new CommandLineMissingError(\"1Password CLI is not found. Please set the path in the extension preferences.\");\n  }\n\n  return cliPath;\n};\nexport const ZSH_PATH = [preferences.zshPath, \"/bin/zsh\"].find((path) => existsSync(path));\nexport const errorRegex = new RegExp(/\\[\\w+\\]\\s+\\d{4}\\/\\d{2}\\/\\d{2}\\s+\\d{2}:\\d{2}:\\d{2}\\s+(.*)$/m);\nexport function actionsForItem(item: Item): ActionID[] {\n  // all actions in the default order\n  const defaultActions: ActionID[] = [\n    \"open-in-1password\",\n    \"open-in-browser\",\n    \"copy-username\",\n    \"copy-password\",\n    \"copy-one-time-password\",\n    \"paste-username\",\n    \"paste-password\",\n    \"paste-one-time-password\",\n    \"share-item\",\n    \"switch-account\",\n  ];\n  // prioritize primary and secondary actions, then append the rest and remove duplicates\n  const deduplicatedActions = [\n    ...new Set<ActionID>([preferences.primaryAction, preferences.secondaryAction, ...defaultActions]),\n  ];\n\n  switch (item.category) {\n    case \"LOGIN\":\n      return deduplicatedActions;\n    case \"PASSWORD\":\n      return deduplicatedActions.filter((action) => action !== \"copy-username\" && action !== \"paste-username\");\n\n    default:\n      return [\"open-in-1password\"];\n  }\n}\nexport function capitalizeWords(str: string): string {\n  return str.replace(/\\b\\w/g, (char: string) => char.toUpperCase());\n}\nexport function hrefToOpenInBrowser(item: Item): string | undefined {\n  if (item.category === \"LOGIN\") {\n    return item.urls?.find((url) => url.primary)?.href;\n  }\n\n  return undefined;\n}\nexport function op(args: string[]) {\n  const cliPath = getCliPath();\n\n  if (cliPath) {\n    const stdout = execFileSync(cliPath, args, { maxBuffer: 4096 * 1024 });\n\n    return stdout.toString();\n  }\n\n  throw Error(\"1Password CLI is not found!\");\n}\nexport const handleErrors = (stderr: string) => {\n  if (stderr.includes(\"no such host\")) {\n    throw new ConnectionError(\"No connection to 1Password.\", \"Verify Your Internet Connection.\");\n  } else if (stderr.includes(\"could not get item\") || stderr.includes(\"isn't an item\")) {\n    throw new NotFoundError(\"Item not found on 1Password.\", \"Check it on your 1Password app.\");\n  } else if (stderr.includes(\"ENOENT\") || stderr.includes(\"file\") || stderr.includes(\"enoent\")) {\n    throw new CommandLineMissingError(\"1Password CLI not found.\");\n  } else if (stderr.includes(\"does not have a field\")) {\n    throw new ExtensionError(`Item does not contain the field ${stderr.split(\"does not have a field \")[1].trim()}.`);\n  } else {\n    throw new ExtensionError(stderr);\n  }\n};\nexport const checkZsh = () => {\n  if (!ZSH_PATH) {\n    return false;\n  }\n\n  return true;\n};\nexport const signIn = (account?: string) =>\n  execSync(`${getCliPath()} signin ${account ? account : \"\"}`, { shell: ZSH_PATH });\nexport const getSignInStatus = () => {\n  try {\n    execSync(`${getCliPath()} whoami`);\n    return true;\n  } catch {\n    return false;\n  }\n};\nexport const useOp = <T = Buffer, U = undefined>(args: string[], callback?: (data: T) => T) => {\n  return useExec<T, U>(getCliPath(), [...args, \"--format=json\"], {\n    onError: async (e) => {\n      await showToast({\n        style: Toast.Style.Failure,\n        title: e.message,\n      });\n    },\n    parseOutput: ({ error, exitCode, stderr, stdout }) => {\n      if (error) handleErrors(error.message);\n      if (stderr) handleErrors(stderr);\n      if (exitCode != 0) handleErrors(stdout);\n      if (callback) return callback(JSON.parse(stdout));\n      return JSON.parse(stdout);\n    },\n  });\n};\nexport const usePasswords2 = ({\n  account,\n  execute = true,\n  flags = [],\n}: {\n  account: string;\n  execute: boolean;\n  flags?: string[];\n}) =>\n  useExec<Item[], ExtensionError>(\n    getCliPath(),\n    [\"--account\", account, \"items\", \"list\", \"--long\", \"--format=json\", ...flags],\n    {\n      execute,\n      onError: async (e) => {\n        await showToast({\n          style: Toast.Style.Failure,\n          title: e.message,\n        });\n      },\n      parseOutput: ({ error, exitCode, stderr, stdout }) => {\n        if (error) handleErrors(error.message);\n        if (stderr) handleErrors(stderr);\n        if (exitCode != 0) handleErrors(stdout);\n        const items = JSON.parse(stdout) as Item[];\n\n        return items.sort((a, b) => {\n          if (a.favorite && !b.favorite) {\n            return -1;\n          } else if (!a.favorite && b.favorite) {\n            return 1;\n          }\n\n          return a.title.localeCompare(b.title);\n        });\n      },\n    },\n  );\nexport const usePasswords = (flags: string[] = []) =>\n  useOp<Item[], ExtensionError>([\"items\", \"list\", \"--long\", ...flags], (data) =>\n    data.sort((a, b) => a.title.localeCompare(b.title)),\n  );\nexport const useVaults = () =>\n  useOp<Vault[], ExtensionError>([\"vault\", \"list\"], (data) => data.sort((a, b) => a.name.localeCompare(b.name)));\nexport const useCategories = () =>\n  useOp<Category[], ExtensionError>([\"item\", \"template\", \"list\"], (data) =>\n    data.sort((a, b) => a.name.localeCompare(b.name)),\n  );\nexport const useAccount = () => useOp<User, ExtensionError>([\"whoami\"]);\nexport const useAccounts = <T = User[], U = ExtensionError>(execute = true) =>\n  useExec<T, U>(getCliPath(), [\"account\", \"list\", \"--format=json\"], {\n    execute: execute,\n    onError: async (e) => {\n      await showToast({\n        style: Toast.Style.Failure,\n        title: e.message,\n      });\n    },\n    parseOutput: ({ error, exitCode, stderr, stdout }) => {\n      if (error) handleErrors(error.message);\n      if (stderr) handleErrors(stderr);\n      if (exitCode != 0) handleErrors(stdout);\n      return JSON.parse(stdout);\n    },\n  });\nexport function getCategoryIcon(category: CategoryName) {\n  switch (category) {\n    case \"API_CREDENTIAL\":\n      return Icon.Code;\n    case \"BANK_ACCOUNT\":\n    case \"CUSTOM\":\n      return Icon.Wallet;\n    case \"CREDIT_CARD\":\n      return Icon.CreditCard;\n    case \"CRYPTO_WALLET\":\n      return Icon.Crypto;\n    case \"DATABASE\":\n      return Icon.HardDrive;\n    case \"DOCUMENT\":\n      return Icon.Document;\n    case \"DRIVER_LICENSE\":\n      return Icon.Car;\n    case \"EMAIL_ACCOUNT\":\n      return Icon.Envelope;\n    case \"IDENTITY\":\n      return Icon.Person;\n    case \"LOGIN\":\n      return Icon.Fingerprint;\n    case \"MEDICAL_RECORD\":\n      return Icon.Heartbeat;\n    case \"MEMBERSHIP\":\n      return Icon.StarCircle;\n    case \"OUTDOOR_LICENSE\":\n      return Icon.Tree;\n    case \"PASSPORT\":\n      return Icon.Globe;\n    case \"PASSWORD\":\n      return Icon.Key;\n    case \"REWARD_PROGRAM\":\n      return Icon.Gift;\n    case \"SECURE_NOTE\":\n      return Icon.Lock;\n    case \"SERVER\":\n    case \"SSH_KEY\":\n      return Icon.Terminal;\n    case \"SOCIAL_SECURITY_NUMBER\":\n      return Icon.Shield;\n    case \"SOFTWARE_LICENSE\":\n      return Icon.CodeBlock;\n    case \"WIRELESS_ROUTER\":\n      return Icon.Wifi;\n\n    default:\n      return Icon.Key;\n  }\n}\nexport function titleCaseWord(word: string) {\n  if (!word) return word;\n  return word[0].toUpperCase() + word.slice(1).toLowerCase();\n}\n"],
  "mappings": "0jBAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,aAAAE,IAAA,eAAAC,EAAAH,GCAA,IAAAI,EAA4D,wB,uFAE5D,IAAAC,EAAuC,8BACvCC,EAA2B,mBAMrBC,KAAc,uBAA0C,EAEjDC,EAAN,cAA6B,KAAM,CACjC,MACP,YAAYC,EAAeC,EAAkB,CACtCA,IAASA,EAAUD,GACxB,MAAMC,CAAO,EACb,KAAK,MAAQD,CACf,CACF,EACaE,EAAN,cAAsCH,CAAe,CAAC,EAItD,IAAMI,EAAa,IAAM,CAC9B,IAAMC,EAAU,CAACC,EAAY,QAAS,oBAAqB,sBAAsB,EAC9E,OAAO,OAAO,EACd,KAAMC,GAAUA,KAAO,cAAWA,CAAI,EAAI,EAAM,EAEnD,GAAI,CAACF,EACH,MAAM,IAAIG,EAAwB,+EAA+E,EAGnH,OAAOH,CACT,EACaI,EAAW,CAACH,EAAY,QAAS,UAAU,EAAE,KAAMC,MAAS,cAAWA,CAAI,CAAC,EAC5EG,EAAa,IAAI,OAAO,4DAA4D,EAwC1F,SAASC,EAAGC,EAAgB,CACjC,IAAMC,EAAUC,EAAW,EAE3B,GAAID,EAGF,SAFe,gBAAaA,EAASD,EAAM,CAAE,UAAW,OAAY,CAAC,EAEvD,SAAS,EAGzB,MAAM,MAAM,6BAA6B,CAC3C,CAuBO,IAAMG,EAAkB,IAAM,CACnC,GAAI,CACF,qBAAS,GAAGC,EAAW,CAAC,SAAS,EAC1B,EACT,MAAQ,CACN,MAAO,EACT,CACF,EDjHe,SAARC,GAA6B,CAClC,GAAI,CACF,GAAIC,EAAgB,EAClB,OAAOC,EAAG,CAAC,UAAW,KAAK,CAAC,CAEhC,OAASC,EAAO,CACVA,aAAiB,OACnB,QAAQ,IAAIA,EAAM,OAAO,CAE7B,CACF",
  "names": ["renew_auth_exports", "__export", "renewAuth", "__toCommonJS", "import_api", "import_node_child_process", "import_node_fs", "preferences", "ExtensionError", "title", "message", "CommandLineMissingError", "getCliPath", "cliPath", "preferences", "path", "CommandLineMissingError", "ZSH_PATH", "errorRegex", "op", "args", "cliPath", "getCliPath", "getSignInStatus", "getCliPath", "renewAuth", "getSignInStatus", "op", "error"]
}
